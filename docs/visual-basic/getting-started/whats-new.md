---
title: Novità in Visual Basic
ms.date: 02/15/2018
ms.prod: .net
ms.technology:
- devlang-visual-basic
ms.topic: article
f1_keywords:
- VB.StartPage.WhatsNew
helpviewer_keywords:
- new features, Visual Basic
- what's new [Visual Basic]
- Visual Basic, what's new
ms.assetid: d7e97396-7f42-4873-a81c-4ebcc4b6ca02
caps.latest.revision: 145
author: rpetrusha
ms.author: ronpet
ms.openlocfilehash: 34c7e7147ce7ae43926de1796bee433667f08331
ms.sourcegitcommit: 86adcc06e35390f13c1e372c36d2e044f1fc31ef
ms.translationtype: HT
ms.contentlocale: it-IT
ms.lasthandoff: 04/26/2018
---
# <a name="whats-new-for-visual-basic"></a><span data-ttu-id="e0a7b-102">Novità in Visual Basic</span><span class="sxs-lookup"><span data-stu-id="e0a7b-102">What's new for Visual Basic</span></span>

<span data-ttu-id="e0a7b-103">Questo argomento elenca i nomi delle funzionalità principali per ogni versione di Visual Basic con le descrizioni dettagliate delle funzionalità nuove e migliorate nell'ultima versione del linguaggio.</span><span class="sxs-lookup"><span data-stu-id="e0a7b-103">This topic lists key feature names for each version of Visual Basic, with detailed descriptions of the new and enhanced features in the lastest version of the language.</span></span>
  
## <a name="current-version"></a><span data-ttu-id="e0a7b-104">Versione corrente</span><span class="sxs-lookup"><span data-stu-id="e0a7b-104">Current Version</span></span>

<span data-ttu-id="e0a7b-105">Visual Basic 15.5</span><span class="sxs-lookup"><span data-stu-id="e0a7b-105">Visual Basic 15.5</span></span>   
<span data-ttu-id="e0a7b-106">Per le funzionalità nuove, vedere [Visual Basic 15.5](#visual-basic-155)</span><span class="sxs-lookup"><span data-stu-id="e0a7b-106">For new features, see [Visual Basic 15.5](#visual-basic-155)</span></span>

## <a name="previous-versions"></a><span data-ttu-id="e0a7b-107">Versioni precedenti</span><span class="sxs-lookup"><span data-stu-id="e0a7b-107">Previous versions</span></span>

<span data-ttu-id="e0a7b-108">Visual Basic 15.3</span><span class="sxs-lookup"><span data-stu-id="e0a7b-108">Visual Basic 15.3</span></span>   
<span data-ttu-id="e0a7b-109">Per le funzionalità nuove, vedere [Visual Basic 15.3](#visual-basic-153)</span><span class="sxs-lookup"><span data-stu-id="e0a7b-109">For new features, see [Visual Basic 15.3](#visual-basic-153)</span></span>

<span data-ttu-id="e0a7b-110">Visual Basic 2017</span><span class="sxs-lookup"><span data-stu-id="e0a7b-110">Visual Basic 2017</span></span>   
<span data-ttu-id="e0a7b-111">Per le funzionalità nuove, vedere [Visual Basic 2017](#visual-basic-2017)</span><span class="sxs-lookup"><span data-stu-id="e0a7b-111">For new features, see [Visual Basic 2017](#visual-basic-2017)</span></span>

<span data-ttu-id="e0a7b-112">Visual Basic/Visual Studio .NET 2015</span><span class="sxs-lookup"><span data-stu-id="e0a7b-112">Visual Basic / Visual Studio .NET 2015</span></span>   
<span data-ttu-id="e0a7b-113">Per le funzionalità nuove, vedere [Visual Basic 14](#visual-basic-14)</span><span class="sxs-lookup"><span data-stu-id="e0a7b-113">For new features, see [Visual Basic 14](#visual-basic-14)</span></span>

<span data-ttu-id="e0a7b-114">Visual Basic/Visual Studio .NET 2013</span><span class="sxs-lookup"><span data-stu-id="e0a7b-114">Visual Basic / Visual Studio .NET 2013</span></span>  
<span data-ttu-id="e0a7b-115">Technology Preview della piattaforma del compilatore .NET ("Roslyn")</span><span class="sxs-lookup"><span data-stu-id="e0a7b-115">Technology previews of the .NET Compiler Platform (“Roslyn”)</span></span>

<span data-ttu-id="e0a7b-116">Visual Basic/Visual Studio .NET 2012</span><span class="sxs-lookup"><span data-stu-id="e0a7b-116">Visual Basic / Visual Studio .NET 2012</span></span>   
<span data-ttu-id="e0a7b-117">Parole chiave `Async` e `await`, iteratori, attributi relativi alle informazioni sul chiamante</span><span class="sxs-lookup"><span data-stu-id="e0a7b-117">`Async` and `await` keywords, iterators, caller info attributes</span></span>

<span data-ttu-id="e0a7b-118">Visual Basic, Visual Studio .NET 2010</span><span class="sxs-lookup"><span data-stu-id="e0a7b-118">Visual Basic, Visual Studio .NET 2010</span></span>   
<span data-ttu-id="e0a7b-119">Proprietà implementate automaticamente, inizializzatori di insieme, continuazione di riga implicita, elementi dinamici, covarianza/controvarianza generica, accesso agli spazi dei nomi globali</span><span class="sxs-lookup"><span data-stu-id="e0a7b-119">Auto-implemented properties, collection initializers, implicit line continuation, dynamic, generic co/contra variance, global namespace access</span></span>

<span data-ttu-id="e0a7b-120">Visual Basic/Visual Studio .NET 2008</span><span class="sxs-lookup"><span data-stu-id="e0a7b-120">Visual Basic / Visual Studio .NET 2008</span></span>   
<span data-ttu-id="e0a7b-121">Language Integrated Query (LINQ), valori letterali XML, inferenza del tipo di variabile locale, inizializzatori di oggetto, tipi anonimi, metodi di estensione, inferenza del tipo `var` locale, espressioni lambda, operatore `if`, metodi parziali, tipi di valore nullable</span><span class="sxs-lookup"><span data-stu-id="e0a7b-121">Language Integrated Query (LINQ), XML literals, local type inference, object initializers, anonymous types, extension methods, local `var` type inference, lambda expressions, `if` operator, partial methods, nullable value types</span></span>  

<span data-ttu-id="e0a7b-122">Visual Basic/Visual Studio .NET 2005</span><span class="sxs-lookup"><span data-stu-id="e0a7b-122">Visual Basic / Visual Studio .NET 2005</span></span>   
<span data-ttu-id="e0a7b-123">Tipo `My` e tipi di helper (accesso all'app, al computer, al file system, alla rete)</span><span class="sxs-lookup"><span data-stu-id="e0a7b-123">The `My` type and helper types (access to app, computer, files system, network)</span></span>

<span data-ttu-id="e0a7b-124">Visual Basic/Visual Studio .NET 2003</span><span class="sxs-lookup"><span data-stu-id="e0a7b-124">Visual Basic / Visual Studio .NET 2003</span></span>   
<span data-ttu-id="e0a7b-125">Operatori di scorrimento bit, dichiarazione di variabile del ciclo</span><span class="sxs-lookup"><span data-stu-id="e0a7b-125">Bit-shift operators, loop variable declaration</span></span>

<span data-ttu-id="e0a7b-126">Visual Basic/Visual Studio .NET 2002</span><span class="sxs-lookup"><span data-stu-id="e0a7b-126">Visual Basic / Visual Studio .NET 2002</span></span>   
<span data-ttu-id="e0a7b-127">Prima versione di Visual Basic .NET</span><span class="sxs-lookup"><span data-stu-id="e0a7b-127">The first release of Visual Basic .NET</span></span>

## <a name="visual-basic-155"></a><span data-ttu-id="e0a7b-128">Visual Basic 15.5</span><span class="sxs-lookup"><span data-stu-id="e0a7b-128">Visual Basic 15.5</span></span>

[<span data-ttu-id="e0a7b-129">Argomenti denominati non finali</span><span class="sxs-lookup"><span data-stu-id="e0a7b-129">Non-trailing named arguments</span></span>](../programming-guide/language-features/procedures/passing-arguments-by-position-and-by-name.md#mixing-arguments-by-position-and-by-name)

<span data-ttu-id="e0a7b-130">In Visual Basic 15.3 e versioni precedenti, quando una chiamata al metodo includeva argomenti in base alla posizione e al nome, gli argomenti posizionali dovevano precedere gli argomenti denominati.</span><span class="sxs-lookup"><span data-stu-id="e0a7b-130">In Visual Basic 15.3 and earlier versions, when a method call included arguments both by position and by name, positional arguments had to precede named arguments.</span></span> <span data-ttu-id="e0a7b-131">A partire da Visual Basic 15,5, gli argomenti posizionali e denominati possono trovarsi in qualsiasi ordine, purché tutti gli argomenti fino all'ultimo argomento posizionale si trovino nella posizione corretta.</span><span class="sxs-lookup"><span data-stu-id="e0a7b-131">Starting with Visual Basic 15.5, positional and named arguments can appear in any order as long as all arguments up to the last positional argument are in the correct position.</span></span> <span data-ttu-id="e0a7b-132">Ciò è particolarmente utile quando gli argomenti denominati vengono utilizzati per rendere il codice più leggibile.</span><span class="sxs-lookup"><span data-stu-id="e0a7b-132">This is particularly useful when named arguments are used to make code more readable.</span></span>

<span data-ttu-id="e0a7b-133">Ad esempio, la seguente chiamata al metodo ha due argomenti posizionali tra un argomento denominato.</span><span class="sxs-lookup"><span data-stu-id="e0a7b-133">For example, the following method call has two positional arguments between a named argument.</span></span> <span data-ttu-id="e0a7b-134">L'argomento denominato chiarisce che il valore 19 rappresenta un'età.</span><span class="sxs-lookup"><span data-stu-id="e0a7b-134">The named argument makes it clear that the value 19 represents an age.</span></span>

```vb
StudentInfo.Display("Mary", age:=19, #9/21/1998#)
```

<span data-ttu-id="e0a7b-135">**Separatore esadecimale/binario/ottali iniziale**</span><span class="sxs-lookup"><span data-stu-id="e0a7b-135">**Leading hex/binary/octal separator**</span></span>

<span data-ttu-id="e0a7b-136">Visual Basic 2017 ha aggiunto il supporto del carattere di sottolineatura (`_`) come separatore di cifre.</span><span class="sxs-lookup"><span data-stu-id="e0a7b-136">Visual Basic 2017 added support for the underscore character (`_`) as a digit separator.</span></span> <span data-ttu-id="e0a7b-137">A partire da Visual Basic 15.5, è possibile usare il carattere di sottolineatura come separatore iniziale tra il prefisso e la cifra esadecimale, binaria o ottale.</span><span class="sxs-lookup"><span data-stu-id="e0a7b-137">Starting with Visual Basic 15.5, you can use the underscore character as a leading separator between the prefix and hexadecimal, binary, or octal digits.</span></span> <span data-ttu-id="e0a7b-138">L'esempio seguente usa il separatore di cifra iniziali per definire 3.271.948.384 come numero esadecimale:</span><span class="sxs-lookup"><span data-stu-id="e0a7b-138">The following example uses a leading digit separator to define 3,271,948,384 as a hexadecimal number:</span></span>

```vb
Dim number As Integer = &H_C305_F860
``` 
<span data-ttu-id="e0a7b-139">Per usare il carattere di sottolineatura come separatore iniziale, è necessario aggiungere l'elemento seguente al file di progetto (\*.vbproj) di Visual Basic:</span><span class="sxs-lookup"><span data-stu-id="e0a7b-139">To use the underscore character as a leading separator, you must add the following element to your Visual Basic project (\*.vbproj) file:</span></span>

```xml
<PropertyGroup>
  <LangVersion>15.5</LangVersion>
</PropertyGroup>
```

## <a name="visual-basic-153"></a><span data-ttu-id="e0a7b-140">Visual Basic 15.3</span><span class="sxs-lookup"><span data-stu-id="e0a7b-140">Visual Basic 15.3</span></span>

[<span data-ttu-id="e0a7b-141">**Inferenza di tupla denominata**</span><span class="sxs-lookup"><span data-stu-id="e0a7b-141">**Named tuple inference**</span></span>](../programming-guide/language-features/data-types/tuples.md#inferred-tuple-element-names)

<span data-ttu-id="e0a7b-142">Quando si assegna il valore di elementi di tupla provenienti da variabili, Visual Basic deduce il nome degli elementi di tupla dai nomi di variabili corrispondenti; non è necessario assegnare esplicitamente un nome a un elemento di tupla.</span><span class="sxs-lookup"><span data-stu-id="e0a7b-142">When you assign the value of tuple elements from variables, Visual Basic infers the name of tuple elements from the corresponding variable names; you do not have to explicitly name a tuple element.</span></span> <span data-ttu-id="e0a7b-143">L'esempio seguente usa l'inferenza per creare una tupla con tre elementi denominati, `state`, `stateName`, e `capital`.</span><span class="sxs-lookup"><span data-stu-id="e0a7b-143">The following example uses inference to create a tuple with three named elements, `state`, `stateName`, and `capital`.</span></span>

[!code-vb[Inferred tuple names](../../../samples/snippets/visualbasic/programming-guide/language-features/data-types/named-tuples/program.vb#2)]

<span data-ttu-id="e0a7b-144">**Nuove opzioni del compilatore**</span><span class="sxs-lookup"><span data-stu-id="e0a7b-144">**Additional compiler switches**</span></span>  

<span data-ttu-id="e0a7b-145">Il compilatore della riga di comando di Visual Basic ora supporta le opzioni [**-refout**](../reference/command-line-compiler/refout-compiler-option.md) e [**-refonly**](../reference/command-line-compiler/refonly-compiler-option.md) per il controllo dell'output degli assembly di riferimento.</span><span class="sxs-lookup"><span data-stu-id="e0a7b-145">The Visual Basic command-line compiler now supports the [**-refout**](../reference/command-line-compiler/refout-compiler-option.md) and [**-refonly**](../reference/command-line-compiler/refonly-compiler-option.md) compiler options to control the output of reference assemblies.</span></span> <span data-ttu-id="e0a7b-146">**-refout** definisce la directory di output dell'assembly di riferimento, mentre **-refonly** specifica che il risultato della compilazione può essere solo un assembly di riferimento.</span><span class="sxs-lookup"><span data-stu-id="e0a7b-146">**-refout** defines the output directory of the reference assembly, and **-refonly** specifies that only a reference assembly is to be output by compilation.</span></span>

## <a name="visual-basic-2017"></a><span data-ttu-id="e0a7b-147">Visual Basic 2017</span><span class="sxs-lookup"><span data-stu-id="e0a7b-147">Visual Basic 2017</span></span>

[<span data-ttu-id="e0a7b-148">**Tuple**</span><span class="sxs-lookup"><span data-stu-id="e0a7b-148">**Tuples**</span></span>](../programming-guide/language-features/data-types/tuples.md)

<span data-ttu-id="e0a7b-149">Le tuple sono una semplice struttura dei dati che viene solitamente usata per restituire più valori da una singola chiamata al metodo.</span><span class="sxs-lookup"><span data-stu-id="e0a7b-149">Tuples are a lightweight data structure that most commonly is used to return multiple values from a single method call.</span></span> <span data-ttu-id="e0a7b-150">In genere, per restituire più valori da un metodo, è necessario eseguire una delle operazioni seguenti:</span><span class="sxs-lookup"><span data-stu-id="e0a7b-150">Ordinarily, to return multiple values from a method, you have to do one of the following:</span></span>

- <span data-ttu-id="e0a7b-151">Definire un tipo personalizzato (`Class` o `Structure`).</span><span class="sxs-lookup"><span data-stu-id="e0a7b-151">Define a custom type (a `Class` or a `Structure`).</span></span> <span data-ttu-id="e0a7b-152">Si tratta di una soluzione complicata.</span><span class="sxs-lookup"><span data-stu-id="e0a7b-152">This is a heavyweight solution.</span></span>

- <span data-ttu-id="e0a7b-153">Definire uno o più parametri `ByRef` e restituire un valore dal metodo.</span><span class="sxs-lookup"><span data-stu-id="e0a7b-153">Define one or more `ByRef` parameters, in addition to returning a value from the method.</span></span>
 
<span data-ttu-id="e0a7b-154">Grazie al supporto per tuple di Visual Basic è possibile definire rapidamente una tupla, assegnare facoltativamente nomi semantici ai rispettivi valori e recuperare rapidamente i relativi valori.</span><span class="sxs-lookup"><span data-stu-id="e0a7b-154">Visual Basic's support for tuples lets you quickly define a tuple, optionally assign semantic names to its values, and quickly retrieve its values.</span></span> <span data-ttu-id="e0a7b-155">L'esempio seguente esegue il wrapping di una chiamata al metodo <xref:System.Int32.TryParse%2A> e restituisce una tupla.</span><span class="sxs-lookup"><span data-stu-id="e0a7b-155">The following example wraps a call to the <xref:System.Int32.TryParse%2A> method and returns a tuple.</span></span>

[!code-vb[Tuple](../../../samples/snippets/visualbasic/programming-guide/language-features/data-types/tuple-returns.vb#2)]

<span data-ttu-id="e0a7b-156">A questo punto è possibile chiamare il metodo e gestire la tupla restituita con codice simile al seguente.</span><span class="sxs-lookup"><span data-stu-id="e0a7b-156">You can then call the method and handle the returned tuple with code like the following.</span></span>

[!code-vb[ReturnTuple](../../../samples/snippets/visualbasic/programming-guide/language-features/data-types/tuple-returns.vb#3)] 

<span data-ttu-id="e0a7b-157">**Valori letterali binari e separatori di cifre**</span><span class="sxs-lookup"><span data-stu-id="e0a7b-157">**Binary literals and digit separators**</span></span>

<span data-ttu-id="e0a7b-158">È possibile definire un valore letterale binario usando il prefisso `&B` o `&b`.</span><span class="sxs-lookup"><span data-stu-id="e0a7b-158">You can define a binary literal by using the prefix `&B` or `&b`.</span></span> <span data-ttu-id="e0a7b-159">È anche possibile usare il carattere di sottolineatura `_` come separatore di cifre per rendere il codice più leggibile.</span><span class="sxs-lookup"><span data-stu-id="e0a7b-159">In addition, you can use the underscore character, `_`, as a digit separator to enhance readability.</span></span> <span data-ttu-id="e0a7b-160">Nell'esempio seguente vengono usate entrambe le funzionalità per assegnare un valore `Byte` e visualizzarlo come un numero decimale, esadecimale e binario.</span><span class="sxs-lookup"><span data-stu-id="e0a7b-160">The following example uses both features to assign a `Byte` value and to display it as a decimal, hexadecimal, and binary number.</span></span>

[!code-vb[Binary](../../../samples/snippets/visualbasic/getting-started/bin-example.vb#1)]

<span data-ttu-id="e0a7b-161">Per altre informazioni, vedere la sezione dedicata alle assegnazioni di valori letterali dei tipi di dati [Byte](../language-reference/data-types/byte-data-type.md#literal-assignments), [Integer](../language-reference/data-types/integer-data-type.md#literal-assignments), [Long](../language-reference/data-types/long-data-type.md#literal-assignments), [Short](../language-reference/data-types/short-data-type.md#literal-assignments), [SByte](../language-reference/data-types/sbyte-data-type.md#literal-assignments), [UInteger](../language-reference/data-types/uinteger-data-type.md#literal-assignments), [ULong](../language-reference/data-types/ulong-data-type.md#literal-assignments) e [UShort](../language-reference/data-types/ushort-data-type.md#literal-assignments).</span><span class="sxs-lookup"><span data-stu-id="e0a7b-161">For more information, see the "Literal assignments" section of the [Byte](../language-reference/data-types/byte-data-type.md#literal-assignments), [Integer](../language-reference/data-types/integer-data-type.md#literal-assignments), [Long](../language-reference/data-types/long-data-type.md#literal-assignments), [Short](../language-reference/data-types/short-data-type.md#literal-assignments), [SByte](../language-reference/data-types/sbyte-data-type.md#literal-assignments), [UInteger](../language-reference/data-types/uinteger-data-type.md#literal-assignments), [ULong](../language-reference/data-types/ulong-data-type.md#literal-assignments), and [UShort](../language-reference/data-types/ushort-data-type.md#literal-assignments) data types.</span></span>

<span data-ttu-id="e0a7b-162">**Supporto per valori di riferimento restituiti C#** </span><span class="sxs-lookup"><span data-stu-id="e0a7b-162">**Support for C# reference return values**</span></span>

<span data-ttu-id="e0a7b-163">A partire dalla versione 7.0, C# supporta i valori di riferimento restituiti.</span><span class="sxs-lookup"><span data-stu-id="e0a7b-163">Starting with C# 7.0, C# supports reference return values.</span></span> <span data-ttu-id="e0a7b-164">Pertanto, quando la chiamata al metodo riceve un valore di riferimento restituito, lo può modificare.</span><span class="sxs-lookup"><span data-stu-id="e0a7b-164">That is, when the calling method receives a value returned by reference, it can change the value of the reference.</span></span> <span data-ttu-id="e0a7b-165">Visual Basic non consente di creare metodi con valori di riferimento restituiti, ma consente di usare e modificare tali valori.</span><span class="sxs-lookup"><span data-stu-id="e0a7b-165">Visual Basic does not allow you to author methods with reference return values, but it does allow you to consume and modify the reference return values.</span></span>

<span data-ttu-id="e0a7b-166">Ad esempio, la classe `Sentence` seguente scritta in C# include un metodo `FindNext` che rileva la parola successiva in una frase che inizia con una sottostringa specificata.</span><span class="sxs-lookup"><span data-stu-id="e0a7b-166">For example, the following `Sentence` class written in C# includes a `FindNext` method that finds the next word in a sentence that begins with a specified substring.</span></span> <span data-ttu-id="e0a7b-167">La stringa viene restituita come valore di riferimento restituito. Una variabile `Boolean` passata dal riferimento al metodo indica se la ricerca ha avuto esito positivo.</span><span class="sxs-lookup"><span data-stu-id="e0a7b-167">The string is returned as a reference return value, and a `Boolean` variable passed by reference to the method indicates whether the search was successful.</span></span> <span data-ttu-id="e0a7b-168">A questo punto il chiamante non solo può leggere il valore restituito, ma lo può anche modificare. Tale modifica si riflette sulla classe `Sentence`.</span><span class="sxs-lookup"><span data-stu-id="e0a7b-168">This means that the caller can not only read the returned value; he or she can also modify it, and that modification is reflected in the `Sentence` class.</span></span>

[!code-csharp[Ref-Return](../../../samples/snippets/visualbasic/getting-started/ref-returns.cs)]

<span data-ttu-id="e0a7b-169">In parole semplici, è possibile modificare la parola trovata nella frase usando un codice simile al seguente.</span><span class="sxs-lookup"><span data-stu-id="e0a7b-169">In its simplest form, you can modify the word found in the sentence by using code like the following.</span></span> <span data-ttu-id="e0a7b-170">Si noti che non si sta assegnando un valore al metodo, ma all'espressione che il metodo restituisce, ovvero il valore di riferimento restituito.</span><span class="sxs-lookup"><span data-stu-id="e0a7b-170">Note that you are not assigning a value to the method, but rather to the expression that the method returns, which is the reference return value.</span></span>

[!code-vb[Ref-Return](../../../samples/snippets/visualbasic/getting-started/ref-return.vb#1)]

<span data-ttu-id="e0a7b-171">Esiste tuttavia un problema con questo codice. Se non viene trovata una corrispondenza, il metodo restituisce la prima parola.</span><span class="sxs-lookup"><span data-stu-id="e0a7b-171">A problem with this code, though, is that if a match is not found, the method returns the first word.</span></span> <span data-ttu-id="e0a7b-172">L'esempio non esamina il valore dell'argomento `Boolean` per determinare se viene trovata una corrispondenza. Modifica quindi la prima parola se non esiste corrispondenza.</span><span class="sxs-lookup"><span data-stu-id="e0a7b-172">Since the example does not examine the value of the `Boolean` argument to determine whether a match is found, it modifies the first word if there is no match.</span></span> <span data-ttu-id="e0a7b-173">Nell'esempio seguente questo problema viene risolto sostituendo la prima parola con la parola stessa se non esiste corrispondenza.</span><span class="sxs-lookup"><span data-stu-id="e0a7b-173">The following example corrects this by replacing the first word with itself if there is no match.</span></span>

[!code-vb[Ref-Return](../../../samples/snippets/visualbasic/getting-started/ref-return.vb#2)]

<span data-ttu-id="e0a7b-174">Una soluzione migliore consiste nell'usare un metodo helper al quale il riferimento passa il valore di riferimento restituito.</span><span class="sxs-lookup"><span data-stu-id="e0a7b-174">A better solution is to use a helper method to which the reference return value is passed by reference.</span></span> <span data-ttu-id="e0a7b-175">Il metodo helper può quindi modificare l'argomento passato dal riferimento.</span><span class="sxs-lookup"><span data-stu-id="e0a7b-175">The helper method can then modify the argument passed to it by reference.</span></span> <span data-ttu-id="e0a7b-176">Nell'esempio seguente viene eseguita questa operazione.</span><span class="sxs-lookup"><span data-stu-id="e0a7b-176">The following example does that.</span></span>

[!code-vb[Ref-Return](../../../samples/snippets/visualbasic/getting-started/ref-return-helper.vb#1)]

<span data-ttu-id="e0a7b-177">Per altre informazioni, vedere [Reference Return Values](../programming-guide/language-features/procedures/ref-return-values.md) (Valori di riferimento restituiti).</span><span class="sxs-lookup"><span data-stu-id="e0a7b-177">For more information, see [Reference Return Values](../programming-guide/language-features/procedures/ref-return-values.md).</span></span>

## <a name="visual-basic-14"></a><span data-ttu-id="e0a7b-178">Visual Basic 14</span><span class="sxs-lookup"><span data-stu-id="e0a7b-178">Visual Basic 14</span></span>

[<span data-ttu-id="e0a7b-179">Nameof</span><span class="sxs-lookup"><span data-stu-id="e0a7b-179">Nameof</span></span>](../../csharp/language-reference/keywords/nameof.md)  
 <span data-ttu-id="e0a7b-180">È possibile ottenere il nome di stringa non qualificato di un tipo o di un membro, da usare in un messaggio di errore senza definire una stringa a livello di codice.</span><span class="sxs-lookup"><span data-stu-id="e0a7b-180">You can get the unqualified string name of a type or member for use in an error message without hard coding a string.</span></span>  <span data-ttu-id="e0a7b-181">In questo modo il codice sarà corretto anche durante il refactoring.</span><span class="sxs-lookup"><span data-stu-id="e0a7b-181">This allows your code to remain correct when refactoring.</span></span>  <span data-ttu-id="e0a7b-182">Questa funzionalità è utile anche per l'associazione di collegamenti MVC (Modello-Vista-Controller) e la generazione di eventi di modifica di proprietà.</span><span class="sxs-lookup"><span data-stu-id="e0a7b-182">This feature is also useful for hooking up model-view-controller MVC links and firing property changed events.</span></span>  
  
[<span data-ttu-id="e0a7b-183">Interpolazione di stringhe</span><span class="sxs-lookup"><span data-stu-id="e0a7b-183">String Interpolation</span></span>](../../visual-basic/programming-guide/language-features/strings/interpolated-strings.md)  
 <span data-ttu-id="e0a7b-184">È possibile usare espressioni di interpolazione di stringhe per costruire stringhe.</span><span class="sxs-lookup"><span data-stu-id="e0a7b-184">You can use string interpolation expressions to construct strings.</span></span>  <span data-ttu-id="e0a7b-185">Un'espressione di stringa interpolata è simile a una stringa di modello che contiene espressioni.</span><span class="sxs-lookup"><span data-stu-id="e0a7b-185">An interpolated string expression looks like a template string that contains expressions.</span></span>  <span data-ttu-id="e0a7b-186">In relazione agli argomenti, è più facile comprendere una stringa interpolata che la [formattazione composita](../../standard/base-types/composite-format.md).</span><span class="sxs-lookup"><span data-stu-id="e0a7b-186">An interpolated string is easier to understand with respect to arguments than [Composite Formatting](../../standard/base-types/composite-format.md).</span></span>  
  
[<span data-ttu-id="e0a7b-187">Indicizzazione e accesso ai membri condizionali null</span><span class="sxs-lookup"><span data-stu-id="e0a7b-187">Null-conditional Member Access and Indexing</span></span>](../../csharp/language-reference/operators/null-conditional-operators.md)  
<span data-ttu-id="e0a7b-188">È possibile verificare la presenza di valori null con una sintassi molto leggera prima di eseguire un'operazione di accesso ai membri (`?.`) o di indice (`?[]`).</span><span class="sxs-lookup"><span data-stu-id="e0a7b-188">You can test for null in a very light syntactic way before performing a member access (`?.`) or index (`?[]`) operation.</span></span>  <span data-ttu-id="e0a7b-189">Questi operatori consentono di scrivere meno codice per gestire i controlli null, soprattutto per l'ordinamento decrescente delle strutture di dati.</span><span class="sxs-lookup"><span data-stu-id="e0a7b-189">These operators help you write less code to handle null checks, especially for descending into data structures.</span></span>  <span data-ttu-id="e0a7b-190">Se l'operando di sinistra o il riferimento a un oggetto è null, le operazioni restituiscono null.</span><span class="sxs-lookup"><span data-stu-id="e0a7b-190">If the left operand or object reference is null, the operations returns null.</span></span>  
  
[<span data-ttu-id="e0a7b-191">Valori letterali stringa multilinea</span><span class="sxs-lookup"><span data-stu-id="e0a7b-191">Multi-line String Literals</span></span>](../../visual-basic/programming-guide/language-features/strings/string-basics.md)  
 <span data-ttu-id="e0a7b-192">I valori letterali stringa possono contenere sequenze di nuove righe.</span><span class="sxs-lookup"><span data-stu-id="e0a7b-192">String literals can contain newline sequences.</span></span>  <span data-ttu-id="e0a7b-193">Non è più necessario usare `<xml><![CDATA[...text with newlines...]]></xml>.Value` come soluzione alternativa.</span><span class="sxs-lookup"><span data-stu-id="e0a7b-193">You no longer need the old work around of using `<xml><![CDATA[...text with newlines...]]></xml>.Value`</span></span>  
  
<span data-ttu-id="e0a7b-194">Commenti</span><span class="sxs-lookup"><span data-stu-id="e0a7b-194">Comments</span></span>  
<span data-ttu-id="e0a7b-195">È possibile inserire commenti dopo le continuazioni di riga implicita, all'interno delle espressioni dell'inizializzatore e tra i termini delle espressioni LINQ.</span><span class="sxs-lookup"><span data-stu-id="e0a7b-195">You can put comments after implicit line continuations, inside initializer expressions, and amongst LINQ expression terms.</span></span>  
  
 <span data-ttu-id="e0a7b-196">Risoluzione dei nomi completi più intelligente</span><span class="sxs-lookup"><span data-stu-id="e0a7b-196">Smarter Fully-qualified Name Resolution</span></span>  
 <span data-ttu-id="e0a7b-197">In precedenza, con un codice come `Threading.Thread.Sleep(1000)`, Visual Basic cercava lo spazio dei nomi "Threading", individuava un'ambiguità tra System.Threading e System.Windows.Threading e quindi segnalava un errore.</span><span class="sxs-lookup"><span data-stu-id="e0a7b-197">Given code such as `Threading.Thread.Sleep(1000)`, Visual Basic used to look up the namespace "Threading", discover it was ambiguous between System.Threading and System.Windows.Threading, and then report an error.</span></span>  <span data-ttu-id="e0a7b-198">Visual Basic ora prende in considerazione entrambi gli spazi dei nomi possibili.</span><span class="sxs-lookup"><span data-stu-id="e0a7b-198">Visual Basic now considers both possible namespaces together.</span></span>  <span data-ttu-id="e0a7b-199">Se si visualizza l'elenco di completamento, l'editor di Visual Studio elenca i membri di entrambi i tipi in questo elenco.</span><span class="sxs-lookup"><span data-stu-id="e0a7b-199">If you show the completion list, the Visual Studio editor lists members from both types in the completion list.</span></span>  
  
 <span data-ttu-id="e0a7b-200">Valori letterali data con anno all'inizio</span><span class="sxs-lookup"><span data-stu-id="e0a7b-200">Year-first Date Literals</span></span>  
 <span data-ttu-id="e0a7b-201">I valori letterali data possono avere il formato aaaa-mm-gg, `#2015-03-17 16:10 PM#`.</span><span class="sxs-lookup"><span data-stu-id="e0a7b-201">You can have date literals in yyyy-mm-dd format, `#2015-03-17 16:10 PM#`.</span></span>  
  
 <span data-ttu-id="e0a7b-202">Proprietà dell'interfaccia readonly</span><span class="sxs-lookup"><span data-stu-id="e0a7b-202">Readonly Interface Properties</span></span>  
 <span data-ttu-id="e0a7b-203">È possibile implementare proprietà dell'interfaccia readonly usando una proprietà readonly.</span><span class="sxs-lookup"><span data-stu-id="e0a7b-203">You can implement readonly interface properties using a readwrite property.</span></span>  <span data-ttu-id="e0a7b-204">L'interfaccia garantisce la funzionalità minima e le classi di implementazione non smettono di consentire l'impostazione della proprietà.</span><span class="sxs-lookup"><span data-stu-id="e0a7b-204">The interface guarantees minimum functionality, and it does not stop an implementing class from allowing the property to be set.</span></span>  
  
 [<span data-ttu-id="e0a7b-205">TypeOf \<espressione> IsNot \<tipo></span><span class="sxs-lookup"><span data-stu-id="e0a7b-205">TypeOf \<expr> IsNot \<type></span></span>](../../visual-basic/language-reference/operators/typeof-operator.md)  
 <span data-ttu-id="e0a7b-206">Per una maggiore leggibilità del codice, ora è possibile usare `TypeOf` con `IsNot`.</span><span class="sxs-lookup"><span data-stu-id="e0a7b-206">For more readability of your code, you can now use `TypeOf` with `IsNot`.</span></span>  
  
 [<span data-ttu-id="e0a7b-207">#Disable Warning \<ID> e #Enable Warning \<ID></span><span class="sxs-lookup"><span data-stu-id="e0a7b-207">#Disable Warning \<ID> and #Enable Warning \<ID></span></span>](../../visual-basic/language-reference/directives/directives.md)  
 <span data-ttu-id="e0a7b-208">È possibile disabilitare e abilitare avvisi specifici per le aree all'interno di un file di origine.</span><span class="sxs-lookup"><span data-stu-id="e0a7b-208">You can disable and enable specific warnings for regions within a source file.</span></span>  
  
 <span data-ttu-id="e0a7b-209">Miglioramenti dei commenti ai documenti XML</span><span class="sxs-lookup"><span data-stu-id="e0a7b-209">XML Doc-comment Improvements</span></span>  
 <span data-ttu-id="e0a7b-210">Quando si scrivono commenti ai documenti, si accede a Smart Editor e al supporto per la compilazione per la convalida di nomi di parametro, la corretta gestione di `crefs` (generics, operatori e così via), la colorazione e il refactoring.</span><span class="sxs-lookup"><span data-stu-id="e0a7b-210">When writing doc comments, you get smart editor and build support for validating parameter names, proper handling of `crefs` (generics, operators, etc.), colorizing, and refactoring.</span></span>  
  
 [<span data-ttu-id="e0a7b-211">Definizioni di interfacce e moduli parziali</span><span class="sxs-lookup"><span data-stu-id="e0a7b-211">Partial Module and Interface Definitions</span></span>](../../visual-basic/language-reference/modifiers/partial.md)  
 <span data-ttu-id="e0a7b-212">Oltre a classi e struct, è possibile dichiarare interfacce e moduli parziali.</span><span class="sxs-lookup"><span data-stu-id="e0a7b-212">In addition to classes and structs, you can declare partial modules and interfaces.</span></span>  
  
 [<span data-ttu-id="e0a7b-213">Direttive #Region in corpi di metodo</span><span class="sxs-lookup"><span data-stu-id="e0a7b-213">#Region Directives inside Method Bodies</span></span>](../../visual-basic/language-reference/directives/region-directive.md)  
 <span data-ttu-id="e0a7b-214">È possibile inserire delimitatori #Region...#End Region in qualsiasi punto di un file, nelle funzioni o nei corpi delle funzioni.</span><span class="sxs-lookup"><span data-stu-id="e0a7b-214">You can put #Region…#End Region delimiters anywhere in a file, inside functions, and even spanning across function bodies.</span></span>  
  
 [<span data-ttu-id="e0a7b-215">Le definizioni Overrides sono overload impliciti</span><span class="sxs-lookup"><span data-stu-id="e0a7b-215">Overrides Definitions are Implicitly Overloads</span></span>](../../visual-basic/language-reference/modifiers/overrides.md)  
 <span data-ttu-id="e0a7b-216">Se si aggiunge il modificatore `Overrides` a una definizione, il compilatore aggiunge in modo implicito `Overloads`. In questo modo è possibile digitare meno codice nella maggior parte dei casi.</span><span class="sxs-lookup"><span data-stu-id="e0a7b-216">If you add the `Overrides` modifier to a definition, the compiler implicitly adds `Overloads` so that you can type less code in common cases.</span></span>  
  
 <span data-ttu-id="e0a7b-217">CObj consentito negli argomenti degli attributi</span><span class="sxs-lookup"><span data-stu-id="e0a7b-217">CObj Allowed in Attributes Arguments</span></span>  
 <span data-ttu-id="e0a7b-218">Il compilatore generava un errore indicante che CObj(...), se usato nelle costruzioni degli attributi, non era una costante.</span><span class="sxs-lookup"><span data-stu-id="e0a7b-218">The compiler used to give an error that CObj(…) was not a constant when used in attribute constructions.</span></span>  
  
 <span data-ttu-id="e0a7b-219">Dichiarazione e utilizzo di metodi ambigui da interfacce diverse</span><span class="sxs-lookup"><span data-stu-id="e0a7b-219">Declaring and Consuming Ambiguous Methods from Different Interfaces</span></span>  
 <span data-ttu-id="e0a7b-220">In precedenza il codice seguente restituiva errori che impedivano di dichiarare `IMock` o di chiamare `GetDetails` (se questi erano stati dichiarati in c#):</span><span class="sxs-lookup"><span data-stu-id="e0a7b-220">Previously the following code yielded errors that prevented you from declaring `IMock` or from calling `GetDetails` (if these had been declared in C#):</span></span>  
  
```vb  
Interface ICustomer  
  Sub GetDetails(x As Integer)  
End Interface  
  
Interface ITime  
  Sub GetDetails(x As String)  
End Interface  
  
Interface IMock : Inherits ICustomer, ITime  
  Overloads Sub GetDetails(x As Char)  
End Interface  
  
Interface IMock2 : Inherits ICustomer, ITime  
End Interface  
```  
  
 <span data-ttu-id="e0a7b-221">Ora il compilatore userà le normali regole di risoluzione dell'overload per scegliere l'oggetto `GetDetails` più appropriato da chiamare ed è possibile dichiarare le relazioni tre le interfacce in Visual Basic, come quelle mostrate nell'esempio.</span><span class="sxs-lookup"><span data-stu-id="e0a7b-221">Now the compiler will use normal overload resolution rules to choose the most appropriate `GetDetails` to call, and you can declare interface relationships in Visual Basic like those shown in the sample.</span></span>  
  
## <a name="see-also"></a><span data-ttu-id="e0a7b-222">Vedere anche</span><span class="sxs-lookup"><span data-stu-id="e0a7b-222">See also</span></span>  
 [<span data-ttu-id="e0a7b-223">Novità di Visual Studio 2017</span><span class="sxs-lookup"><span data-stu-id="e0a7b-223">What's New in Visual Studio 2017</span></span>](/visualstudio/ide/whats-new-in-visual-studio)
