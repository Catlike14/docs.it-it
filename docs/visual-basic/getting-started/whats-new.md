---
title: "Novità in Visual Basic"
ms.date: 2017-04-27
ms.prod: .net
ms.technology:
- devlang-visual-basic
ms.topic: article
f1_keywords:
- VB.StartPage.WhatsNew
dev_langs:
- VB
helpviewer_keywords:
- new features, Visual Basic
- what's new [Visual Basic]
- Visual Basic, what's new
ms.assetid: d7e97396-7f42-4873-a81c-4ebcc4b6ca02
caps.latest.revision: 145
author: rpetrusha
ms.author: ronpet
translation.priority.ht:
- cs-cz
- de-de
- es-es
- fr-fr
- it-it
- ja-jp
- ko-kr
- pl-pl
- pt-br
- ru-ru
- tr-tr
- zh-cn
- zh-tw
ms.translationtype: HT
ms.sourcegitcommit: 306c608dc7f97594ef6f72ae0f5aaba596c936e1
ms.openlocfilehash: 0a9379d5dd2d1c6b3ed6820e350c19fb346ac84c
ms.contentlocale: it-it
ms.lasthandoff: 07/28/2017

---
# <a name="whats-new-for-visual-basic"></a><span data-ttu-id="53cf1-102">Novità in Visual Basic</span><span class="sxs-lookup"><span data-stu-id="53cf1-102">What's new for Visual Basic</span></span>

<span data-ttu-id="53cf1-103">Questo argomento elenca i nomi delle funzionalità principali per ogni versione di Visual Basic con le descrizioni dettagliate delle funzionalità nuove e migliorate nell'ultima versione del linguaggio.</span><span class="sxs-lookup"><span data-stu-id="53cf1-103">This topic lists key feature names for each version of Visual Basic, with detailed descriptions of the new and enhanced features in the lastest version of the language.</span></span>
  
## <a name="current-version"></a><span data-ttu-id="53cf1-104">Versione corrente</span><span class="sxs-lookup"><span data-stu-id="53cf1-104">Current Version</span></span>

<span data-ttu-id="53cf1-105">Visual Basic / Visual Studio .NET 2017</span><span class="sxs-lookup"><span data-stu-id="53cf1-105">Visual Basic / Visual Studio .NET 2017</span></span>   
<span data-ttu-id="53cf1-106">Per le funzionalità nuove, vedere [Visual Basic 2017](#visual-basic-2017)</span><span class="sxs-lookup"><span data-stu-id="53cf1-106">For new features, see [Visual Basic 2017](#visual-basic-2017)</span></span>

## <a name="previous-versions"></a><span data-ttu-id="53cf1-107">Versioni precedenti</span><span class="sxs-lookup"><span data-stu-id="53cf1-107">Previous versions</span></span>

<span data-ttu-id="53cf1-108">Visual Basic/Visual Studio .NET 2015</span><span class="sxs-lookup"><span data-stu-id="53cf1-108">Visual Basic / Visual Studio .NET 2015</span></span>   
<span data-ttu-id="53cf1-109">Per le funzionalità nuove, vedere [Visual Basic 14](#visual-basic-14)</span><span class="sxs-lookup"><span data-stu-id="53cf1-109">For new features, see [Visual Basic 14](#visual-basic-14)</span></span>

<span data-ttu-id="53cf1-110">Visual Basic/Visual Studio .NET 2013</span><span class="sxs-lookup"><span data-stu-id="53cf1-110">Visual Basic / Visual Studio .NET 2013</span></span>  
<span data-ttu-id="53cf1-111">Technology Preview della piattaforma del compilatore .NET ("Roslyn")</span><span class="sxs-lookup"><span data-stu-id="53cf1-111">Technology previews of the .NET Compiler Platform (“Roslyn”)</span></span>

<span data-ttu-id="53cf1-112">Visual Basic/Visual Studio .NET 2012</span><span class="sxs-lookup"><span data-stu-id="53cf1-112">Visual Basic / Visual Studio .NET 2012</span></span>   
<span data-ttu-id="53cf1-113">Parole chiave `Async` e `await`, iteratori, attributi relativi alle informazioni sul chiamante</span><span class="sxs-lookup"><span data-stu-id="53cf1-113">`Async` and `await` keywords, iterators, caller info attributes</span></span>

<span data-ttu-id="53cf1-114">Visual Basic, Visual Studio .NET 2010</span><span class="sxs-lookup"><span data-stu-id="53cf1-114">Visual Basic, Visual Studio .NET 2010</span></span>   
<span data-ttu-id="53cf1-115">Proprietà implementate automaticamente, inizializzatori di insieme, continuazione di riga implicita, elementi dinamici, covarianza/controvarianza generica, accesso agli spazi dei nomi globali</span><span class="sxs-lookup"><span data-stu-id="53cf1-115">Auto-implemented properties, collection initializers, implicit line continuation, dynamic, generic co/contra variance, global namespace access</span></span>

<span data-ttu-id="53cf1-116">Visual Basic/Visual Studio .NET 2008</span><span class="sxs-lookup"><span data-stu-id="53cf1-116">Visual Basic / Visual Studio .NET 2008</span></span>   
<span data-ttu-id="53cf1-117">Language Integrated Query (LINQ), valori letterali XML, inferenza del tipo di variabile locale, inizializzatori di oggetto, tipi anonimi, metodi di estensione, inferenza del tipo `var` locale, espressioni lambda, operatore `if`, metodi parziali, tipi di valore nullable</span><span class="sxs-lookup"><span data-stu-id="53cf1-117">Language Integrated Query (LINQ), XML literals, local type inference, object initializers, anonymous types, extension methods, local `var` type inference, lambda expressions, `if` operator, partial methods, nullable value types</span></span>  

<span data-ttu-id="53cf1-118">Visual Basic/Visual Studio .NET 2005</span><span class="sxs-lookup"><span data-stu-id="53cf1-118">Visual Basic / Visual Studio .NET 2005</span></span>   
<span data-ttu-id="53cf1-119">Tipo `My` e tipi di helper (accesso all'app, al computer, al file system, alla rete)</span><span class="sxs-lookup"><span data-stu-id="53cf1-119">The `My` type and helper types (access to app, computer, files system, network)</span></span>

<span data-ttu-id="53cf1-120">Visual Basic/Visual Studio .NET 2003</span><span class="sxs-lookup"><span data-stu-id="53cf1-120">Visual Basic / Visual Studio .NET 2003</span></span>   
<span data-ttu-id="53cf1-121">Operatori di scorrimento bit, dichiarazione di variabile del ciclo</span><span class="sxs-lookup"><span data-stu-id="53cf1-121">Bit-shift operators, loop variable declaration</span></span>

<span data-ttu-id="53cf1-122">Visual Basic/Visual Studio .NET 2002</span><span class="sxs-lookup"><span data-stu-id="53cf1-122">Visual Basic / Visual Studio .NET 2002</span></span>   
<span data-ttu-id="53cf1-123">Prima versione di Visual Basic .NET</span><span class="sxs-lookup"><span data-stu-id="53cf1-123">The first release of Visual Basic .NET</span></span>

## <a name="visual-basic-2017"></a><span data-ttu-id="53cf1-124">Visual Basic 2017</span><span class="sxs-lookup"><span data-stu-id="53cf1-124">Visual Basic 2017</span></span>

[<span data-ttu-id="53cf1-125">Tuple</span><span class="sxs-lookup"><span data-stu-id="53cf1-125">Tuples</span></span>](../programming-guide/language-features/data-types/tuples.md)

<span data-ttu-id="53cf1-126">Le tuple sono una semplice struttura dei dati che viene solitamente usata per restituire più valori da una singola chiamata al metodo.</span><span class="sxs-lookup"><span data-stu-id="53cf1-126">Tuples are a lightweight data structure that most commonly is used to return multiple values from a single method call.</span></span> <span data-ttu-id="53cf1-127">In genere, per restituire più valori da un metodo, è necessario eseguire una delle operazioni seguenti:</span><span class="sxs-lookup"><span data-stu-id="53cf1-127">Ordinarily, to return multiple values from a method, you have to do one of the following:</span></span>

- <span data-ttu-id="53cf1-128">Definire un tipo personalizzato (`Class` o `Structure`).</span><span class="sxs-lookup"><span data-stu-id="53cf1-128">Define a custom type (a `Class` or a `Structure`).</span></span> <span data-ttu-id="53cf1-129">Si tratta di una soluzione complicata.</span><span class="sxs-lookup"><span data-stu-id="53cf1-129">This is a heavyweight solution.</span></span>

- <span data-ttu-id="53cf1-130">Definire uno o più parametri `ByRef` e restituire un valore dal metodo.</span><span class="sxs-lookup"><span data-stu-id="53cf1-130">Define one or more `ByRef` parameters, in addition to returning a value from the method.</span></span>
 
<span data-ttu-id="53cf1-131">Grazie al supporto per tuple di Visual Basic è possibile definire rapidamente una tupla, assegnare facoltativamente nomi semantici ai rispettivi valori e recuperare rapidamente i relativi valori.</span><span class="sxs-lookup"><span data-stu-id="53cf1-131">Visual Basic's support for tuples lets you quickly define a tuple, optionally assign semantic names to its values, and quickly retrieve its values.</span></span> <span data-ttu-id="53cf1-132">L'esempio seguente esegue il wrapping di una chiamata al metodo <xref:System.Int32.TryParse%2A> e restituisce una tupla.</span><span class="sxs-lookup"><span data-stu-id="53cf1-132">The following example wraps a call to the <xref:System.Int32.TryParse%2A> method and returns a tuple.</span></span>

<span data-ttu-id="53cf1-133">[!code-vb[Tuple](../../../samples/snippets/visualbasic/programming-guide/language-features/data-types/tuple-returns.vb#2)]</span><span class="sxs-lookup"><span data-stu-id="53cf1-133">[!code-vb[Tuple](../../../samples/snippets/visualbasic/programming-guide/language-features/data-types/tuple-returns.vb#2)]</span></span>

<span data-ttu-id="53cf1-134">A questo punto è possibile chiamare il metodo e gestire la tupla restituita con codice simile al seguente.</span><span class="sxs-lookup"><span data-stu-id="53cf1-134">You can then call the method and handle the returned tuple with code like the following.</span></span>

<span data-ttu-id="53cf1-135">[!code-vb[ReturnTuple](../../../samples/snippets/visualbasic/programming-guide/language-features/data-types/tuple-returns.vb#3)]</span><span class="sxs-lookup"><span data-stu-id="53cf1-135">[!code-vb[ReturnTuple](../../../samples/snippets/visualbasic/programming-guide/language-features/data-types/tuple-returns.vb#3)]</span></span> 

<span data-ttu-id="53cf1-136">**Valori letterali binari e separatori di cifre**</span><span class="sxs-lookup"><span data-stu-id="53cf1-136">**Binary literals and digit separators**</span></span>

<span data-ttu-id="53cf1-137">È possibile definire un valore letterale binario usando il prefisso `&B` o `&b`.</span><span class="sxs-lookup"><span data-stu-id="53cf1-137">You can define a binary literal by using the prefix `&B` or `&b`.</span></span> <span data-ttu-id="53cf1-138">È anche possibile usare il carattere di sottolineatura `_` come separatore di cifre per rendere il codice più leggibile.</span><span class="sxs-lookup"><span data-stu-id="53cf1-138">In addition, you can use the underscore character, `_`, as a digit separator to enhance readability.</span></span> <span data-ttu-id="53cf1-139">Nell'esempio seguente vengono usate entrambe le funzionalità per assegnare un valore `Byte` e visualizzarlo come un numero decimale, esadecimale e binario.</span><span class="sxs-lookup"><span data-stu-id="53cf1-139">The following example uses both features to assign a `Byte` value and to display it as a decimal, hexadecimal, and binary number.</span></span>

<span data-ttu-id="53cf1-140">[!code-vb[Binary](../../../samples/snippets/visualbasic/getting-started/bin-example.vb#1)]</span><span class="sxs-lookup"><span data-stu-id="53cf1-140">[!code-vb[Binary](../../../samples/snippets/visualbasic/getting-started/bin-example.vb#1)]</span></span>

<span data-ttu-id="53cf1-141">Per altre informazioni, vedere la sezione dedicata alle assegnazioni di valori letterali dei tipi di dati [Byte](../language-reference/data-types/byte-data-type.md#literal-assignments), [Integer](../language-reference/data-types/integer-data-type.md#literal-assignments), [Long](../language-reference/data-types/long-data-type.md#literal-assignments), [Short](../language-reference/data-types/short-data-type.md#literal-assignments), [SByte](../language-reference/data-types/sbyte-data-type.md#literal-assignments), [UInteger](../language-reference/data-types/uinteger-data-type.md#literal-assignments), [ULong](../language-reference/data-types/ulong-data-type.md#literal-assignments) e [UShort](../language-reference/data-types/ushort-data-type.md#literal-assignments).</span><span class="sxs-lookup"><span data-stu-id="53cf1-141">For more information, see the "Literal assignments" section of the [Byte](../language-reference/data-types/byte-data-type.md#literal-assignments), [Integer](../language-reference/data-types/integer-data-type.md#literal-assignments), [Long](../language-reference/data-types/long-data-type.md#literal-assignments), [Short](../language-reference/data-types/short-data-type.md#literal-assignments), [SByte](../language-reference/data-types/sbyte-data-type.md#literal-assignments), [UInteger](../language-reference/data-types/uinteger-data-type.md#literal-assignments), [ULong](../language-reference/data-types/ulong-data-type.md#literal-assignments), and [UShort](../language-reference/data-types/ushort-data-type.md#literal-assignments) data types.</span></span>

<span data-ttu-id="53cf1-142">**Supporto per valori di riferimento restituiti C#** </span><span class="sxs-lookup"><span data-stu-id="53cf1-142">**Support for C# reference return values**</span></span>

<span data-ttu-id="53cf1-143">A partire da C# 7, C# supporta i valori di riferimento restituiti.</span><span class="sxs-lookup"><span data-stu-id="53cf1-143">Starting with C# 7, C# supports reference return values.</span></span> <span data-ttu-id="53cf1-144">Pertanto, quando la chiamata al metodo riceve un valore di riferimento restituito, lo può modificare.</span><span class="sxs-lookup"><span data-stu-id="53cf1-144">That is, when the calling method receives a value returned by reference, it can change the value of the reference.</span></span> <span data-ttu-id="53cf1-145">Visual Basic non consente di creare metodi con valori di riferimento restituiti, ma consente di usare e modificare tali valori.</span><span class="sxs-lookup"><span data-stu-id="53cf1-145">Visual Basic does not allow you to author methods with reference return values, but it does allow you to consume and modify the reference return values.</span></span>

<span data-ttu-id="53cf1-146">Ad esempio, la classe `Sentence` seguente scritta in C# include un metodo `FindNext` che rileva la parola successiva in una frase che inizia con una sottostringa specificata.</span><span class="sxs-lookup"><span data-stu-id="53cf1-146">For example, the following `Sentence` class written in C# includes a `FindNext` method that finds the next word in a sentence that begins with a specified substring.</span></span> <span data-ttu-id="53cf1-147">La stringa viene restituita come valore di riferimento restituito. Una variabile `Boolean` passata dal riferimento al metodo indica se la ricerca ha avuto esito positivo.</span><span class="sxs-lookup"><span data-stu-id="53cf1-147">The string is returned as a reference return value, and a `Boolean` variable passed by reference to the method indicates whether the search was successful.</span></span> <span data-ttu-id="53cf1-148">A questo punto il chiamante non solo può leggere il valore restituito, ma lo può anche modificare. Tale modifica si riflette sulla classe `Sentence`.</span><span class="sxs-lookup"><span data-stu-id="53cf1-148">This means that the caller can not only read the returned value; he or she can also modify it, and that modification is reflected in the `Sentence` class.</span></span>

<span data-ttu-id="53cf1-149">[!code-csharp[Ref-Return](../../../samples/snippets/visualbasic/getting-started/ref-returns.cs)]</span><span class="sxs-lookup"><span data-stu-id="53cf1-149">[!code-csharp[Ref-Return](../../../samples/snippets/visualbasic/getting-started/ref-returns.cs)]</span></span>

<span data-ttu-id="53cf1-150">In parole semplici, è possibile modificare la parola trovata nella frase usando un codice simile al seguente.</span><span class="sxs-lookup"><span data-stu-id="53cf1-150">In its simplest form, you can modify the word found in the sentence by using code like the following.</span></span> <span data-ttu-id="53cf1-151">Si noti che non si sta assegnando un valore al metodo, ma all'espressione che il metodo restituisce, ovvero il valore di riferimento restituito.</span><span class="sxs-lookup"><span data-stu-id="53cf1-151">Note that you are not assigning a value to the method, but rather to the expression that the method returns, which is the reference return value.</span></span>

<span data-ttu-id="53cf1-152">[!code-vb[Ref-Return](../../../samples/snippets/visualbasic/getting-started/ref-return.vb#1)]</span><span class="sxs-lookup"><span data-stu-id="53cf1-152">[!code-vb[Ref-Return](../../../samples/snippets/visualbasic/getting-started/ref-return.vb#1)]</span></span>

<span data-ttu-id="53cf1-153">Esiste tuttavia un problema con questo codice. Se non viene trovata una corrispondenza, il metodo restituisce la prima parola.</span><span class="sxs-lookup"><span data-stu-id="53cf1-153">A problem with this code, though, is that if a match is not found, the method returns the first word.</span></span> <span data-ttu-id="53cf1-154">L'esempio non esamina il valore dell'argomento `Boolean` per determinare se viene trovata una corrispondenza. Modifica quindi la prima parola se non esiste corrispondenza.</span><span class="sxs-lookup"><span data-stu-id="53cf1-154">Since the example does not examine the value of the `Boolean` argument to determine whether a match is found, it modifies the first word if there is no match.</span></span> <span data-ttu-id="53cf1-155">Nell'esempio seguente questo problema viene risolto sostituendo la prima parola con la parola stessa se non esiste corrispondenza.</span><span class="sxs-lookup"><span data-stu-id="53cf1-155">The following example corrects this by replacing the first word with itself if there is no match.</span></span>

<span data-ttu-id="53cf1-156">[!code-vb[Ref-Return](../../../samples/snippets/visualbasic/getting-started/ref-return.vb#2)]</span><span class="sxs-lookup"><span data-stu-id="53cf1-156">[!code-vb[Ref-Return](../../../samples/snippets/visualbasic/getting-started/ref-return.vb#2)]</span></span>

<span data-ttu-id="53cf1-157">Una soluzione migliore consiste nell'usare un metodo helper al quale il riferimento passa il valore di riferimento restituito.</span><span class="sxs-lookup"><span data-stu-id="53cf1-157">A better solution is to use a helper method to which the reference return value is passed by reference.</span></span> <span data-ttu-id="53cf1-158">Il metodo helper può quindi modificare l'argomento passato dal riferimento.</span><span class="sxs-lookup"><span data-stu-id="53cf1-158">The helper method can then modify the argument passed to it by reference.</span></span> <span data-ttu-id="53cf1-159">Nell'esempio seguente viene eseguita questa operazione.</span><span class="sxs-lookup"><span data-stu-id="53cf1-159">The following example does that.</span></span>

<span data-ttu-id="53cf1-160">[!code-vb[Ref-Return](../../../samples/snippets/visualbasic/getting-started/ref-return-helper.vb#1)]</span><span class="sxs-lookup"><span data-stu-id="53cf1-160">[!code-vb[Ref-Return](../../../samples/snippets/visualbasic/getting-started/ref-return-helper.vb#1)]</span></span>

<span data-ttu-id="53cf1-161">Per altre informazioni, vedere [Reference Return Values](../programming-guide/language-features/procedures/ref-return-values.md) (Valori di riferimento restituiti).</span><span class="sxs-lookup"><span data-stu-id="53cf1-161">For more information, see [Reference Return Values](../programming-guide/language-features/procedures/ref-return-values.md).</span></span>

## <a name="visual-basic-14"></a><span data-ttu-id="53cf1-162">Visual Basic 14</span><span class="sxs-lookup"><span data-stu-id="53cf1-162">Visual Basic 14</span></span>

[<span data-ttu-id="53cf1-163">Nameof</span><span class="sxs-lookup"><span data-stu-id="53cf1-163">Nameof</span></span>](../../csharp/language-reference/keywords/nameof.md)  
 <span data-ttu-id="53cf1-164">È possibile ottenere il nome di stringa non qualificato di un tipo o di un membro, da usare in un messaggio di errore senza definire una stringa a livello di codice.</span><span class="sxs-lookup"><span data-stu-id="53cf1-164">You can get the unqualified string name of a type or member for use in an error message without hard coding a string.</span></span>  <span data-ttu-id="53cf1-165">In questo modo il codice sarà corretto anche durante il refactoring.</span><span class="sxs-lookup"><span data-stu-id="53cf1-165">This allows your code to remain correct when refactoring.</span></span>  <span data-ttu-id="53cf1-166">Questa funzionalità è utile anche per l'associazione di collegamenti MVC (Modello-Vista-Controller) e la generazione di eventi di modifica di proprietà.</span><span class="sxs-lookup"><span data-stu-id="53cf1-166">This feature is also useful for hooking up model-view-controller MVC links and firing property changed events.</span></span>  
  
[<span data-ttu-id="53cf1-167">Interpolazione di stringhe</span><span class="sxs-lookup"><span data-stu-id="53cf1-167">String Interpolation</span></span>](../../csharp/language-reference/keywords/interpolated-strings.md)  
 <span data-ttu-id="53cf1-168">È possibile usare espressioni di interpolazione di stringhe per costruire stringhe.</span><span class="sxs-lookup"><span data-stu-id="53cf1-168">You can use string interpolation expressions to construct strings.</span></span>  <span data-ttu-id="53cf1-169">Un'espressione di stringa interpolata è simile a una stringa di modello che contiene espressioni.</span><span class="sxs-lookup"><span data-stu-id="53cf1-169">An interpolated string expression looks like a template string that contains expressions.</span></span>  <span data-ttu-id="53cf1-170">In relazione agli argomenti, è più facile comprendere una stringa interpolata che la [formattazione composita](../../standard/base-types/composite-format.md).</span><span class="sxs-lookup"><span data-stu-id="53cf1-170">An interpolated string is easier to understand with respect to arguments than [Composite Formatting](../../standard/base-types/composite-format.md).</span></span>  
  
[<span data-ttu-id="53cf1-171">Indicizzazione e accesso ai membri condizionali null</span><span class="sxs-lookup"><span data-stu-id="53cf1-171">Null-conditional Member Access and Indexing</span></span>](../../csharp/language-reference/operators/null-conditional-operators.md)  
<span data-ttu-id="53cf1-172">È possibile verificare la presenza di valori null con una sintassi molto leggera prima di eseguire un'operazione di accesso ai membri (`?.`) o di indice (`?[]`).</span><span class="sxs-lookup"><span data-stu-id="53cf1-172">You can test for null in a very light syntactic way before performing a member access (`?.`) or index (`?[]`) operation.</span></span>  <span data-ttu-id="53cf1-173">Questi operatori consentono di scrivere meno codice per gestire i controlli null, soprattutto per l'ordinamento decrescente delle strutture di dati.</span><span class="sxs-lookup"><span data-stu-id="53cf1-173">These operators help you write less code to handle null checks, especially for descending into data structures.</span></span>  <span data-ttu-id="53cf1-174">Se l'operando di sinistra o il riferimento a un oggetto è null, le operazioni restituiscono null.</span><span class="sxs-lookup"><span data-stu-id="53cf1-174">If the left operand or object reference is null, the operations returns null.</span></span>  
  
[<span data-ttu-id="53cf1-175">Valori letterali stringa multilinea</span><span class="sxs-lookup"><span data-stu-id="53cf1-175">Multi-line String Literals</span></span>](../../visual-basic/programming-guide/language-features/strings/string-basics.md)  
 <span data-ttu-id="53cf1-176">I valori letterali stringa possono contenere sequenze di nuove righe.</span><span class="sxs-lookup"><span data-stu-id="53cf1-176">String literals can contain newline sequences.</span></span>  <span data-ttu-id="53cf1-177">Non è più necessario usare `<xml><![CDATA[...text with newlines...]]></xml>.Value` come soluzione alternativa.</span><span class="sxs-lookup"><span data-stu-id="53cf1-177">You no longer need the old work around of using `<xml><![CDATA[...text with newlines...]]></xml>.Value`</span></span>  
  
<span data-ttu-id="53cf1-178">Commenti</span><span class="sxs-lookup"><span data-stu-id="53cf1-178">Comments</span></span>  
<span data-ttu-id="53cf1-179">È possibile inserire commenti dopo le continuazioni di riga implicita, all'interno delle espressioni dell'inizializzatore e tra i termini delle espressioni LINQ.</span><span class="sxs-lookup"><span data-stu-id="53cf1-179">You can put comments after implicit line continuations, inside initializer expressions, and amongst LINQ expression terms.</span></span>  
  
 <span data-ttu-id="53cf1-180">Risoluzione dei nomi completi più intelligente</span><span class="sxs-lookup"><span data-stu-id="53cf1-180">Smarter Fully-qualified Name Resolution</span></span>  
 <span data-ttu-id="53cf1-181">In precedenza, con un codice come `Threading.Thread.Sleep(1000)`, Visual Basic cercava lo spazio dei nomi "Threading", individuava un'ambiguità tra System.Threading e System.Windows.Threading e quindi segnalava un errore.</span><span class="sxs-lookup"><span data-stu-id="53cf1-181">Given code such as `Threading.Thread.Sleep(1000)`, Visual Basic used to look up the namespace "Threading", discover it was ambiguous between System.Threading and System.Windows.Threading, and then report an error.</span></span>  <span data-ttu-id="53cf1-182">Visual Basic ora prende in considerazione entrambi gli spazi dei nomi possibili.</span><span class="sxs-lookup"><span data-stu-id="53cf1-182">Visual Basic now considers both possible namespaces together.</span></span>  <span data-ttu-id="53cf1-183">Se si visualizza l'elenco di completamento, l'editor di Visual Studio elenca i membri di entrambi i tipi in questo elenco.</span><span class="sxs-lookup"><span data-stu-id="53cf1-183">If you show the completion list, the Visual Studio editor lists members from both types in the completion list.</span></span>  
  
 <span data-ttu-id="53cf1-184">Valori letterali data con anno all'inizio</span><span class="sxs-lookup"><span data-stu-id="53cf1-184">Year-first Date Literals</span></span>  
 <span data-ttu-id="53cf1-185">I valori letterali data possono avere il formato aaaa-mm-gg, `#2015-03-17 16:10 PM#`.</span><span class="sxs-lookup"><span data-stu-id="53cf1-185">You can have date literals in yyyy-mm-dd format, `#2015-03-17 16:10 PM#`.</span></span>  
  
 <span data-ttu-id="53cf1-186">Proprietà dell'interfaccia readonly</span><span class="sxs-lookup"><span data-stu-id="53cf1-186">Readonly Interface Properties</span></span>  
 <span data-ttu-id="53cf1-187">È possibile implementare proprietà dell'interfaccia readonly usando una proprietà readonly.</span><span class="sxs-lookup"><span data-stu-id="53cf1-187">You can implement readonly interface properties using a readwrite property.</span></span>  <span data-ttu-id="53cf1-188">L'interfaccia garantisce la funzionalità minima e le classi di implementazione non smettono di consentire l'impostazione della proprietà.</span><span class="sxs-lookup"><span data-stu-id="53cf1-188">The interface guarantees minimum functionality, and it does not stop an implementing class from allowing the property to be set.</span></span>  
  
 [<span data-ttu-id="53cf1-189">TypeOf \<espressione> IsNot \<tipo></span><span class="sxs-lookup"><span data-stu-id="53cf1-189">TypeOf \<expr> IsNot \<type></span></span>](../../visual-basic/language-reference/operators/typeof-operator.md)  
 <span data-ttu-id="53cf1-190">Per una maggiore leggibilità del codice, ora è possibile usare `TypeOf` con `IsNot`.</span><span class="sxs-lookup"><span data-stu-id="53cf1-190">For more readability of your code, you can now use `TypeOf` with `IsNot`.</span></span>  
  
 [<span data-ttu-id="53cf1-191">#Disable Warning \<ID> e #Enable Warning \<ID></span><span class="sxs-lookup"><span data-stu-id="53cf1-191">#Disable Warning \<ID> and #Enable Warning \<ID></span></span>](../../visual-basic/language-reference/directives/directives.md)  
 <span data-ttu-id="53cf1-192">È possibile disabilitare e abilitare avvisi specifici per le aree all'interno di un file di origine.</span><span class="sxs-lookup"><span data-stu-id="53cf1-192">You can disable and enable specific warnings for regions within a source file.</span></span>  
  
 <span data-ttu-id="53cf1-193">Miglioramenti dei commenti ai documenti XML</span><span class="sxs-lookup"><span data-stu-id="53cf1-193">XML Doc-comment Improvements</span></span>  
 <span data-ttu-id="53cf1-194">Quando si scrivono commenti ai documenti, si accede a Smart Editor e al supporto per la compilazione per la convalida di nomi di parametro, la corretta gestione di `crefs` (generics, operatori e così via), la colorazione e il refactoring.</span><span class="sxs-lookup"><span data-stu-id="53cf1-194">When writing doc comments, you get smart editor and build support for validating parameter names, proper handling of `crefs` (generics, operators, etc.), colorizing, and refactoring.</span></span>  
  
 [<span data-ttu-id="53cf1-195">Definizioni di interfacce e moduli parziali</span><span class="sxs-lookup"><span data-stu-id="53cf1-195">Partial Module and Interface Definitions</span></span>](../../visual-basic/language-reference/modifiers/partial.md)  
 <span data-ttu-id="53cf1-196">Oltre a classi e struct, è possibile dichiarare interfacce e moduli parziali.</span><span class="sxs-lookup"><span data-stu-id="53cf1-196">In addition to classes and structs, you can declare partial modules and interfaces.</span></span>  
  
 [<span data-ttu-id="53cf1-197">Direttive #Region in corpi di metodo</span><span class="sxs-lookup"><span data-stu-id="53cf1-197">#Region Directives inside Method Bodies</span></span>](../../visual-basic/language-reference/directives/region-directive.md)  
 <span data-ttu-id="53cf1-198">È possibile inserire delimitatori #Region...#End Region in qualsiasi punto di un file, nelle funzioni o nei corpi delle funzioni.</span><span class="sxs-lookup"><span data-stu-id="53cf1-198">You can put #Region…#End Region delimiters anywhere in a file, inside functions, and even spanning across function bodies.</span></span>  
  
 [<span data-ttu-id="53cf1-199">Le definizioni Overrides sono overload impliciti</span><span class="sxs-lookup"><span data-stu-id="53cf1-199">Overrides Definitions are Implicitly Overloads</span></span>](../../visual-basic/language-reference/modifiers/overrides.md)  
 <span data-ttu-id="53cf1-200">Se si aggiunge il modificatore `Overrides` a una definizione, il compilatore aggiunge in modo implicito `Overloads`. In questo modo è possibile digitare meno codice nella maggior parte dei casi.</span><span class="sxs-lookup"><span data-stu-id="53cf1-200">If you add the `Overrides` modifier to a definition, the compiler implicitly adds `Overloads` so that you can type less code in common cases.</span></span>  
  
 <span data-ttu-id="53cf1-201">CObj consentito negli argomenti degli attributi</span><span class="sxs-lookup"><span data-stu-id="53cf1-201">CObj Allowed in Attributes Arguments</span></span>  
 <span data-ttu-id="53cf1-202">Il compilatore generava un errore indicante che CObj(...), se usato nelle costruzioni degli attributi, non era una costante.</span><span class="sxs-lookup"><span data-stu-id="53cf1-202">The compiler used to give an error that CObj(…) was not a constant when used in attribute constructions.</span></span>  
  
 <span data-ttu-id="53cf1-203">Dichiarazione e utilizzo di metodi ambigui da interfacce diverse</span><span class="sxs-lookup"><span data-stu-id="53cf1-203">Declaring and Consuming Ambiguous Methods from Different Interfaces</span></span>  
 <span data-ttu-id="53cf1-204">In precedenza il codice seguente restituiva errori che impedivano di dichiarare `IMock` o di chiamare `GetDetails` (se questi erano stati dichiarati in c#):</span><span class="sxs-lookup"><span data-stu-id="53cf1-204">Previously the following code yielded errors that prevented you from declaring `IMock` or from calling `GetDetails` (if these had been declared in C#):</span></span>  
  
```vb  
Interface ICustomer  
  Sub GetDetails(x As Integer)  
End Interface  
  
Interface ITime  
  Sub GetDetails(x As String)  
End Interface  
  
Interface IMock : Inherits ICustomer, ITime  
  Overloads Sub GetDetails(x As Char)  
End Interface  
  
Interface IMock2 : Inherits ICustomer, ITime  
End Interface  
```  
  
 <span data-ttu-id="53cf1-205">Ora il compilatore userà le normali regole di risoluzione dell'overload per scegliere l'oggetto `GetDetails` più appropriato da chiamare ed è possibile dichiarare le relazioni tre le interfacce in Visual Basic, come quelle mostrate nell'esempio.</span><span class="sxs-lookup"><span data-stu-id="53cf1-205">Now the compiler will use normal overload resolution rules to choose the most appropriate `GetDetails` to call, and you can declare interface relationships in Visual Basic like those shown in the sample.</span></span>  
  
## <a name="see-also"></a><span data-ttu-id="53cf1-206">Vedere anche</span><span class="sxs-lookup"><span data-stu-id="53cf1-206">See also</span></span>  
 [<span data-ttu-id="53cf1-207">Novità di Visual Studio 2017</span><span class="sxs-lookup"><span data-stu-id="53cf1-207">What's New in Visual Studio 2017</span></span>](/visualstudio/ide/whats-new-in-visual-studio)

