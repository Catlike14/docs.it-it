---
title: Thread di sincronizzazione (Visual Basic) | Documenti di Microsoft
ms.custom: 
ms.date: 2015-07-20
ms.prod: .net
ms.reviewer: 
ms.suite: 
ms.technology:
- devlang-visual-basic
ms.tgt_pltfrm: 
ms.topic: article
dev_langs:
- VB
ms.assetid: 04f485d1-8333-4510-9e72-c334e7427e7e
caps.latest.revision: 3
author: dotnet-bot
ms.author: dotnetcontent
translation.priority.mt:
- cs-cz
- pl-pl
- pt-br
- tr-tr
ms.translationtype: Machine Translation
ms.sourcegitcommit: 9f5b8ebb69c9206ff90b05e748c64d29d82f7a16
ms.openlocfilehash: 240937905254120f777ce140049084279c35005c
ms.contentlocale: it-it
ms.lasthandoff: 04/12/2017

---
# <a name="thread-synchronization-visual-basic"></a><span data-ttu-id="61e3b-102">Sincronizzazione dei thread (Visual Basic)</span><span class="sxs-lookup"><span data-stu-id="61e3b-102">Thread Synchronization (Visual Basic)</span></span>
<span data-ttu-id="61e3b-103">Le sezioni seguenti descrivono le funzionalità e le classi che possono essere utilizzate per sincronizzare l'accesso alle risorse in applicazioni multithreading.</span><span class="sxs-lookup"><span data-stu-id="61e3b-103">The following sections describe features and classes that can be used to synchronize access to resources in multithreaded applications.</span></span>  
  
 <span data-ttu-id="61e3b-104">Uno dei vantaggi dell'utilizzo di più thread in un'applicazione consiste nel fatto che ogni thread esegue in modo asincrono.</span><span class="sxs-lookup"><span data-stu-id="61e3b-104">One of the benefits of using multiple threads in an application is that each thread executes asynchronously.</span></span> <span data-ttu-id="61e3b-105">Per le applicazioni di Windows, in questo modo l'attività richiede molto tempo essere eseguita in background mentre la finestra dell'applicazione e controlli rimangano attiva.</span><span class="sxs-lookup"><span data-stu-id="61e3b-105">For Windows applications, this allows time-consuming tasks to be performed in the background while the application window and controls remain responsive.</span></span> <span data-ttu-id="61e3b-106">Per server applicazioni, multithreading offre la possibilità di gestire ogni richiesta in ingresso con un altro thread.</span><span class="sxs-lookup"><span data-stu-id="61e3b-106">For server applications, multithreading provides the ability to handle each incoming request with a different thread.</span></span> <span data-ttu-id="61e3b-107">In caso contrario, ogni nuova richiesta verrebbe soddisfatta fino a quando la richiesta precedente fosse stata siano soddisfatta.</span><span class="sxs-lookup"><span data-stu-id="61e3b-107">Otherwise, each new request would not get serviced until the previous request had been fully satisfied.</span></span>  
  
 <span data-ttu-id="61e3b-108">Tuttavia, data la natura asincrona dei thread implica che l'accesso alle risorse, ad esempio memoria, handle di file e le connessioni di rete deve essere coordinata.</span><span class="sxs-lookup"><span data-stu-id="61e3b-108">However, the asynchronous nature of threads means that access to resources such as file handles, network connections, and memory must be coordinated.</span></span> <span data-ttu-id="61e3b-109">In caso contrario, due o più thread potrebbero accedere alla stessa risorsa nello stesso momento, ogni riconosce le azioni di altro.</span><span class="sxs-lookup"><span data-stu-id="61e3b-109">Otherwise, two or more threads could access the same resource at the same time, each unaware of the other's actions.</span></span> <span data-ttu-id="61e3b-110">Il risultato è il danneggiamento dei dati imprevisti.</span><span class="sxs-lookup"><span data-stu-id="61e3b-110">The result is unpredictable data corruption.</span></span>  
  
 <span data-ttu-id="61e3b-111">Per operazioni semplici sui tipi di dati numerici integrali, la sincronizzazione dei thread può essere eseguita con i membri di <xref:System.Threading.Interlocked>classe.</xref:System.Threading.Interlocked></span><span class="sxs-lookup"><span data-stu-id="61e3b-111">For simple operations on integral numeric data types, synchronizing threads can be accomplished with members of the <xref:System.Threading.Interlocked> class.</span></span> <span data-ttu-id="61e3b-112">Per tutti gli altri dati tipi e le risorse non thread-safe, multithreading possono essere tranquillamente eseguite solo utilizzando i costrutti in questo argomento.</span><span class="sxs-lookup"><span data-stu-id="61e3b-112">For all other data types and non thread-safe resources, multithreading can only be safely performed using the constructs in this topic.</span></span>  
  
 <span data-ttu-id="61e3b-113">Per informazioni generali sulla programmazione multithreading, vedere:</span><span class="sxs-lookup"><span data-stu-id="61e3b-113">For background information on multithreaded programming, see:</span></span>  
  
-   [<span data-ttu-id="61e3b-114">Nozioni di base di Threading gestito</span><span class="sxs-lookup"><span data-stu-id="61e3b-114">Managed Threading Basics</span></span>](http://msdn.microsoft.com/library/b2944911-0e8f-427d-a8bb-077550618935)  
  
-   [<span data-ttu-id="61e3b-115">Utilizzo di thread e Threading</span><span class="sxs-lookup"><span data-stu-id="61e3b-115">Using Threads and Threading</span></span>](http://msdn.microsoft.com/library/9b5ec2cd-121b-4d49-b075-222cf26f2344)  
  
-   [<span data-ttu-id="61e3b-116">Procedure consigliate di Threading gestito</span><span class="sxs-lookup"><span data-stu-id="61e3b-116">Managed Threading Best Practices</span></span>](http://msdn.microsoft.com/library/e51988e7-7f4b-4646-a06d-1416cee8d557)  
  
## <a name="the-lock-and-synclock-keywords"></a><span data-ttu-id="61e3b-117">Il blocco e parole chiave SyncLock</span><span class="sxs-lookup"><span data-stu-id="61e3b-117">The lock and SyncLock Keywords</span></span>  
 <span data-ttu-id="61e3b-118">Visual Basic `SyncLock` istruzione può essere utilizzata per garantire che un blocco di codice viene eseguito fino al completamento senza interruzioni da altri thread.</span><span class="sxs-lookup"><span data-stu-id="61e3b-118">The Visual Basic `SyncLock` statement can be used to ensure that a block of code runs to completion without interruption by other threads.</span></span> <span data-ttu-id="61e3b-119">Questa operazione viene eseguita ottenendo un blocco a esclusione reciproca per un determinato oggetto per la durata del blocco di codice.</span><span class="sxs-lookup"><span data-stu-id="61e3b-119">This is accomplished by obtaining a mutual-exclusion lock for a given object for the duration of the code block.</span></span>  
  
 <span data-ttu-id="61e3b-120">Oggetto `SyncLock` istruzione viene assegnata un oggetto come argomento, seguita da un blocco di codice che deve essere eseguito da un solo thread alla volta.</span><span class="sxs-lookup"><span data-stu-id="61e3b-120">A `SyncLock` statement is given an object as an argument, and is followed by a code block that is to be executed by only one thread at a time.</span></span> <span data-ttu-id="61e3b-121">Ad esempio:</span><span class="sxs-lookup"><span data-stu-id="61e3b-121">For example:</span></span>  
  
```vb  
Public Class TestThreading  
    Dim lockThis As New Object  
  
    Public Sub Process()  
        SyncLock lockThis  
            ' Access thread-sensitive resources.  
        End SyncLock  
    End Sub  
End Class  
```  
  
 <span data-ttu-id="61e3b-122">L'argomento fornito per il `SyncLock` (parola chiave) deve essere un oggetto basato su un tipo di riferimento e viene utilizzato per definire l'ambito del blocco.</span><span class="sxs-lookup"><span data-stu-id="61e3b-122">The argument provided to the `SyncLock` keyword must be an object based on a reference type, and is used to define the scope of the lock.</span></span> <span data-ttu-id="61e3b-123">Nell'esempio precedente, l'ambito del blocco è limitato a questa funzione perché nessun riferimento all'oggetto `lockThis` esiste all'esterno della funzione.</span><span class="sxs-lookup"><span data-stu-id="61e3b-123">In the example above, the lock scope is limited to this function because no references to the object `lockThis` exist outside the function.</span></span> <span data-ttu-id="61e3b-124">Se esiste un riferimento, ambito del blocco si estende anche a tale oggetto.</span><span class="sxs-lookup"><span data-stu-id="61e3b-124">If such a reference did exist, lock scope would extend to that object.</span></span> <span data-ttu-id="61e3b-125">In teoria, l'oggetto fornito viene utilizzato esclusivamente per identificare la risorsa condivisa tra più thread, pertanto può essere un'istanza di classe arbitraria.</span><span class="sxs-lookup"><span data-stu-id="61e3b-125">Strictly speaking, the object provided is used solely to uniquely identify the resource being shared among multiple threads, so it can be an arbitrary class instance.</span></span> <span data-ttu-id="61e3b-126">In pratica, tuttavia, questo oggetto rappresenta in genere la risorsa per il thread su cui sia necessaria la sincronizzazione.</span><span class="sxs-lookup"><span data-stu-id="61e3b-126">In practice, however, this object usually represents the resource for which thread synchronization is necessary.</span></span> <span data-ttu-id="61e3b-127">Ad esempio, se un oggetto contenitore deve essere utilizzato da più thread, quindi il contenitore può essere passato per bloccare e il blocco di codice sincronizzato segue il blocco acceda al contenitore.</span><span class="sxs-lookup"><span data-stu-id="61e3b-127">For example, if a container object is to be used by multiple threads, then the container can be passed to lock, and the synchronized code block following the lock would access the container.</span></span> <span data-ttu-id="61e3b-128">Come altri thread vengano bloccati sullo stesso contengono prima dell'accesso, in modo sicuro l'accesso all'oggetto è sincronizzato.</span><span class="sxs-lookup"><span data-stu-id="61e3b-128">As long as other threads locks on the same contain before accessing it, then access to the object is safely synchronized.</span></span>  
  
 <span data-ttu-id="61e3b-129">In genere, è consigliabile evitare il blocco di un `public` tipo, o istanze di oggetti sotto il controllo dell'applicazione.</span><span class="sxs-lookup"><span data-stu-id="61e3b-129">Generally, it is best to avoid locking on a `public` type, or on object instances beyond the control of your application.</span></span> <span data-ttu-id="61e3b-130">Ad esempio, `lockThis` può risultare problematico se l'istanza è possibile accedere pubblicamente, perché il codice fuori controllo potrebbe causare il blocco anche l'oggetto.</span><span class="sxs-lookup"><span data-stu-id="61e3b-130">For example, `lockThis` can be problematic if the instance can be accessed publicly, because code beyond your control may lock on the object as well.</span></span> <span data-ttu-id="61e3b-131">Questo può creare situazioni di deadlock in cui due o più thread sono in attesa per la versione dello stesso oggetto.</span><span class="sxs-lookup"><span data-stu-id="61e3b-131">This could create deadlock situations where two or more threads wait for the release of the same object.</span></span> <span data-ttu-id="61e3b-132">Il blocco di un tipo di dati pubblici, anziché su un oggetto, può causare problemi per lo stesso motivo.</span><span class="sxs-lookup"><span data-stu-id="61e3b-132">Locking on a public data type, as opposed to an object, can cause problems for the same reason.</span></span> <span data-ttu-id="61e3b-133">Il blocco di stringhe letterali è particolarmente rischioso poiché le stringhe letterali sono *inserite* da common language runtime (CLR).</span><span class="sxs-lookup"><span data-stu-id="61e3b-133">Locking on literal strings is especially risky because literal strings are *interned* by the common language runtime (CLR).</span></span> <span data-ttu-id="61e3b-134">Questo significa che è presente un'istanza di una stringa letterale per l'intero programma, lo stesso oggetto rappresenta il valore letterale in tutti domini applicazione, in esecuzione su tutti i thread.</span><span class="sxs-lookup"><span data-stu-id="61e3b-134">This means that there is one instance of any given string literal for the entire program, the exact same object represents the literal in all running application domains, on all threads.</span></span> <span data-ttu-id="61e3b-135">Di conseguenza, un blocco collocato su una stringa con lo stesso contenuto in qualsiasi posizione il processo dell'applicazione blocca tutte le istanze di tale stringa nell'applicazione.</span><span class="sxs-lookup"><span data-stu-id="61e3b-135">As a result, a lock placed on a string with the same contents anywhere in the application process locks all instances of that string in the application.</span></span> <span data-ttu-id="61e3b-136">Di conseguenza, si consiglia di bloccare un membro privato o protetto che non è inserito.</span><span class="sxs-lookup"><span data-stu-id="61e3b-136">As a result, it is best to lock a private or protected member that is not interned.</span></span> <span data-ttu-id="61e3b-137">Alcune classi sono disponibili membri specifici per il blocco.</span><span class="sxs-lookup"><span data-stu-id="61e3b-137">Some classes provide members specifically for locking.</span></span> <span data-ttu-id="61e3b-138">Il <xref:System.Array>tipo, ad esempio, fornisce <xref:System.Array.SyncRoot%2A>.</xref:System.Array.SyncRoot%2A> </xref:System.Array></span><span class="sxs-lookup"><span data-stu-id="61e3b-138">The <xref:System.Array> type, for example, provides <xref:System.Array.SyncRoot%2A>.</span></span> <span data-ttu-id="61e3b-139">Molti tipi di raccolta forniscono un `SyncRoot` nonché membro.</span><span class="sxs-lookup"><span data-stu-id="61e3b-139">Many collection types provide a `SyncRoot` member as well.</span></span>  
  
 <span data-ttu-id="61e3b-140">Per ulteriori informazioni sui `SyncLock` istruzione, vedere gli argomenti seguenti:</span><span class="sxs-lookup"><span data-stu-id="61e3b-140">For more information about the `SyncLock` statement, see the following topics:</span></span>  
  
-   [<span data-ttu-id="61e3b-141">Istruzione SyncLock</span><span class="sxs-lookup"><span data-stu-id="61e3b-141">SyncLock Statement</span></span>](../../../../visual-basic/language-reference/statements/synclock-statement.md)  
  
-   @System.Threading.Monitor  
  
## <a name="monitors"></a><span data-ttu-id="61e3b-142">Monitoraggi</span><span class="sxs-lookup"><span data-stu-id="61e3b-142">Monitors</span></span>  
 <span data-ttu-id="61e3b-143">Ad esempio il `SyncLock` (parola chiave), monitoraggi evitare blocchi di codice dall'esecuzione simultanea di più thread.</span><span class="sxs-lookup"><span data-stu-id="61e3b-143">Like the `SyncLock` keyword, monitors prevent blocks of code from simultaneous execution by multiple threads.</span></span> <span data-ttu-id="61e3b-144">Il <xref:System.Threading.Monitor.Enter%2A>metodo consente un solo thread procedere nelle istruzioni seguenti, tutti gli altri thread sono bloccati fino a quando l'esecuzione del thread chiama <xref:System.Threading.Monitor.Exit%2A>.</xref:System.Threading.Monitor.Exit%2A> </xref:System.Threading.Monitor.Enter%2A></span><span class="sxs-lookup"><span data-stu-id="61e3b-144">The <xref:System.Threading.Monitor.Enter%2A> method allows one and only one thread to proceed into the following statements; all other threads are blocked until the executing thread calls <xref:System.Threading.Monitor.Exit%2A>.</span></span> <span data-ttu-id="61e3b-145">Si tratta come quando si utilizza il `SyncLock` (parola chiave).</span><span class="sxs-lookup"><span data-stu-id="61e3b-145">This is just like using the `SyncLock` keyword.</span></span> <span data-ttu-id="61e3b-146">Ad esempio:</span><span class="sxs-lookup"><span data-stu-id="61e3b-146">For example:</span></span>  
  
```vb  
SyncLock x  
    DoSomething()  
End SyncLock  
```  
  
 <span data-ttu-id="61e3b-147">Ciò equivale a:</span><span class="sxs-lookup"><span data-stu-id="61e3b-147">This is equivalent to:</span></span>  
  
```vb  
Dim obj As Object = CType(x, Object)  
System.Threading.Monitor.Enter(obj)  
Try  
    DoSomething()  
Finally  
    System.Threading.Monitor.Exit(obj)  
End Try  
```  
  
 <span data-ttu-id="61e3b-148">Utilizzando il `SyncLock` (parola chiave) viene in genere preferibile all'utilizzo di <xref:System.Threading.Monitor>direttamente alla classe, sia perché `SyncLock` è più conciso e poiché `SyncLock` assicura il rilascio del monitor sottostante, anche se il codice protetto genera un'eccezione.</xref:System.Threading.Monitor></span><span class="sxs-lookup"><span data-stu-id="61e3b-148">Using the `SyncLock` keyword is generally preferred over using the <xref:System.Threading.Monitor> class directly, both because `SyncLock` is more concise, and because `SyncLock` insures that the underlying monitor is released, even if the protected code throws an exception.</span></span> <span data-ttu-id="61e3b-149">Questa operazione viene eseguita con il `Finally` (parola chiave), che esegue il blocco di codice associato indipendentemente dal fatto che viene generata un'eccezione.</span><span class="sxs-lookup"><span data-stu-id="61e3b-149">This is accomplished with the `Finally` keyword, which executes its associated code block regardless of whether an exception is thrown.</span></span>  
  
## <a name="synchronization-events-and-wait-handles"></a><span data-ttu-id="61e3b-150">Eventi di sincronizzazione e gli handle di attesa</span><span class="sxs-lookup"><span data-stu-id="61e3b-150">Synchronization Events and Wait Handles</span></span>  
 <span data-ttu-id="61e3b-151">Utilizzo di un blocco o il monitoraggio è utile per impedire l'esecuzione simultanea di blocchi di codice sensibili thread, ma questi costrutti non consentono un solo thread comunicare un evento a un altro.</span><span class="sxs-lookup"><span data-stu-id="61e3b-151">Using a lock or monitor is useful for preventing the simultaneous execution of thread-sensitive blocks of code, but these constructs do not allow one thread to communicate an event to another.</span></span> <span data-ttu-id="61e3b-152">Questa operazione richiede *gli eventi di sincronizzazione*, che sono oggetti che presentano uno dei due stati, segnalato e non segnalato, che può essere utilizzato per attivare e sospendere i thread.</span><span class="sxs-lookup"><span data-stu-id="61e3b-152">This requires *synchronization events*, which are objects that have one of two states, signaled and un-signaled, that can be used to activate and suspend threads.</span></span> <span data-ttu-id="61e3b-153">Thread può essere sospesa dal stabilite per attendere un evento di sincronizzazione che viene segnalato e può essere attivato modificando lo stato dell'evento su segnalato.</span><span class="sxs-lookup"><span data-stu-id="61e3b-153">Threads can be suspended by being made to wait on a synchronization event that is unsignaled, and can be activated by changing the event state to signaled.</span></span> <span data-ttu-id="61e3b-154">Se si tenta di un thread in attesa di un evento che è già segnalato, il thread continua l'esecuzione senza ritardo.</span><span class="sxs-lookup"><span data-stu-id="61e3b-154">If a thread attempts to wait on an event that is already signaled, then the thread continues to execute without delay.</span></span>  
  
 <span data-ttu-id="61e3b-155">Esistono due tipi di eventi di sincronizzazione: <xref:System.Threading.AutoResetEvent>e <xref:System.Threading.ManualResetEvent>.</xref:System.Threading.ManualResetEvent> </xref:System.Threading.AutoResetEvent></span><span class="sxs-lookup"><span data-stu-id="61e3b-155">There are two kinds of synchronization events: <xref:System.Threading.AutoResetEvent>, and <xref:System.Threading.ManualResetEvent>.</span></span> <span data-ttu-id="61e3b-156">L'unica differenza che <xref:System.Threading.AutoResetEvent>le modifiche da segnalato allo stato non segnalato automaticamente ogni volta che si attiva un thread.</xref:System.Threading.AutoResetEvent></span><span class="sxs-lookup"><span data-stu-id="61e3b-156">They differ only in that <xref:System.Threading.AutoResetEvent> changes from signaled to unsignaled automatically any time it activates a thread.</span></span> <span data-ttu-id="61e3b-157">Al contrario, un <xref:System.Threading.ManualResetEvent>consente qualsiasi numero di thread da attivare con lo stato segnalato e torna allo stato non segnalato solo stato quando il relativo <xref:System.Threading.EventWaitHandle.Reset%2A>viene chiamato.</xref:System.Threading.EventWaitHandle.Reset%2A> </xref:System.Threading.ManualResetEvent></span><span class="sxs-lookup"><span data-stu-id="61e3b-157">Conversely, a <xref:System.Threading.ManualResetEvent> allows any number of threads to be activated by its signaled state, and will only revert to an unsignaled state when its <xref:System.Threading.EventWaitHandle.Reset%2A> method is called.</span></span>  
  
 <span data-ttu-id="61e3b-158">I thread possono essere resi per attendere gli eventi chiamando uno dei metodi di attesa, ad esempio <xref:System.Threading.WaitHandle.WaitOne%2A>, <xref:System.Threading.WaitHandle.WaitAny%2A>, o <xref:System.Threading.WaitHandle.WaitAll%2A>.</xref:System.Threading.WaitHandle.WaitAll%2A> </xref:System.Threading.WaitHandle.WaitAny%2A> </xref:System.Threading.WaitHandle.WaitOne%2A></span><span class="sxs-lookup"><span data-stu-id="61e3b-158">Threads can be made to wait on events by calling one of the wait methods, such as <xref:System.Threading.WaitHandle.WaitOne%2A>, <xref:System.Threading.WaitHandle.WaitAny%2A>, or <xref:System.Threading.WaitHandle.WaitAll%2A>.</span></span> <span data-ttu-id="61e3b-159"><xref:System.Threading.WaitHandle.WaitOne%2A?displayProperty=fullName>fa sì che il thread in attesa finché non viene segnalato un singolo evento, <xref:System.Threading.WaitHandle.WaitAny%2A?displayProperty=fullName>Blocca un thread finché non viene segnalati uno o più eventi indicati, e <xref:System.Threading.WaitHandle.WaitAll%2A?displayProperty=fullName>Blocca il thread finché tutti gli eventi indicati non diventano segnalati.</xref:System.Threading.WaitHandle.WaitAll%2A?displayProperty=fullName> </xref:System.Threading.WaitHandle.WaitAny%2A?displayProperty=fullName></xref:System.Threading.WaitHandle.WaitOne%2A?displayProperty=fullName></span><span class="sxs-lookup"><span data-stu-id="61e3b-159"><xref:System.Threading.WaitHandle.WaitOne%2A?displayProperty=fullName> causes the thread to wait until a single event becomes signaled, <xref:System.Threading.WaitHandle.WaitAny%2A?displayProperty=fullName> blocks a thread until one or more indicated events become signaled, and <xref:System.Threading.WaitHandle.WaitAll%2A?displayProperty=fullName> blocks the thread until all of the indicated events become signaled.</span></span> <span data-ttu-id="61e3b-160">L'evento diventa segnalato quando il relativo <xref:System.Threading.EventWaitHandle.Set%2A>viene chiamato.</xref:System.Threading.EventWaitHandle.Set%2A></span><span class="sxs-lookup"><span data-stu-id="61e3b-160">An event becomes signaled when its <xref:System.Threading.EventWaitHandle.Set%2A> method is called.</span></span>  
  
 <span data-ttu-id="61e3b-161">Nell'esempio seguente viene creato e avviato da un thread di `Main` (funzione).</span><span class="sxs-lookup"><span data-stu-id="61e3b-161">In the following example, a thread is created and started by the `Main` function.</span></span> <span data-ttu-id="61e3b-162">Il nuovo thread attende un evento utilizzando il <xref:System.Threading.WaitHandle.WaitOne%2A>(metodo).</xref:System.Threading.WaitHandle.WaitOne%2A></span><span class="sxs-lookup"><span data-stu-id="61e3b-162">The new thread waits on an event using the <xref:System.Threading.WaitHandle.WaitOne%2A> method.</span></span> <span data-ttu-id="61e3b-163">Il thread viene sospesa fino a quando l'evento viene segnalato dal thread principale è in esecuzione il `Main` (funzione).</span><span class="sxs-lookup"><span data-stu-id="61e3b-163">The thread is suspended until the event becomes signaled by the primary thread that is executing the `Main` function.</span></span> <span data-ttu-id="61e3b-164">Una volta che viene segnalato l'evento, viene restituito il thread ausiliario.</span><span class="sxs-lookup"><span data-stu-id="61e3b-164">Once the event becomes signaled, the auxiliary thread returns.</span></span> <span data-ttu-id="61e3b-165">In questo caso, poiché l'evento viene utilizzato solo per l'attivazione di un thread, è il <xref:System.Threading.AutoResetEvent>o <xref:System.Threading.ManualResetEvent>classi potrebbero essere utilizzate.</xref:System.Threading.ManualResetEvent> </xref:System.Threading.AutoResetEvent></span><span class="sxs-lookup"><span data-stu-id="61e3b-165">In this case, because the event is only used for one thread activation, either the <xref:System.Threading.AutoResetEvent> or <xref:System.Threading.ManualResetEvent> classes could be used.</span></span>  
  
```vb  
Imports System.Threading  
  
Module Module1  
    Dim autoEvent As AutoResetEvent  
  
    Sub DoWork()  
        Console.WriteLine("   worker thread started, now waiting on event...")  
        autoEvent.WaitOne()  
        Console.WriteLine("   worker thread reactivated, now exiting...")  
    End Sub  
  
    Sub Main()  
        autoEvent = New AutoResetEvent(False)  
  
        Console.WriteLine("main thread starting worker thread...")  
        Dim t As New Thread(AddressOf DoWork)  
        t.Start()  
  
        Console.WriteLine("main thread sleeping for 1 second...")  
        Thread.Sleep(1000)  
  
        Console.WriteLine("main thread signaling worker thread...")  
        autoEvent.Set()  
    End Sub  
End Module  
```  
  
## <a name="mutex-object"></a><span data-ttu-id="61e3b-166">Oggetto mutex</span><span class="sxs-lookup"><span data-stu-id="61e3b-166">Mutex Object</span></span>  
 <span data-ttu-id="61e3b-167">Oggetto *mutex* è simile a un monitoraggio, impedisce l'esecuzione simultanea di un blocco di codice da più thread contemporaneamente.</span><span class="sxs-lookup"><span data-stu-id="61e3b-167">A *mutex* is similar to a monitor; it prevents the simultaneous execution of a block of code by more than one thread at a time.</span></span> <span data-ttu-id="61e3b-168">Infatti, il nome "mutex" è una versione abbreviata del termine "si escludono a vicenda."</span><span class="sxs-lookup"><span data-stu-id="61e3b-168">In fact, the name "mutex" is a shortened form of the term "mutually exclusive."</span></span> <span data-ttu-id="61e3b-169">A differenza dei monitoraggi, tuttavia, un mutex consente di sincronizzare i thread tra processi.</span><span class="sxs-lookup"><span data-stu-id="61e3b-169">Unlike monitors, however, a mutex can be used to synchronize threads across processes.</span></span> <span data-ttu-id="61e3b-170">Un mutex è rappresentato dalla <xref:System.Threading.Mutex>classe.</xref:System.Threading.Mutex></span><span class="sxs-lookup"><span data-stu-id="61e3b-170">A mutex is represented by the <xref:System.Threading.Mutex> class.</span></span>  
  
 <span data-ttu-id="61e3b-171">Quando utilizzato per la sincronizzazione tra processo, il mutex viene definito un *mutex denominato* perché deve essere utilizzato in un'altra applicazione e pertanto non può essere condiviso mediante una variabile globale o statica.</span><span class="sxs-lookup"><span data-stu-id="61e3b-171">When used for inter-process synchronization, a mutex is called a *named mutex* because it is to be used in another application, and therefore it cannot be shared by means of a global or static variable.</span></span> <span data-ttu-id="61e3b-172">Deve essere provvisto di un nome in modo che entrambe le applicazioni possono accedere lo stesso oggetto mutex.</span><span class="sxs-lookup"><span data-stu-id="61e3b-172">It must be given a name so that both applications can access the same mutex object.</span></span>  
  
 <span data-ttu-id="61e3b-173">Sebbene un mutex può essere utilizzato per la sincronizzazione dei thread all'interno del processo, utilizzando <xref:System.Threading.Monitor>è in genere preferibile, perché i monitoraggi sono stati progettati specificamente per .NET Framework e pertanto un migliore utilizzo delle risorse.</xref:System.Threading.Monitor></span><span class="sxs-lookup"><span data-stu-id="61e3b-173">Although a mutex can be used for intra-process thread synchronization, using <xref:System.Threading.Monitor> is generally preferred, because monitors were designed specifically for the .NET Framework and therefore make better use of resources.</span></span> <span data-ttu-id="61e3b-174">Al contrario, la <xref:System.Threading.Mutex>classe è un wrapper per un costrutto Win32.</xref:System.Threading.Mutex></span><span class="sxs-lookup"><span data-stu-id="61e3b-174">In contrast, the <xref:System.Threading.Mutex> class is a wrapper to a Win32 construct.</span></span> <span data-ttu-id="61e3b-175">Sebbene sia più potente di un monitor, un mutex richiede transizioni di interoperabilità che sono più dispendiosa rispetto a quelle richieste dalla <xref:System.Threading.Monitor>classe.</xref:System.Threading.Monitor></span><span class="sxs-lookup"><span data-stu-id="61e3b-175">While it is more powerful than a monitor, a mutex requires interop transitions that are more computationally expensive than those required by the <xref:System.Threading.Monitor> class.</span></span> <span data-ttu-id="61e3b-176">Per un esempio di utilizzo di un mutex, vedere [mutex](http://msdn.microsoft.com/library/9dd06e25-12c0-4a9e-855a-452dc83803e2).</span><span class="sxs-lookup"><span data-stu-id="61e3b-176">For an example of using a mutex, see [Mutexes](http://msdn.microsoft.com/library/9dd06e25-12c0-4a9e-855a-452dc83803e2).</span></span>  
  
## <a name="interlocked-class"></a><span data-ttu-id="61e3b-177">Interlocked (classe)</span><span class="sxs-lookup"><span data-stu-id="61e3b-177">Interlocked Class</span></span>  
 <span data-ttu-id="61e3b-178">È possibile utilizzare i metodi della <xref:System.Threading.Interlocked>classe per evitare i problemi che possono verificarsi quando più thread tentano contemporaneamente di aggiornare o confrontare lo stesso valore.</xref:System.Threading.Interlocked></span><span class="sxs-lookup"><span data-stu-id="61e3b-178">You can use the methods of the <xref:System.Threading.Interlocked> class to prevent problems that can occur when multiple threads attempt to simultaneously update or compare the same value.</span></span> <span data-ttu-id="61e3b-179">I metodi di questa classe consentono in modo sicuro di incremento, decrementano, scambino e confrontano i valori da qualsiasi thread.</span><span class="sxs-lookup"><span data-stu-id="61e3b-179">The methods of this class let you safely increment, decrement, exchange, and compare values from any thread.</span></span>  
  
## <a name="readerwriter-locks"></a><span data-ttu-id="61e3b-180">Blocchi ReaderWriter</span><span class="sxs-lookup"><span data-stu-id="61e3b-180">ReaderWriter Locks</span></span>  
 <span data-ttu-id="61e3b-181">In alcuni casi, si desidera bloccare una risorsa solo durante la scrittura di dati e consentire a leggere contemporaneamente i dati quando i dati non vengono aggiornati più client.</span><span class="sxs-lookup"><span data-stu-id="61e3b-181">In some cases, you may want to lock a resource only when data is being written and permit multiple clients to simultaneously read data when data is not being updated.</span></span> <span data-ttu-id="61e3b-182">La <xref:System.Threading.ReaderWriterLock>classe impone l'accesso esclusivo a una risorsa mentre un thread sta modificando la risorsa, ma consente l'accesso non esclusivo durante la lettura della risorsa.</xref:System.Threading.ReaderWriterLock></span><span class="sxs-lookup"><span data-stu-id="61e3b-182">The <xref:System.Threading.ReaderWriterLock> class enforces exclusive access to a resource while a thread is modifying the resource, but it allows non-exclusive access when reading the resource.</span></span> <span data-ttu-id="61e3b-183">Blocchi ReaderWriter rappresentano un'alternativa utile per i blocchi esclusivi, che altri thread in attesa, anche quando i thread non è necessitano aggiornare i dati.</span><span class="sxs-lookup"><span data-stu-id="61e3b-183">ReaderWriter locks are a useful alternative to exclusive locks, which cause other threads to wait, even when those threads do not need to update data.</span></span>  
  
## <a name="deadlocks"></a><span data-ttu-id="61e3b-184">Deadlock</span><span class="sxs-lookup"><span data-stu-id="61e3b-184">Deadlocks</span></span>  
 <span data-ttu-id="61e3b-185">La sincronizzazione dei thread si rivela particolarmente utile nelle applicazioni multithreading, ma è sempre presente il pericolo di creazione di un `deadlock`, in cui più thread in attesa di loro e l'applicazione si blocca.</span><span class="sxs-lookup"><span data-stu-id="61e3b-185">Thread synchronization is invaluable in multithreaded applications, but there is always the danger of creating a `deadlock`, where multiple threads are waiting for each other and the application comes to a halt.</span></span> <span data-ttu-id="61e3b-186">È analogo a una situazione in cui automobili sono stati interrotti in un'interruzione di quattro direzioni e ogni persona è in attesa per l'altra passare un deadlock.</span><span class="sxs-lookup"><span data-stu-id="61e3b-186">A deadlock is analogous to a situation in which cars are stopped at a four-way stop and each person is waiting for the other to go.</span></span> <span data-ttu-id="61e3b-187">Evitare i deadlock è importante. la chiave è un'attenta pianificazione.</span><span class="sxs-lookup"><span data-stu-id="61e3b-187">Avoiding deadlocks is important; the key is careful planning.</span></span> <span data-ttu-id="61e3b-188">È spesso possibile prevedere situazioni di deadlock creando diagrammi prima di iniziare la codifica di applicazioni multithread.</span><span class="sxs-lookup"><span data-stu-id="61e3b-188">You can often predict deadlock situations by diagramming multithreaded applications before you start coding.</span></span>  
  
## <a name="see-also"></a><span data-ttu-id="61e3b-189">Vedere anche</span><span class="sxs-lookup"><span data-stu-id="61e3b-189">See Also</span></span>  
 <span data-ttu-id="61e3b-190"><xref:System.Threading.Thread></xref:System.Threading.Thread></span><span class="sxs-lookup"><span data-stu-id="61e3b-190"><xref:System.Threading.Thread></span></span>   
 <span data-ttu-id="61e3b-191"><xref:System.Threading.WaitHandle.WaitOne%2A></xref:System.Threading.WaitHandle.WaitOne%2A></span><span class="sxs-lookup"><span data-stu-id="61e3b-191"><xref:System.Threading.WaitHandle.WaitOne%2A></span></span>   
 <span data-ttu-id="61e3b-192"><xref:System.Threading.WaitHandle.WaitAny%2A></xref:System.Threading.WaitHandle.WaitAny%2A></span><span class="sxs-lookup"><span data-stu-id="61e3b-192"><xref:System.Threading.WaitHandle.WaitAny%2A></span></span>   
 <span data-ttu-id="61e3b-193"><xref:System.Threading.WaitHandle.WaitAll%2A></xref:System.Threading.WaitHandle.WaitAll%2A></span><span class="sxs-lookup"><span data-stu-id="61e3b-193"><xref:System.Threading.WaitHandle.WaitAll%2A></span></span>   
 <span data-ttu-id="61e3b-194"><xref:System.Threading.Thread.Join%2A></xref:System.Threading.Thread.Join%2A></span><span class="sxs-lookup"><span data-stu-id="61e3b-194"><xref:System.Threading.Thread.Join%2A></span></span>   
 <span data-ttu-id="61e3b-195"><xref:System.Threading.Thread.Start%2A></xref:System.Threading.Thread.Start%2A></span><span class="sxs-lookup"><span data-stu-id="61e3b-195"><xref:System.Threading.Thread.Start%2A></span></span>   
 <span data-ttu-id="61e3b-196"><xref:System.Threading.Thread.Sleep%2A></xref:System.Threading.Thread.Sleep%2A></span><span class="sxs-lookup"><span data-stu-id="61e3b-196"><xref:System.Threading.Thread.Sleep%2A></span></span>   
 <span data-ttu-id="61e3b-197"><xref:System.Threading.Monitor></xref:System.Threading.Monitor></span><span class="sxs-lookup"><span data-stu-id="61e3b-197"><xref:System.Threading.Monitor></span></span>   
 <span data-ttu-id="61e3b-198"><xref:System.Threading.Mutex></xref:System.Threading.Mutex></span><span class="sxs-lookup"><span data-stu-id="61e3b-198"><xref:System.Threading.Mutex></span></span>   
 <span data-ttu-id="61e3b-199"><xref:System.Threading.AutoResetEvent></xref:System.Threading.AutoResetEvent></span><span class="sxs-lookup"><span data-stu-id="61e3b-199"><xref:System.Threading.AutoResetEvent></span></span>   
 <span data-ttu-id="61e3b-200"><xref:System.Threading.ManualResetEvent></xref:System.Threading.ManualResetEvent></span><span class="sxs-lookup"><span data-stu-id="61e3b-200"><xref:System.Threading.ManualResetEvent></span></span>   
 <span data-ttu-id="61e3b-201"><xref:System.Threading.Interlocked></xref:System.Threading.Interlocked></span><span class="sxs-lookup"><span data-stu-id="61e3b-201"><xref:System.Threading.Interlocked></span></span>   
 <span data-ttu-id="61e3b-202"><xref:System.Threading.WaitHandle></xref:System.Threading.WaitHandle></span><span class="sxs-lookup"><span data-stu-id="61e3b-202"><xref:System.Threading.WaitHandle></span></span>   
 <span data-ttu-id="61e3b-203"><xref:System.Threading.EventWaitHandle></xref:System.Threading.EventWaitHandle></span><span class="sxs-lookup"><span data-stu-id="61e3b-203"><xref:System.Threading.EventWaitHandle></span></span>   
 <span data-ttu-id="61e3b-204"><xref:System.Threading></xref:System.Threading></span><span class="sxs-lookup"><span data-stu-id="61e3b-204"><xref:System.Threading></span></span>   
 <span data-ttu-id="61e3b-205"><xref:System.Threading.EventWaitHandle.Set%2A></xref:System.Threading.EventWaitHandle.Set%2A></span><span class="sxs-lookup"><span data-stu-id="61e3b-205"><xref:System.Threading.EventWaitHandle.Set%2A></span></span>   
<span data-ttu-id="61e3b-206"> [Applicazioni multithreading (Visual Basic)](../../../../visual-basic/programming-guide/concepts/threading/multithreaded-applications.md) </span><span class="sxs-lookup"><span data-stu-id="61e3b-206"> [Multithreaded Applications (Visual Basic)](../../../../visual-basic/programming-guide/concepts/threading/multithreaded-applications.md) </span></span>  
<span data-ttu-id="61e3b-207"> [Istruzione SyncLock](../../../../visual-basic/language-reference/statements/synclock-statement.md) </span><span class="sxs-lookup"><span data-stu-id="61e3b-207"> [SyncLock Statement](../../../../visual-basic/language-reference/statements/synclock-statement.md) </span></span>  
<span data-ttu-id="61e3b-208"> [Mutex](http://msdn.microsoft.com/library/9dd06e25-12c0-4a9e-855a-452dc83803e2) </span><span class="sxs-lookup"><span data-stu-id="61e3b-208"> [Mutexes](http://msdn.microsoft.com/library/9dd06e25-12c0-4a9e-855a-452dc83803e2) </span></span>  
 @System.Threading.Monitor   
<span data-ttu-id="61e3b-209"> [Operazioni interlocked](http://msdn.microsoft.com/library/cbda7114-c752-4f3e-ada1-b1e8dd262f2b) </span><span class="sxs-lookup"><span data-stu-id="61e3b-209"> [Interlocked Operations](http://msdn.microsoft.com/library/cbda7114-c752-4f3e-ada1-b1e8dd262f2b) </span></span>  
<span data-ttu-id="61e3b-210"> [AutoResetEvent](http://msdn.microsoft.com/library/6d39c48d-6b37-4a9b-8631-f2924cfd9c18) </span><span class="sxs-lookup"><span data-stu-id="61e3b-210"> [AutoResetEvent](http://msdn.microsoft.com/library/6d39c48d-6b37-4a9b-8631-f2924cfd9c18) </span></span>  
<span data-ttu-id="61e3b-211"> [Sincronizzazione dei dati per il Multithreading](http://msdn.microsoft.com/library/b980eb4c-71d5-4860-864a-6dfe3692430a)</span><span class="sxs-lookup"><span data-stu-id="61e3b-211"> [Synchronizing Data for Multithreading](http://msdn.microsoft.com/library/b980eb4c-71d5-4860-864a-6dfe3692430a)</span></span>
