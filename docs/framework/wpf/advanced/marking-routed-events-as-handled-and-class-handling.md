---
title: Impostazione degli eventi indirizzati come gestiti e gestione delle classi
ms.date: 03/30/2017
helpviewer_keywords:
- tunneling events [WPF]
- class listeners [WPF]
- listeners [WPF]
- Preview routed events [WPF]
- instance listeners [WPF]
- events [WPF], bubbling
- suppressing events [WPF]
- routed events [WPF], Preview
- composited controls [WPF]
- events [WPF], tunneling
- routed events [WPF], marking as handled
- controls [WPF], compositing
- events [WPF], suppressing
- bubbling events [WPF]
ms.assetid: 5e745508-4861-4b48-b5f6-5fc7ce5289d2
ms.openlocfilehash: 2d696c85be0f46c5f08e1770f0d695dbb4d50cb9
ms.sourcegitcommit: 3d5d33f384eeba41b2dff79d096f47ccc8d8f03d
ms.translationtype: MT
ms.contentlocale: it-IT
ms.lasthandoff: 05/04/2018
---
# <a name="marking-routed-events-as-handled-and-class-handling"></a>Impostazione degli eventi indirizzati come gestiti e gestione delle classi
I gestori per un evento indirizzato possono contrassegnare l'evento come gestito all'interno dei dati dell'evento. La gestione dell'evento abbrevia efficacemente la route. La gestione delle classi è un concetto di programmazione supportato dagli eventi indirizzati. Un gestore classi ha l'opportunità di gestire un evento indirizzato specifico a livello di classe con un gestore richiamato prima di qualsiasi gestore istanze in qualsiasi istanza di classe.  
  

  
<a name="prerequisites"></a>   
## <a name="prerequisites"></a>Prerequisiti  
 Questo argomento elabora i concetti introdotti in [Cenni preliminari sugli eventi indirizzati](../../../../docs/framework/wpf/advanced/routed-events-overview.md).  
  
<a name="When_to_Mark_Events_as_Handled"></a>   
## <a name="when-to-mark-events-as-handled"></a>Quando contrassegnare eventi come gestiti  
 Quando si imposta il valore della <xref:System.Windows.RoutedEventArgs.Handled%2A> proprietà `true` nell'evento dati per un evento indirizzato, questo viene considerato "contrassegnando l'evento come gestito". Non esiste una regola assoluta riguardo a quando contrassegnare gli eventi indirizzati come gestiti, né per un autore di applicazioni né per un autore di controlli che risponde a eventi indirizzati esistenti o implementa nuovi eventi indirizzati. Per la maggior parte dei casi, il concetto di "gestito" se applicato ai dati dell'evento indirizzato deve essere usato come protocollo limitato per le risposte dell'applicazione a diversi eventi indirizzati esposti nelle [!INCLUDE[TLA2#tla_api#plural](../../../../includes/tla2sharptla-apisharpplural-md.md)] [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)], nonché per tutti gli eventi indirizzati personalizzati. Un altro modo di considerare il concetto di "gestito" è che in genere è necessario contrassegnare un evento indirizzato come gestito se il codice ha risposto all'evento indirizzato in modo significativo e relativamente completo. In genere, deve essere presente una sola risposta significativa che richiede implementazioni del gestore separate per qualsiasi singola occorrenza di un evento indirizzato. Se sono necessarie più risposte, il codice richiesto deve essere implementato tramite logica dell'applicazione concatenata a un singolo gestore, anziché usare il sistema degli eventi indirizzati per l'inoltro. Anche il concetto di "significativo" è soggettivo e dipende dall'applicazione o dal codice. Come indicazione generale, ecco alcuni esempi di "risposta significativa": impostazione dello stato attivo, modifica dello stato pubblico, impostazione delle proprietà che influiscono sulla rappresentazione visiva e generazione di altri nuovi eventi. Ecco inoltre alcuni esempi di risposte non significative: modifica dello stato privato (senza alcun impatto visivo o sulla rappresentazione programmatica), registrazione di eventi o esame degli argomenti di un evento e scelta di non rispondervi.  
  
 Il comportamento del sistema dell'evento indirizzato consolida questo modello di "risposta significativa" per l'utilizzo dello stato gestito di un evento indirizzato, poiché i gestori aggiunti [!INCLUDE[TLA2#tla_xaml](../../../../includes/tla2sharptla-xaml-md.md)] o la firma comune di <xref:System.Windows.UIElement.AddHandler%2A> non vengono richiamati in risposta a un evento indirizzato in cui l'evento dati sono già contrassegnato come gestiti. È necessario eseguire un'ulteriore operazione di aggiunta di un gestore con il `handledEventsToo` versione del parametro (<xref:System.Windows.UIElement.AddHandler%28System.Windows.RoutedEvent%2CSystem.Delegate%2CSystem.Boolean%29>) per gestire gli eventi indirizzati che sono contrassegnati come gestiti dai partecipanti precedenti nella route dell'evento.  
  
 In alcuni casi, i controlli stessi contrassegnano determinati eventi indirizzati come gestiti. Un evento indirizzato gestito rappresenta una decisione da parte degli autori di controlli [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] in base alla quale le azioni del controllo in risposta all'evento indirizzato sono significative o complete come parte dell'implementazione del controllo e che l'evento non richiede gestione aggiuntiva. Questo avviene in genere aggiungendo un gestore classi per un evento oppure eseguendo l'override di uno dei metodi virtuali del gestore classi presenti in una classe base. Se necessario, è comunque possibile trovare soluzioni alternative per questa gestione degli eventi. Vedere [Soluzioni alternative all'eliminazione di eventi da parte dei controlli](#WorkingAroundEventSuppressionByControls) più avanti in questo argomento.  
  
<a name="Preview_Events_vs__Bubbling_Events_and_Handling"></a>   
## <a name="preview-tunneling-events-vs-bubbling-events-and-event-handling"></a>Confronto tra eventi (di tunneling) "di anteprima" ed eventi di bubbling e gestione degli eventi  
 Gli eventi indirizzati di anteprima sono eventi che seguono una route di tunneling attraverso l'albero degli elementi. Il termine "anteprima" usato nella convenzione di denominazione è indicativo del principio generale per gli eventi di input in base al quale gli eventi indirizzati (di tunneling) di anteprima vengono generati prima dell'evento indirizzato di bubbling equivalente. Inoltre, gli eventi indirizzati di input dotati di una coppia di tunneling e bubbling hanno una logica di gestione distinta. Se l'evento indirizzato di tunneling/anteprima viene contrassegnato come gestito da un listener di eventi, l'evento indirizzato di bubbling verrà contrassegnato come gestito anche prima che qualsiasi listener dell'evento indirizzato di bubbling lo riceva. Gli eventi indirizzati di tunneling e bubbling sono tecnicamente eventi separati, ma condividono intenzionalmente la stessa istanza dei dati degli eventi per permettere questo comportamento.  
  
 La connessione tra gli eventi indirizzati di tunneling e bubbling viene eseguita tramite l'implementazione interna del modo in cui ogni classe [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] specifica genera i propri eventi indirizzati dichiarati e questo avviene per gli eventi indirizzati di input associati. Tuttavia, se questa implementazione a livello di classe non esiste, non vi è alcuna connessione tra un evento indirizzato di tunneling e un evento indirizzato di bubbling che condividono lo schema di denominazione: senza questa implementazione, i due eventi indirizzati sono completamente separati e non vengono generati in sequenza né condividono i dati degli eventi.  
  
 Per altre informazioni su come implementare coppie di eventi indirizzati di input di tunneling/bubbling in una classe personalizzata, vedere [Creare un evento indirizzato personalizzato](../../../../docs/framework/wpf/advanced/how-to-create-a-custom-routed-event.md).  
  
<a name="Class_Handlers_and_Instance_Handlers"></a>   
## <a name="class-handlers-and-instance-handlers"></a>Gestori classi e gestori istanze  
 Gli eventi indirizzati considerano due tipi diversi di listener per l'evento: listener di classi e listener di istanze. Listener di classe esistono poiché i tipi hanno chiamato un determinato <xref:System.Windows.EventManager> [!INCLUDE[TLA2#tla_api](../../../../includes/tla2sharptla-api-md.md)] ,<xref:System.Windows.EventManager.RegisterClassHandler%2A>, nel costruttore statico, o è stato eseguito l'override di un metodo virtuale del gestore della classe dalla classe di base di un elemento. Listener di istanze sono elementi/istanze di classe specifico in cui sono stati associati uno o più gestori per l'evento indirizzato da una chiamata a <xref:System.Windows.UIElement.AddHandler%2A>. Esistente [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] gli eventi indirizzati effettuano chiamate a <xref:System.Windows.UIElement.AddHandler%2A> come parte del [!INCLUDE[TLA#tla_clr](../../../../includes/tlasharptla-clr-md.md)] wrapper evento aggiungere{} e rimuovere{} implementazioni dell'evento, che è anche come semplici [!INCLUDE[TLA2#tla_xaml](../../../../includes/tla2sharptla-xaml-md.md)] meccanismo di collegamento gestori di eventi tramite una sintassi di attributo è abilitata. Pertanto, anche il semplice [!INCLUDE[TLA2#tla_xaml](../../../../includes/tla2sharptla-xaml-md.md)] utilizzo equivale in definitiva a una <xref:System.Windows.UIElement.AddHandler%2A> chiamare.  
  
 Gli elementi all'interno dell'albero visuale vengono controllati per individuare le eventuali implementazioni di gestori registrati. I gestori vengono potenzialmente richiamati lungo la route, nell'ordine ereditato nel tipo della strategia di routing per l'evento indirizzato specifico. Ad esempio, gli eventi indirizzati di bubbling richiameranno prima di tutto i gestori collegati allo stesso elemento che ha generato l'evento indirizzato. L'evento indirizzato viene propagato al successivo elemento padre e così via fino a raggiungere l'elemento radice dell'applicazione.  
  
 Dal punto di vista dell'elemento radice in una route di bubbling, se la gestione delle classi o qualsiasi elemento più vicino all'origine dell'evento indirizzato richiama gestori che contrassegnano gli argomenti dell'evento come gestiti, i gestori negli elementi radice non vengono richiamati e la route dell'evento viene abbreviata in modo efficace prima di raggiungere l'elemento radice. Tuttavia, la route non viene completamente interrotta, perché è possibile aggiungere gestori con una speciale condizione in base alla quale devono comunque essere richiamati, anche se un gestore classi o un gestore istanze ha contrassegnato l'evento indirizzato come gestito. Questo comportamento viene descritto in [Aggiunta di gestori istanze generati anche se gli eventi sono contrassegnati come gestiti](#AddingInstanceHandlersthatAreRaisedEvenWhenEventsareMarkedHandled) più avanti in questo argomento.  
  
 A un livello più profondo rispetto a quello della route degli eventi esistono potenzialmente anche più gestori classi che agiscono su qualsiasi istanza specifica di una classe. Questo avviene perché il modello di gestione delle classi per eventi indirizzati permette a tutte le possibili classi in una gerarchia di classi di registrare ciascuna il proprio gestore classi per ogni evento indirizzato. Ogni gestore classi viene aggiunto a un archivio interno e quando viene creata la route degli eventi per un'applicazione, i gestori classi vengono tutti aggiunti alla route. I gestori classi vengono aggiunti alla route in modo che venga richiamato per primo il gestore della classe più derivata, richiamando quindi i gestori classi da ogni classe base successiva. In genere i gestori classi non sono registrati in modo da rispondere anche a eventi indirizzati già contrassegnati come gestiti. Di conseguenza, questo meccanismo di gestione delle classi permette di scegliere tra due opzioni:  
  
-   Le classi derivate possono completare la gestione delle classi ereditata dalla classe base aggiungendo un gestore che non contrassegna l'evento indirizzato come gestito, perché il gestore della classe base verrà richiamato in un momento successivo al gestore delle classi derivate.  
  
-   Le classi derivate possono sostituire la gestione delle classi dalla classe base tramite l'aggiunta di un gestore classi che contrassegna l'evento indirizzato come gestito. È necessario usare questo approccio con cautela, perché potrebbe modificare la progettazione dei controlli di base desiderata, ad esempio in aree come l'aspetto visivo, la logica di stato, la gestione degli input e la gestione dei comandi.  
  
<a name="Class_Handling_of_Routed_Events"></a>   
## <a name="class-handling-of-routed-events-by-control-base-classes"></a>Gestione delle classi degli eventi indirizzati tramite classi di base dei controlli  
 Nel nodo di ogni elemento specifico in una route di eventi i listener di classi possono rispondere all'evento indirizzato prima di qualsiasi listener di istanze per l'elemento. Per questo motivo, i gestori classi vengono usati talvolta per eliminare gli eventi indirizzati che l'implementazione di una determinata classe di controlli non desidera propagare ulteriormente oppure per fornire una gestione speciale dell'evento indirizzato che è una caratteristica della classe. Ad esempio, una classe potrebbe generare il proprio evento specifico della classe che contiene più specifiche sul significato di una certa condizione di input utente nel contesto di una determinata classe. L'implementazione della classe potrebbe quindi contrassegnare come gestito l'evento indirizzato più generale. Gestori di classi in genere vengono aggiunti in modo che non vengano richiamati per indirizzato gestiti gli eventi in cui i dati di evento condiviso era già contrassegnati, ma per i casi atipici è presente anche un <xref:System.Windows.EventManager.RegisterClassHandler%28System.Type%2CSystem.Windows.RoutedEvent%2CSystem.Delegate%2CSystem.Boolean%29> firma che registra i gestori di classi per richiamare anche quando gli eventi indirizzati sono contrassegnato come gestito.  
  
### <a name="class-handler-virtuals"></a>Metodi virtuali dei gestori classi  
 Alcuni elementi, in particolare gli elementi di base, ad esempio <xref:System.Windows.UIElement>, espongono vuoto "su * evento" e "OnPreview\*evento" metodi virtuali che corrispondono al relativo elenco di eventi indirizzati pubblici. È possibile eseguire l'override di questi metodi virtuali per implementare un gestore classi per l'evento indirizzato. Le classi di elemento di base registrano questi metodi virtuali come gestore di classi per ognuno di tali indirizzato eventi utilizzando <xref:System.Windows.EventManager.RegisterClassHandler%28System.Type%2CSystem.Windows.RoutedEvent%2CSystem.Delegate%2CSystem.Boolean%29> come descritto in precedenza. I metodi virtuali On\*Event semplificano notevolmente l'implementazione della gestione delle classi per gli eventi indirizzati pertinenti, senza richiedere attività di inizializzazione speciali nei costruttori statici per ogni tipo. Ad esempio, è possibile aggiungere Gestione della classe per il <xref:System.Windows.UIElement.DragEnter> eventi in qualsiasi <xref:System.Windows.UIElement> derivata eseguendo l'override di <xref:System.Windows.UIElement.OnDragEnter%2A> metodo virtuale. All'interno dell'override è possibile gestire l'evento indirizzato, generare altri eventi, avviare una logica specifica della classe che può modificare le proprietà degli elementi nelle istanze o scegliere qualsiasi combinazione di queste azioni. È in genere consigliabile chiamare l'implementazione base in questi override, anche se si contrassegna l'evento come gestito. La chiamata dell'implementazione base è fortemente consigliata perché il metodo virtuale è incluso nella classe base. Il modello virtuale protetto standard costituito dalla chiamata delle implementazioni base da ogni metodo virtuale essenzialmente sostituisce ed eguaglia un meccanismo simile che è nativo per la gestione delle classi degli eventi indirizzati, in cui i gestori classi per tutte le classi in una gerarchia di classi vengono chiamati in qualsiasi istanza specifica, a partire dal gestore della classe più derivata e continuando fino al gestore della classe base. È necessario omettere la chiamata dell'implementazione base solo se la classe prevede un requisito intenzionale relativo alla modifica della logica di gestione delle classi base. Se si chiamerà l'implementazione base prima o dopo l'override del codice dipende dalla natura dell'implementazione.  
  
#### <a name="input-event-class-handling"></a>Gestione delle classi degli eventi di input  
 I metodi virtuali dei gestori classi vengono tutti registrati in modo da essere richiamati solo in presenza di dati degli eventi condivisi che non sono già stati contrassegnati come gestiti. Inoltre, solo per gli eventi di input, le versioni di tunneling e bubbling vengono normalmente generate in sequenza e condividono i dati degli eventi. Di conseguenza, per una specifica coppia di gestori classi di eventi di input in cui uno corrisponde alla versione di tunneling e l'altro alla versione di bubbling, si potrebbe non voler contrassegnare immediatamente l'evento come gestito. Se si implementa il metodo virtuale della gestione delle classi di tunneling per contrassegnare l'evento come gestito, si impedirà al gestore classi di bubbling di essere richiamato, oltre a impedire la chiamata dei gestori istanze normalmente registrati per l'evento di tunneling o di bubbling.  
  
 Quando la gestione delle classi in un nodo è completa, vengono presi in considerazione i listener di istanze.  
  
<a name="AddingInstanceHandlersthatAreRaisedEvenWhenEventsareMarkedHandled"></a>   
## <a name="adding-instance-handlers-that-are-raised-even-when-events-are-marked-handled"></a>Aggiunta di gestori istanze generati anche se gli eventi sono contrassegnati come gestiti  
 Il <xref:System.Windows.UIElement.AddHandler%2A> metodo fornisce un overload specifico che consente di aggiungere i gestori che verranno richiamati dal sistema di eventi ogni volta che un evento raggiunge l'elemento di gestione del ciclo di lavorazione, anche se un altro gestore già ha modificato i dati dell'evento per contrassegnare che evento come gestito. Questo non è il comportamento più comune. In genere, i gestori possono essere scritti in modo da modificare tutte le aree del codice dell'applicazione che potrebbero essere influenzate da un evento, indipendentemente dal punto in cui questo è stato gestito nell'albero degli elementi, anche nei casi in cui si desiderano più risultati finali. Inoltre, in genere, un solo elemento deve rispondere all'evento e la logica dell'applicazione appropriata è già stata applicata. Tuttavia, è disponibile l'overload `handledEventsToo` per i casi eccezionali in cui un altro elemento in un albero di elementi o in una composizione di controlli ha già contrassegnato un evento come gestito, ma altri elementi in posizione superiore o inferiore nell'albero degli elementi (a seconda della route) vogliono comunque che i rispettivi gestori vengano richiamati.  
  
#### <a name="when-to-mark-handled-events-as-unhandled"></a>Quando contrassegnare eventi gestiti come non gestiti  
 In genere, gli eventi indirizzati che sono contrassegnati come gestiti non devono essere contrassegnati come non gestiti (<xref:System.Windows.RoutedEventArgs.Handled%2A> reimpostarlo a `false`) anche da gestori che agiscono su `handledEventsToo`. Tuttavia, alcuni eventi di input hanno rappresentazioni di eventi di alto livello e di livello inferiore che possono sovrapporsi quando l'evento di alto livello viene visualizzato in una posizione nell'albero e quello di basso livello viene visualizzato in un'altra posizione. Ad esempio, si consideri il caso in cui un elemento figlio è in attesa di un evento di chiave di alto livello, ad esempio <xref:System.Windows.UIElement.TextInput> mentre un elemento padre è in ascolto un evento di basso livello, ad esempio <xref:System.Windows.UIElement.KeyDown>. Se l'elemento padre gestisce l'evento di basso livello, l'evento di livello superiore può essere eliminato anche nell'elemento figlio che dovrebbe avere la prima opportunità di gestire l'evento.  
  
 In queste situazioni può essere necessario aggiungere gestori sia agli elementi padre sia agli elementi figlio per l'evento di basso livello. L'implementazione del gestore dell'elemento figlio può contrassegnare l'evento di basso livello come gestito, ma l'implementazione del gestore dell'elemento padre lo imposterebbe di nuovo come non gestito per permettere ad altri elementi di livello superiore nell'albero (nonché all'evento di alto livello) di rispondere. Questa situazione dovrebbe essere piuttosto rara.  
  
<a name="Deliberately_Suppressing_Input_Events_for_Control"></a>   
## <a name="deliberately-suppressing-input-events-for-control-compositing"></a>Eliminazione intenzionale di eventi di input per la composizione dei controlli  
 Lo scenario principale in cui viene usata la gestione delle classi per eventi indirizzati riguarda gli eventi di input e i controlli compositi. Un controllo composito è per definizione composto da più controlli pratici o classi base di controlli. Spesso l'autore del controllo desidera comporre in modo uniforme tutti i possibili eventi di input che possono essere generati da ognuno dei sottocomponenti, per segnalare l'intero controllo come singola origine evento. In alcuni casi, l'autore del controllo potrebbe desiderare di eliminare interamente gli eventi dai componenti oppure sostituire un evento definito da un componente che contiene più informazioni o implica un comportamento più specifico. L'esempio canonico è immediatamente visibile a qualsiasi autore di componenti è come un [!INCLUDE[TLA#tla_winclient](../../../../includes/tlasharptla-winclient-md.md)] <xref:System.Windows.Controls.Button> gestisce qualsiasi evento del mouse che verrà risolto l'evento intuitiva che tutti i pulsanti hanno: un <xref:System.Windows.Controls.Primitives.ButtonBase.Click> evento.  
  
 Il <xref:System.Windows.Controls.Button> classe di base (<xref:System.Windows.Controls.Primitives.ButtonBase>) deriva da <xref:System.Windows.Controls.Control> che a sua volta deriva da <xref:System.Windows.FrameworkElement> e <xref:System.Windows.UIElement>e la maggior parte dell'infrastruttura di evento necessaria per l'elaborazione dell'input del controllo è disponibile all'indirizzo di <xref:System.Windows.UIElement> livello. In particolare, <xref:System.Windows.UIElement> elabora generale <xref:System.Windows.Input.Mouse> gli eventi che gestiscono l'hit testing per il cursore del mouse all'interno dei limiti e fornisce eventi distinti per più comuni pulsante azioni, ad esempio <xref:System.Windows.UIElement.MouseLeftButtonDown>. <xref:System.Windows.UIElement> fornisce inoltre un oggetto virtuale vuoto <xref:System.Windows.UIElement.OnMouseLeftButtonDown%2A> come gestore per la classe preregistrato <xref:System.Windows.UIElement.MouseLeftButtonDown>, e <xref:System.Windows.Controls.Primitives.ButtonBase> ne esegue l'override. Analogamente, <xref:System.Windows.Controls.Primitives.ButtonBase> utilizza gestori di classi per <xref:System.Windows.UIElement.MouseLeftButtonUp>. Le sostituzioni, che vengono passati i dati dell'evento, le implementazioni contrassegnano che <xref:System.Windows.RoutedEventArgs> istanza come gestito impostando <xref:System.Windows.RoutedEventArgs.Handled%2A> a `true`, e che i dati dell'evento stesso siano continuano nella parte restante della route da altri gestori di classi e anche per i gestori di istanze o metodi set dell'evento. Inoltre, il <xref:System.Windows.Controls.Primitives.ButtonBase.OnMouseLeftButtonUp%2A> override successivamente genererà il <xref:System.Windows.Controls.Primitives.ButtonBase.Click> evento. Il risultato finale per la maggior parte dei listener sarà quello di <xref:System.Windows.UIElement.MouseLeftButtonDown> e <xref:System.Windows.UIElement.MouseLeftButtonUp> eventi "scompaiono" e la relativa sostituzione con <xref:System.Windows.Controls.Primitives.ButtonBase.Click>, un evento più significativo poiché è noto che ha avuto origine questo evento da un pulsante effettivo, non solo alcuni composito di parti del pulsante o da un altro elemento completamente.  
  
<a name="WorkingAroundEventSuppressionByControls"></a>   
### <a name="working-around-event-suppression-by-controls"></a>Soluzioni alternative all'eliminazione di eventi da parte dei controlli  
 A volte questo comportamento di eliminazione di eventi all'interno di singoli controlli può interferire con alcune intenzioni più generali della logica di gestione degli eventi per l'applicazione. Ad esempio, se per qualche motivo l'applicazione presentava un gestore per <xref:System.Windows.UIElement.MouseLeftButtonDown> si trova in corrispondenza dell'elemento radice dell'applicazione, è possibile notare che qualsiasi clic del mouse su un pulsante non richiama <xref:System.Windows.UIElement.MouseLeftButtonDown> o <xref:System.Windows.UIElement.MouseLeftButtonUp> gestori al livello radice. L'evento stesso è stato effettivamente propagato. Come già detto, le route degli eventi non vengono davvero completate, ma il sistema degli eventi indirizzati ne modifica il comportamento di chiamata del gestore dopo che gli eventi sono stati contrassegnati come gestiti. Quando l'evento indirizzato ha raggiunto il pulsante, il <xref:System.Windows.Controls.Primitives.ButtonBase> gestione delle classi contrassegnato il <xref:System.Windows.UIElement.MouseLeftButtonDown> gestita perché per sostituire il <xref:System.Windows.Controls.Primitives.ButtonBase.Click> evento con più significato. Pertanto, qualsiasi standard <xref:System.Windows.UIElement.MouseLeftButtonDown> ulteriormente gestore di route non verrà richiamato. Esistono due tecniche che è possibile usare per garantire che i gestori vengano richiamati in questo caso.  
  
 La prima tecnica consiste nell'aggiunta intenzionale del gestore utilizzando il `handledEventsToo` firma di <xref:System.Windows.UIElement.AddHandler%28System.Windows.RoutedEvent%2CSystem.Delegate%2CSystem.Boolean%29>. Una limitazione di questo approccio è che la tecnica di collegamento di un gestore eventi è possibile solo dal codice, non dal markup. La semplice sintassi per specificare il nome del gestore eventi come valore di attributo dell'evento tramite [!INCLUDE[TLA#tla_xaml](../../../../includes/tlasharptla-xaml-md.md)] non permette questo comportamento.  
  
 La seconda tecnica può essere usata solo per gli eventi di input, le cui versioni di tunneling e bubbling dell'evento indirizzato sono associate. Per questi eventi indirizzati, è invece possibile aggiungere gestori all'evento indirizzato di anteprima/tunneling equivalente. Poiché l'evento indirizzato percorre tramite tunneling la route a partire dalla radice, il codice di gestione delle classi del pulsante non lo intercetta, presumendo che il gestore di anteprima sia stato collegato a livello di un elemento predecessore nell'albero degli elementi dell'applicazione. Se si usa questo approccio, contrassegnare con cautela qualsiasi evento di anteprima come gestito. Per l'esempio fornito con <xref:System.Windows.UIElement.PreviewMouseLeftButtonDown> gestita in corrispondenza dell'elemento radice, se è stato contrassegnato l'evento come <xref:System.Windows.RoutedEventArgs.Handled%2A> nell'implementazione del gestore, è effettivamente eliminare il <xref:System.Windows.Controls.Primitives.ButtonBase.Click> evento. Questo non è un comportamento consigliato.  
  
## <a name="see-also"></a>Vedere anche  
 <xref:System.Windows.EventManager>  
 [Eventi di anteprima](../../../../docs/framework/wpf/advanced/preview-events.md)  
 [Creare un evento indirizzato personalizzato](../../../../docs/framework/wpf/advanced/how-to-create-a-custom-routed-event.md)  
 [Cenni preliminari sugli eventi indirizzati](../../../../docs/framework/wpf/advanced/routed-events-overview.md)
