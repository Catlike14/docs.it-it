---
title: Definizione di tipi personalizzati da utilizzare con i servizi XAML di .NET Framework
ms.custom: 
ms.date: 03/30/2017
ms.prod: .net-framework
ms.reviewer: 
ms.suite: 
ms.technology: dotnet-wpf
ms.tgt_pltfrm: 
ms.topic: article
helpviewer_keywords: defining custom types [XAML Services]
ms.assetid: c2667cbd-2f46-4a7f-9dfc-53696e35e8e4
caps.latest.revision: "11"
author: wadepickett
ms.author: wpickett
manager: wpickett
ms.workload: dotnet
ms.openlocfilehash: c7cce479c7c7a5f6c7112f08f1e15f3bc7e4d366
ms.sourcegitcommit: 16186c34a957fdd52e5db7294f291f7530ac9d24
ms.translationtype: MT
ms.contentlocale: it-IT
ms.lasthandoff: 12/22/2017
---
# <a name="defining-custom-types-for-use-with-net-framework-xaml-services"></a><span data-ttu-id="f3d1b-102">Definizione di tipi personalizzati da utilizzare con i servizi XAML di .NET Framework</span><span class="sxs-lookup"><span data-stu-id="f3d1b-102">Defining Custom Types for Use with .NET Framework XAML Services</span></span>
<span data-ttu-id="f3d1b-103">Quando si definiscono i tipi personalizzati che sono oggetti business o tipi che non dispongono di una dipendenza su Framework specifici, esistono alcune procedure consigliate per XAML è possibile seguire.</span><span class="sxs-lookup"><span data-stu-id="f3d1b-103">When you define custom types that are business objects or are types that do not have a dependency on specific frameworks, there are certain best practices for XAML you can follow.</span></span> <span data-ttu-id="f3d1b-104">Se si seguono queste procedure, servizi XAML di .NET Framework e i relativi reader XAML e writer XAML possono individuare le caratteristiche XAML del tipo e assegnargli una rappresentazione appropriata in un flusso del nodo XAML tramite il sistema di tipi XAML.</span><span class="sxs-lookup"><span data-stu-id="f3d1b-104">If you follow these practices, .NET Framework XAML Services and its XAML readers and XAML writers can discover the XAML characteristics of your type and give it appropriate representation in a XAML node stream using the XAML type system.</span></span> <span data-ttu-id="f3d1b-105">In questo argomento vengono descritte le procedure consigliate per le definizioni dei tipi, le definizioni dei membri e assegnazione di attributi CLR di tipi o membri.</span><span class="sxs-lookup"><span data-stu-id="f3d1b-105">This topic describes best practices for type definitions, member definitions, and CLR attributing of types or members.</span></span>  
  
## <a name="constructor-patterns-and-type-definitions-for-xaml"></a><span data-ttu-id="f3d1b-106">Modelli di costruttore e definizioni di tipi per XAML</span><span class="sxs-lookup"><span data-stu-id="f3d1b-106">Constructor Patterns and Type Definitions for XAML</span></span>  
 <span data-ttu-id="f3d1b-107">Per creare un'istanza come elemento oggetto in XAML, una classe personalizzata deve soddisfare i requisiti seguenti:</span><span class="sxs-lookup"><span data-stu-id="f3d1b-107">To be instantiated as an object element in XAML, a custom class must meet the following requirements:</span></span>  
  
-   <span data-ttu-id="f3d1b-108">La classe personalizzata deve essere pubblica e deve esporre un costruttore pubblico (senza parametri) predefinito.</span><span class="sxs-lookup"><span data-stu-id="f3d1b-108">The custom class must be public and must expose a default (parameterless) public constructor.</span></span> <span data-ttu-id="f3d1b-109">Per alcune note riguardanti le strutture, vedere la sezione seguente.</span><span class="sxs-lookup"><span data-stu-id="f3d1b-109">(See following section for notes regarding structures.)</span></span>  
  
-   <span data-ttu-id="f3d1b-110">La classe personalizzata non deve essere una classe annidata.</span><span class="sxs-lookup"><span data-stu-id="f3d1b-110">The custom class must not be a nested class.</span></span> <span data-ttu-id="f3d1b-111">"Punto" il nome completo di percorso aggiuntivo rende ambiguo la divisione di spazio dei nomi di classe e interferisce con altre funzionalità XAML, ad esempio le proprietà associate.</span><span class="sxs-lookup"><span data-stu-id="f3d1b-111">The extra "dot" in the full-name path makes the class-namespace division ambiguous, and interferes with other XAML features such as attached properties.</span></span>  
  
 <span data-ttu-id="f3d1b-112">Se è possibile creare istanze di un oggetto come un elemento oggetto, l'oggetto creato può inserire la forma di elemento di proprietà di qualsiasi proprietà che accetta l'oggetto come tipo sottostante.</span><span class="sxs-lookup"><span data-stu-id="f3d1b-112">If an object can be instantiated as an object element, the created object can fill the property element form of any properties that take the object as their underlying type.</span></span>  
  
 <span data-ttu-id="f3d1b-113">È comunque possibile fornire i valori dell'oggetto per i tipi che non soddisfano questi criteri, se si abilita un convertitore di valori.</span><span class="sxs-lookup"><span data-stu-id="f3d1b-113">You can still provide object values for types that do not meet these criteria, if you enable a value converter.</span></span> <span data-ttu-id="f3d1b-114">Per ulteriori informazioni, vedere [convertitori di tipi ed estensioni di Markup per XAML](../../../docs/framework/xaml-services/type-converters-and-markup-extensions-for-xaml.md).</span><span class="sxs-lookup"><span data-stu-id="f3d1b-114">For more information, see [Type Converters and Markup Extensions for XAML](../../../docs/framework/xaml-services/type-converters-and-markup-extensions-for-xaml.md).</span></span>  
  
### <a name="structures"></a><span data-ttu-id="f3d1b-115">Strutture</span><span class="sxs-lookup"><span data-stu-id="f3d1b-115">Structures</span></span>  
 <span data-ttu-id="f3d1b-116">Le strutture sono sempre in grado di essere costruito in XAML, per definizione di CLR.</span><span class="sxs-lookup"><span data-stu-id="f3d1b-116">Structures are always able to be constructed in XAML, by CLR definition.</span></span> <span data-ttu-id="f3d1b-117">Questo avviene perché un compilatore CLR crea in modo implicito un costruttore predefinito per una struttura.</span><span class="sxs-lookup"><span data-stu-id="f3d1b-117">This is because a CLR compiler implicitly creates a default constructor for a structure.</span></span> <span data-ttu-id="f3d1b-118">Questo costruttore inizializza tutti i valori di proprietà sui valori predefiniti.</span><span class="sxs-lookup"><span data-stu-id="f3d1b-118">This constructor initializes all property values to their defaults.</span></span>  
  
 <span data-ttu-id="f3d1b-119">In alcuni casi, il comportamento di costruzione predefinita per una struttura non è auspicabile.</span><span class="sxs-lookup"><span data-stu-id="f3d1b-119">In some cases, the default construction behavior for a structure is not desirable.</span></span> <span data-ttu-id="f3d1b-120">È possibile che la struttura deve compilare concettualmente come un'unione di valori e funzioni.</span><span class="sxs-lookup"><span data-stu-id="f3d1b-120">This might be because the structure is intended to fill values and function conceptually as a union.</span></span> <span data-ttu-id="f3d1b-121">Come un'unione, i valori contenuti potrebbero avere interpretazioni si escludono a vicenda e, pertanto, nessuna delle proprietà possono essere impostata.</span><span class="sxs-lookup"><span data-stu-id="f3d1b-121">As a union, the contained values might have mutually exclusive interpretations, and therefore, none of its properties are settable.</span></span> <span data-ttu-id="f3d1b-122">Un esempio di una struttura nel vocabolario WPF è <xref:System.Windows.GridLength>.</span><span class="sxs-lookup"><span data-stu-id="f3d1b-122">An example of such a structure in the WPF vocabulary is <xref:System.Windows.GridLength>.</span></span> <span data-ttu-id="f3d1b-123">Tali strutture devono implementare un convertitore di tipi in modo che i valori possono essere espressi in forma di attributo, utilizzando le convenzioni di stringa che creano le interpretazioni o modalità diverse di valori di struttura.</span><span class="sxs-lookup"><span data-stu-id="f3d1b-123">Such structures should implement a type converter so that the values can be expressed in attribute form, by using string conventions that create the different interpretations or modes of the structure values.</span></span> <span data-ttu-id="f3d1b-124">La struttura deve anche esporre un comportamento simile per la costruzione del codice tramite un costruttore non predefinito.</span><span class="sxs-lookup"><span data-stu-id="f3d1b-124">The structure should also expose similar behavior for code construction through a non-default constructor.</span></span>  
  
### <a name="interfaces"></a><span data-ttu-id="f3d1b-125">Interfacce</span><span class="sxs-lookup"><span data-stu-id="f3d1b-125">Interfaces</span></span>  
 <span data-ttu-id="f3d1b-126">Interfacce possono essere utilizzate come tipi sottostanti di membri.</span><span class="sxs-lookup"><span data-stu-id="f3d1b-126">Interfaces can be used as underlying types of members.</span></span> <span data-ttu-id="f3d1b-127">Sistema di tipi XAML controlla l'elenco può essere assegnato e non prevede che è possibile assegnare l'oggetto che viene fornito come valore per l'interfaccia.</span><span class="sxs-lookup"><span data-stu-id="f3d1b-127">The XAML type system checks the assignable list and expects that the object that is provided as the value can be assigned to the interface.</span></span> <span data-ttu-id="f3d1b-128">Non vi è alcun concetto di modalità di presentazione dell'interfaccia come tipo XAML come un tipo assegnabile pertinente supporti i requisiti di costruzione XAML.</span><span class="sxs-lookup"><span data-stu-id="f3d1b-128">There is no concept of how the interface must be presented as a XAML type as long as a relevant assignable type supports the XAML construction requirements.</span></span>  
  
### <a name="factory-methods"></a><span data-ttu-id="f3d1b-129">Metodi factory</span><span class="sxs-lookup"><span data-stu-id="f3d1b-129">Factory Methods</span></span>  
 <span data-ttu-id="f3d1b-130">Metodi factory sono una funzionalità di XAML 2009.</span><span class="sxs-lookup"><span data-stu-id="f3d1b-130">Factory methods are a XAML 2009 feature.</span></span> <span data-ttu-id="f3d1b-131">Modificare il principio XAML che gli oggetti devono avere costruttori predefiniti.</span><span class="sxs-lookup"><span data-stu-id="f3d1b-131">They modify the XAML principle that objects must have default constructors.</span></span> <span data-ttu-id="f3d1b-132">Metodi factory non sono documentati in questo argomento.</span><span class="sxs-lookup"><span data-stu-id="f3d1b-132">Factory methods are not documented in this topic.</span></span> <span data-ttu-id="f3d1b-133">Vedere [direttiva X:FactoryMethod](../../../docs/framework/xaml-services/x-factorymethod-directive.md).</span><span class="sxs-lookup"><span data-stu-id="f3d1b-133">See [x:FactoryMethod Directive](../../../docs/framework/xaml-services/x-factorymethod-directive.md).</span></span>  
  
## <a name="enumerations"></a><span data-ttu-id="f3d1b-134">Enumerazioni</span><span class="sxs-lookup"><span data-stu-id="f3d1b-134">Enumerations</span></span>  
 <span data-ttu-id="f3d1b-135">Le enumerazioni dispongono di comportamento di conversione di tipo nativo di XAML.</span><span class="sxs-lookup"><span data-stu-id="f3d1b-135">Enumerations have XAML native type conversion behavior.</span></span> <span data-ttu-id="f3d1b-136">Nomi di costanti di enumerazione specificati in XAML vengono risolte rispetto al tipo di enumerazione sottostante e restituiscono il valore di enumerazione per un writer di oggetti XAML.</span><span class="sxs-lookup"><span data-stu-id="f3d1b-136">Enumeration constant names specified in XAML are resolved against the underlying enumeration type, and return the enumeration value to a XAML object writer.</span></span>  
  
 <span data-ttu-id="f3d1b-137">XAML supporta l'utilizzo dello stile flag per le enumerazioni con <xref:System.FlagsAttribute> applicato.</span><span class="sxs-lookup"><span data-stu-id="f3d1b-137">XAML supports a flags-style usage for enumerations with <xref:System.FlagsAttribute> applied.</span></span> <span data-ttu-id="f3d1b-138">Per ulteriori informazioni, vedere [sintassi di XAML In dettaglio](../../../docs/framework/wpf/advanced/xaml-syntax-in-detail.md).</span><span class="sxs-lookup"><span data-stu-id="f3d1b-138">For more information, see [XAML Syntax In Detail](../../../docs/framework/wpf/advanced/xaml-syntax-in-detail.md).</span></span> <span data-ttu-id="f3d1b-139">([Sintassi di XAML In dettaglio](../../../docs/framework/wpf/advanced/xaml-syntax-in-detail.md) viene scritto per il pubblico WPF, ma la maggior parte delle informazioni in questo argomento è rilevante per il codice XAML non è specifico di un particolare framework di implementazione.)</span><span class="sxs-lookup"><span data-stu-id="f3d1b-139">([XAML Syntax In Detail](../../../docs/framework/wpf/advanced/xaml-syntax-in-detail.md) is written for the WPF audience, but most of the information in that topic is relevant for XAML that is not specific to a particular implementing framework.)</span></span>  
  
## <a name="member-definitions"></a><span data-ttu-id="f3d1b-140">Definizioni dei membri</span><span class="sxs-lookup"><span data-stu-id="f3d1b-140">Member Definitions</span></span>  
 <span data-ttu-id="f3d1b-141">Tipi possono definire membri per l'utilizzo di XAML.</span><span class="sxs-lookup"><span data-stu-id="f3d1b-141">Types can define members for XAML usage.</span></span> <span data-ttu-id="f3d1b-142">È possibile che i tipi che definiscono i membri che possono essere utilizzati con XAML anche se il tipo specifico non è utilizzabile con XAML.</span><span class="sxs-lookup"><span data-stu-id="f3d1b-142">It is possible for types that define members that are XAML-usable even if that specific type is not XAML-usable.</span></span> <span data-ttu-id="f3d1b-143">Questo è possibile a causa di ereditarietà di CLR.</span><span class="sxs-lookup"><span data-stu-id="f3d1b-143">This is possible because of CLR inheritance.</span></span> <span data-ttu-id="f3d1b-144">Se un tipo che eredita il membro supporta l'utilizzo XAML come tipo e il membro supporta l'utilizzo della sintassi XAML per il relativo tipo sottostante o ha una sintassi XAML nativa, il membro è utilizzabile con XAML.</span><span class="sxs-lookup"><span data-stu-id="f3d1b-144">So long as some type that inherits the member supports XAML usage as a type, and the member supports XAML usage for its underlying type or has a native XAML syntax available, that member is XAML-usable.</span></span>  
  
### <a name="properties"></a><span data-ttu-id="f3d1b-145">Proprietà</span><span class="sxs-lookup"><span data-stu-id="f3d1b-145">Properties</span></span>  
 <span data-ttu-id="f3d1b-146">Se si definiscono proprietà come proprietà CLR pubblica utilizzando CLR tipico `get` e `set` modelli di funzione di accesso e parole chiave appropriata per la lingua, il sistema di tipi XAML può segnalare la proprietà come un membro con le informazioni appropriate previste <xref:System.Xaml.XamlMember> proprietà, ad esempio <xref:System.Xaml.XamlMember.IsReadPublic%2A> e <xref:System.Xaml.XamlMember.IsWritePublic%2A>.</span><span class="sxs-lookup"><span data-stu-id="f3d1b-146">If you define properties as a public CLR property using the typical CLR `get` and `set` accessor patterns and language-appropriate keywording, the XAML type system can report the property as a member with appropriate information provided for <xref:System.Xaml.XamlMember> properties, such as <xref:System.Xaml.XamlMember.IsReadPublic%2A> and <xref:System.Xaml.XamlMember.IsWritePublic%2A>.</span></span>  
  
 <span data-ttu-id="f3d1b-147">Le proprietà specifiche possono abilitare una sintassi del testo applicando <xref:System.ComponentModel.TypeConverterAttribute>.</span><span class="sxs-lookup"><span data-stu-id="f3d1b-147">Specific properties can enable a text syntax by applying <xref:System.ComponentModel.TypeConverterAttribute>.</span></span> <span data-ttu-id="f3d1b-148">Per ulteriori informazioni, vedere [convertitori di tipi ed estensioni di Markup per XAML](../../../docs/framework/xaml-services/type-converters-and-markup-extensions-for-xaml.md).</span><span class="sxs-lookup"><span data-stu-id="f3d1b-148">For more information, see [Type Converters and Markup Extensions for XAML](../../../docs/framework/xaml-services/type-converters-and-markup-extensions-for-xaml.md).</span></span>  
  
 <span data-ttu-id="f3d1b-149">In assenza di una sintassi del testo o di conversione XAML nativa e in assenza di ulteriore riferimento indiretto, ad esempio un utilizzo dell'estensione di markup, il tipo di una proprietà (<xref:System.Xaml.XamlMember.TargetType%2A> sistema di tipi in XAML) deve essere in grado di restituire un'istanza a un writer di oggetti XAML considerando t tipo di destinazione come tipo CLR.</span><span class="sxs-lookup"><span data-stu-id="f3d1b-149">In the absence of a text syntax or native XAML conversion and in the absence of further indirection, such as a markup extension usage, the type of a property (<xref:System.Xaml.XamlMember.TargetType%2A> in the XAML type system) must be able to return an instance to a XAML object writer by treating the target type as a CLR type.</span></span>  
  
 <span data-ttu-id="f3d1b-150">Se l'utilizzo di XAML 2009, [estensione di Markup X:Reference](../../../docs/framework/xaml-services/x-reference-markup-extension.md) possono essere utilizzate per fornire i valori non vengono soddisfatte le considerazioni precedenti, tuttavia, che è più un problema di utilizzo di un problema di definizione del tipo di.</span><span class="sxs-lookup"><span data-stu-id="f3d1b-150">If using XAML 2009, [x:Reference Markup Extension](../../../docs/framework/xaml-services/x-reference-markup-extension.md) can be used to provide values if the previous considerations are not met; however, that is more of a usage issue than a type definition issue.</span></span>  
  
### <a name="events"></a><span data-ttu-id="f3d1b-151">Eventi</span><span class="sxs-lookup"><span data-stu-id="f3d1b-151">Events</span></span>  
 <span data-ttu-id="f3d1b-152">Se si definiscono gli eventi come un evento CLR pubblico, il sistema di tipi XAML può segnalare l'evento come un membro con <xref:System.Xaml.XamlMember.IsEvent%2A> come `true`.</span><span class="sxs-lookup"><span data-stu-id="f3d1b-152">If you define events as a public CLR event, the XAML type system can report the event as a member with <xref:System.Xaml.XamlMember.IsEvent%2A> as `true`.</span></span> <span data-ttu-id="f3d1b-153">Cablaggio i gestori eventi non è nell'ambito di funzioni di servizi XAML di .NET Framework. questo viene lasciato alle implementazioni e framework specifici.</span><span class="sxs-lookup"><span data-stu-id="f3d1b-153">Wiring the event handlers is not within the scope of .NET Framework XAML Services capabilities; this is left to specific frameworks and implementations.</span></span>  
  
### <a name="methods"></a><span data-ttu-id="f3d1b-154">Metodi</span><span class="sxs-lookup"><span data-stu-id="f3d1b-154">Methods</span></span>  
 <span data-ttu-id="f3d1b-155">Il codice inline per i metodi non è una funzionalità XAML predefinito.</span><span class="sxs-lookup"><span data-stu-id="f3d1b-155">Inline code for methods is not a default XAML capability.</span></span> <span data-ttu-id="f3d1b-156">Nella maggior parte dei casi si non direttamente riferimento metodo membri da XAML e il ruolo di metodi in XAML è solo per fornire supporto per modelli XAML specifici.</span><span class="sxs-lookup"><span data-stu-id="f3d1b-156">In most cases you do not directly reference method members from XAML, and the role of methods in XAML is only to provide support for specific XAML patterns.</span></span> <span data-ttu-id="f3d1b-157">[Direttiva X:FactoryMethod](../../../docs/framework/xaml-services/x-factorymethod-directive.md) è un'eccezione.</span><span class="sxs-lookup"><span data-stu-id="f3d1b-157">[x:FactoryMethod Directive](../../../docs/framework/xaml-services/x-factorymethod-directive.md) is an exception.</span></span>  
  
### <a name="fields"></a><span data-ttu-id="f3d1b-158">Campi</span><span class="sxs-lookup"><span data-stu-id="f3d1b-158">Fields</span></span>  
 <span data-ttu-id="f3d1b-159">Linee guida di progettazione CLR scoraggiano campi non statici.</span><span class="sxs-lookup"><span data-stu-id="f3d1b-159">CLR design guidelines discourage nonstatic fields.</span></span> <span data-ttu-id="f3d1b-160">Per i campi statici, è possibile accedere a valori di campo statico solo tramite [estensione di Markup X:Static](../../../docs/framework/xaml-services/x-static-markup-extension.md); in questo caso non si sta eseguendo nulla nella definizione di CLR per esporre un campo per [X:Static](../../../docs/framework/xaml-services/x-static-markup-extension.md) utilizzi.</span><span class="sxs-lookup"><span data-stu-id="f3d1b-160">For static fields, you can access static field values only through [x:Static Markup Extension](../../../docs/framework/xaml-services/x-static-markup-extension.md); in this case you are not doing anything special in the CLR definition to expose a field for [x:Static](../../../docs/framework/xaml-services/x-static-markup-extension.md) usages.</span></span>  
  
## <a name="attachable-members"></a><span data-ttu-id="f3d1b-161">Membri associabili</span><span class="sxs-lookup"><span data-stu-id="f3d1b-161">Attachable Members</span></span>  
 <span data-ttu-id="f3d1b-162">I membri associabili sono esposte in XAML tramite un modello di metodo di funzione di accesso su un tipo di definizione.</span><span class="sxs-lookup"><span data-stu-id="f3d1b-162">Attachable members are exposed to XAML through an accessor method pattern on a defining type.</span></span> <span data-ttu-id="f3d1b-163">Il tipo di definizione non è necessario essere utilizzabile per XAML come un oggetto.</span><span class="sxs-lookup"><span data-stu-id="f3d1b-163">The defining type itself does not need to be XAML-usable as an object.</span></span> <span data-ttu-id="f3d1b-164">È in effetti un modello comune per dichiarare una classe del servizio il cui ruolo è proprietario membro associabile e implementare i comportamenti correlati, ma non servono alcuna altra funzione, ad esempio una rappresentazione dell'interfaccia utente.</span><span class="sxs-lookup"><span data-stu-id="f3d1b-164">In fact, a common pattern is to declare a service class whose role is to own the attachable member and implement the related behaviors, but serve no other function such as a UI representation.</span></span> <span data-ttu-id="f3d1b-165">Per le sezioni seguenti, il segnaposto *PropertyName* rappresenta il nome del membro associabile.</span><span class="sxs-lookup"><span data-stu-id="f3d1b-165">For the following sections, the placeholder *PropertyName* represents the name of your attachable member.</span></span> <span data-ttu-id="f3d1b-166">Tale nome deve essere valido nella [grammatica XamlName](../../../docs/framework/xaml-services/xamlname-grammar.md).</span><span class="sxs-lookup"><span data-stu-id="f3d1b-166">That name must be valid in the [XamlName Grammar](../../../docs/framework/xaml-services/xamlname-grammar.md).</span></span>  
  
 <span data-ttu-id="f3d1b-167">Prestare attenzione a conflitti di nome tra questi modelli e altri metodi di un tipo.</span><span class="sxs-lookup"><span data-stu-id="f3d1b-167">Be cautious of name collisions between these patterns and other methods of a type.</span></span> <span data-ttu-id="f3d1b-168">Se esiste un membro che corrisponde a uno dei modelli, questo può essere interpretato come un percorso di utilizzo del membro associabile da un processore XAML anche se non era l'intenzione.</span><span class="sxs-lookup"><span data-stu-id="f3d1b-168">If a member exists that matches one of the patterns, it can be interpreted as an attachable member usage pathway by a XAML processor even if that was not your intention.</span></span>  
  
#### <a name="the-getpropertyname-accessor"></a><span data-ttu-id="f3d1b-169">Funzione di accesso GetPropertyName</span><span class="sxs-lookup"><span data-stu-id="f3d1b-169">The GetPropertyName Accessor</span></span>  
 <span data-ttu-id="f3d1b-170">La firma per la funzione di accesso `Get`*NomeProprietà* deve essere:</span><span class="sxs-lookup"><span data-stu-id="f3d1b-170">The signature for the `Get`*PropertyName* accessor must be:</span></span>  
  
 <span data-ttu-id="f3d1b-171">`public static object Get` *PropertyName* `(object` `target` `)`</span><span class="sxs-lookup"><span data-stu-id="f3d1b-171">`public static object Get` *PropertyName* `(object`  `target` `)`</span></span>  
  
-   <span data-ttu-id="f3d1b-172">L'oggetto `target` può essere specificato come tipo più specifico nell'implementazione.</span><span class="sxs-lookup"><span data-stu-id="f3d1b-172">The `target` object can be specified as a more specific type in your implementation.</span></span> <span data-ttu-id="f3d1b-173">Ciò consente di definire l'ambito di utilizzo del membro associabile; gli utilizzi all'esterno dell'ambito previsto genereranno eccezioni di cast non valido che vengono quindi replicate da un errore di analisi XAML.</span><span class="sxs-lookup"><span data-stu-id="f3d1b-173">You can use this to scope the usage of your attachable member; usages outside your intended scope will throw invalid cast exceptions that are then surfaced by a XAML parse error.</span></span> <span data-ttu-id="f3d1b-174">Il nome del parametro `target` non è un requisito, ma è denominato `target` per convenzione nella maggior parte delle implementazioni.</span><span class="sxs-lookup"><span data-stu-id="f3d1b-174">The parameter name `target` is not a requirement, but is named `target` by convention in most implementations.</span></span>  
  
-   <span data-ttu-id="f3d1b-175">Il valore restituito può essere specificato come tipo più specifico nell'implementazione.</span><span class="sxs-lookup"><span data-stu-id="f3d1b-175">The return value can be specified as a more specific type in your implementation.</span></span>  
  
 <span data-ttu-id="f3d1b-176">Per supportare un <xref:System.ComponentModel.TypeConverter> sintassi del testo abilitata per l'utilizzo dell'attributo del membro associabile, applicare <xref:System.ComponentModel.TypeConverterAttribute> per il `Get` *PropertyName* della funzione di accesso.</span><span class="sxs-lookup"><span data-stu-id="f3d1b-176">To support a <xref:System.ComponentModel.TypeConverter> enabled text syntax for attribute usage of the attachable member, apply <xref:System.ComponentModel.TypeConverterAttribute> to the `Get`*PropertyName* accessor.</span></span> <span data-ttu-id="f3d1b-177">L'applicazione per il `get` anziché il `set` può sembrare non intuitiva; tuttavia, questa convenzione può supportare il concetto di sola lettura e i membri associabili serializzabili, che è utile negli scenari di progettazione.</span><span class="sxs-lookup"><span data-stu-id="f3d1b-177">Applying to the `get` instead of the `set` may seem nonintuitive; however, this convention can support the concept of read-only attachable members that are serializable, which is useful in designer scenarios.</span></span>  
  
#### <a name="the-setpropertyname-accessor"></a><span data-ttu-id="f3d1b-178">La funzione di accesso SetPropertyName</span><span class="sxs-lookup"><span data-stu-id="f3d1b-178">The SetPropertyName Accessor</span></span>  
 <span data-ttu-id="f3d1b-179">La firma per il Set di*PropertyName* della funzione di accesso deve essere:</span><span class="sxs-lookup"><span data-stu-id="f3d1b-179">The signature for the Set*PropertyName* accessor must be:</span></span>  
  
 <span data-ttu-id="f3d1b-180">`public static void Set` *NomeProprietà* `(object` `target` `, object` `value` `)`</span><span class="sxs-lookup"><span data-stu-id="f3d1b-180">`public static void Set` *PropertyName* `(object`  `target` `, object`  `value` `)`</span></span>  
  
-   <span data-ttu-id="f3d1b-181">Il `target` oggetto può essere specificato come un tipo più specifico nell'implementazione, con la stessa logica e conseguenze come descritto nella sezione precedente.</span><span class="sxs-lookup"><span data-stu-id="f3d1b-181">The `target` object can be specified as a more specific type in your implementation, with same logic and consequences as described in the previous section.</span></span>  
  
-   <span data-ttu-id="f3d1b-182">L'oggetto `value` può essere specificato come tipo più specifico nell'implementazione.</span><span class="sxs-lookup"><span data-stu-id="f3d1b-182">The `value` object can be specified as a more specific type in your implementation.</span></span>  
  
 <span data-ttu-id="f3d1b-183">Tenere presente che il valore di questo metodo è l'input proveniente dall'utilizzo in XAML, in genere in forma di attributo.</span><span class="sxs-lookup"><span data-stu-id="f3d1b-183">Remember that the value for this method is the input coming from the XAML usage, typically in attribute form.</span></span> <span data-ttu-id="f3d1b-184">Da una forma di attributo deve essere supporto del convertitore di tipi di valore per una sintassi del testo e attributo di `Get` *PropertyName* della funzione di accesso.</span><span class="sxs-lookup"><span data-stu-id="f3d1b-184">From attribute form there must be value converter support for a text syntax, and you attribute on the `Get`*PropertyName* accessor.</span></span>  
  
### <a name="attachable-member-stores"></a><span data-ttu-id="f3d1b-185">Archivi dei membri associabili</span><span class="sxs-lookup"><span data-stu-id="f3d1b-185">Attachable Member Stores</span></span>  
 <span data-ttu-id="f3d1b-186">I metodi della funzione di accesso non sono in genere sufficiente per fornire un modo per inserire i valori del membro associabile in un oggetto grafico, o per recuperare i valori non compresi nell'oggetto grafico e serializzarli nel modo appropriato.</span><span class="sxs-lookup"><span data-stu-id="f3d1b-186">The accessor methods are typically not enough to provide a means to place attachable member values into an object graph, or to retrieve values out of the object graph and serialize them properly.</span></span> <span data-ttu-id="f3d1b-187">Per fornire questa funzionalità, il `target` gli oggetti nelle firme della funzione di accesso precedente devono essere in grado di archiviare i valori.</span><span class="sxs-lookup"><span data-stu-id="f3d1b-187">To provide this functionality, the `target` objects in the previous accessor signatures must be capable of storing values.</span></span> <span data-ttu-id="f3d1b-188">Il meccanismo di archiviazione deve essere coerenza con il principio del membro associabile che il membro è associabile a destinazioni in cui il membro associabile non è nell'elenco dei membri.</span><span class="sxs-lookup"><span data-stu-id="f3d1b-188">The storage mechanism should be consistent with the attachable member principle that the member is attachable to targets where the attachable member is not in the members list.</span></span> <span data-ttu-id="f3d1b-189">Servizi XAML di .NET framework fornisce una tecnica di implementazione per il membro collegabile archivia tramite le API <xref:System.Xaml.IAttachedPropertyStore> e <xref:System.Xaml.AttachablePropertyServices>.</span><span class="sxs-lookup"><span data-stu-id="f3d1b-189">.NET Framework XAML Services provides an implementation technique for attachable member stores through the APIs <xref:System.Xaml.IAttachedPropertyStore> and <xref:System.Xaml.AttachablePropertyServices>.</span></span> <span data-ttu-id="f3d1b-190"><xref:System.Xaml.IAttachedPropertyStore>viene utilizzato dai writer XAML per individuare l'implementazione dell'archivio e deve essere implementata nel tipo che è la `target` delle funzioni di accesso.</span><span class="sxs-lookup"><span data-stu-id="f3d1b-190"><xref:System.Xaml.IAttachedPropertyStore> is used by the XAML writers to discover the store implementation, and should be implemented on the type that is the `target` of the accessors.</span></span> <span data-ttu-id="f3d1b-191">Il metodo statico <xref:System.Xaml.AttachablePropertyServices> API vengono utilizzate all'interno del corpo delle funzioni di accesso e fare riferimento al membro associabile dal relativo <xref:System.Xaml.AttachableMemberIdentifier>.</span><span class="sxs-lookup"><span data-stu-id="f3d1b-191">The static <xref:System.Xaml.AttachablePropertyServices> APIs are used within the body of the accessors, and refer to the attachable member by its <xref:System.Xaml.AttachableMemberIdentifier>.</span></span>  
  
## <a name="xaml-related-clr-attributes"></a><span data-ttu-id="f3d1b-192">Attributi CLR correlati a XAML</span><span class="sxs-lookup"><span data-stu-id="f3d1b-192">XAML-Related CLR Attributes</span></span>  
 <span data-ttu-id="f3d1b-193">Assegnazione di attributi correttamente i tipi, membri e gli assembly è importante ai report di informazioni sul sistema di tipi XAML ai servizi XAML di .NET Framework.</span><span class="sxs-lookup"><span data-stu-id="f3d1b-193">Correctly attributing your types, members, and assemblies is important in order to report XAML type system information to .NET Framework XAML Services.</span></span> <span data-ttu-id="f3d1b-194">È rilevante se si prevede di utilizzare con i sistemi XAML direttamente basate su XAML dei servizi XAML di .NET Framework reader e writer XAML i tipi, o se si definiscono o utilizza un framework che utilizzano XAML basato su tali reader XAML e writer XAML.</span><span class="sxs-lookup"><span data-stu-id="f3d1b-194">This is relevant if you intend your types for use with XAML systems that are directly based on .NET Framework XAML Services XAML readers and XAML writers, or if you define or use a XAML-utilizing framework that is based on those XAML readers and XAML writers.</span></span>  
  
 <span data-ttu-id="f3d1b-195">Per un elenco di ogni attributo correlati a XAML che sono rilevante per il supporto XAML dei tipi personalizzati, vedere [Related di attributi CLR per tipi personalizzati e le librerie](../../../docs/framework/xaml-services/xaml-related-clr-attributes-for-custom-types-and-libraries.md).</span><span class="sxs-lookup"><span data-stu-id="f3d1b-195">For a listing of each XAML-related attribute that is relevant for XAML support of your custom types, see [XAML-Related CLR Attributes for Custom Types and Libraries](../../../docs/framework/xaml-services/xaml-related-clr-attributes-for-custom-types-and-libraries.md).</span></span>  
  
## <a name="usage"></a><span data-ttu-id="f3d1b-196">Utilizzo</span><span class="sxs-lookup"><span data-stu-id="f3d1b-196">Usage</span></span>  
 <span data-ttu-id="f3d1b-197">Utilizzo di tipi personalizzati è necessario che l'autore del markup deve eseguire il mapping di un prefisso per l'assembly e spazio dei nomi CLR che contengono il tipo personalizzato.</span><span class="sxs-lookup"><span data-stu-id="f3d1b-197">Usage of custom types requires that the markup author must map a prefix for the assembly and CLR namespace that contain the custom type.</span></span> <span data-ttu-id="f3d1b-198">Questa procedura non è documentata in questo argomento.</span><span class="sxs-lookup"><span data-stu-id="f3d1b-198">This procedure is not documented in this topic.</span></span>  
  
## <a name="access-level"></a><span data-ttu-id="f3d1b-199">Livello di accesso</span><span class="sxs-lookup"><span data-stu-id="f3d1b-199">Access Level</span></span>  
 <span data-ttu-id="f3d1b-200">XAML consente di caricare e creare istanze di tipi che dispongono di un `internal` livello di accesso.</span><span class="sxs-lookup"><span data-stu-id="f3d1b-200">XAML provides a means to load and instantiate types that have an `internal` access level.</span></span> <span data-ttu-id="f3d1b-201">Questa funzionalità viene fornita in modo che il codice utente possa definire tipi personalizzati e quindi creare un'istanza di tali classi dal codice che fa anche parte dello stesso ambito di codice utente.</span><span class="sxs-lookup"><span data-stu-id="f3d1b-201">This capability is provided so that user code can define its own types, and then instantiate those classes from markup that is also part of the same user code scope.</span></span>  
  
 <span data-ttu-id="f3d1b-202">Un esempio di WPF è ogni volta che il codice utente definisce un <xref:System.Windows.Controls.UserControl> inteso come un modo per effettuare il refactoring di un comportamento dell'interfaccia utente, ma non come parte di qualsiasi possibile meccanismo di estensione che potrebbe essere implicito dichiarando la classe di supporto con `public` livello di accesso.</span><span class="sxs-lookup"><span data-stu-id="f3d1b-202">An example from WPF is whenever user code defines a <xref:System.Windows.Controls.UserControl> that is intended as a way to refactor a UI behavior, but not as part of any possible extension mechanism that might be implied by declaring the supporting class with `public` access level.</span></span> <span data-ttu-id="f3d1b-203">Questo tipo un <xref:System.Windows.Controls.UserControl> può essere dichiarato con `internal` accedere se il codice sottostante viene compilato nello stesso assembly da cui viene fatto riferimento come un tipo XAML.</span><span class="sxs-lookup"><span data-stu-id="f3d1b-203">Such a <xref:System.Windows.Controls.UserControl> can be declared with `internal` access if the backing code is compiled into the same assembly from which it is referenced as a XAML type.</span></span>  
  
 <span data-ttu-id="f3d1b-204">Per un'applicazione che carica XAML con l'attendibilità totale e lo usa <xref:System.Xaml.XamlObjectWriter>, il caricamento delle classi con `internal` livello di accesso è sempre abilitato.</span><span class="sxs-lookup"><span data-stu-id="f3d1b-204">For an application that loads XAML under full trust and uses <xref:System.Xaml.XamlObjectWriter>, loading classes with `internal` access level is always enabled.</span></span>  
  
 <span data-ttu-id="f3d1b-205">Per un'applicazione che carica XAML con attendibilità parziale, è possibile controllare le caratteristiche di livello di accesso tramite il <xref:System.Xaml.Permissions.XamlAccessLevel> API.</span><span class="sxs-lookup"><span data-stu-id="f3d1b-205">For an application that loads XAML under partial trust, you can control the access level characteristics by using the <xref:System.Xaml.Permissions.XamlAccessLevel> API.</span></span> <span data-ttu-id="f3d1b-206">Inoltre, devono essere in grado di propagare le autorizzazioni a livello di accesso e conservarle per le valutazioni della fase di esecuzione finale; i meccanismi di rinvio (ad esempio, il sistema di modelli WPF) Questa operazione viene gestita internamente passando il <xref:System.Xaml.Permissions.XamlAccessLevel> informazioni.</span><span class="sxs-lookup"><span data-stu-id="f3d1b-206">Also, deferral mechanisms (such as the WPF template system) must be able to propagate any access level permissions and preserve them for the eventual run time evaluations; this is handled internally by passing the <xref:System.Xaml.Permissions.XamlAccessLevel> information.</span></span>  
  
### <a name="wpf-implementation"></a><span data-ttu-id="f3d1b-207">Implementazione di WPF</span><span class="sxs-lookup"><span data-stu-id="f3d1b-207">WPF Implementation</span></span>  
 <span data-ttu-id="f3d1b-208">XAML WPF viene utilizzato un modello di accesso parzialmente attendibile in cui se BAML viene caricato con attendibilità parziale, l'accesso è limitato a <xref:System.Xaml.Permissions.XamlAccessLevel.AssemblyAccessTo%2A> per l'assembly che rappresenta l'origine BAML.</span><span class="sxs-lookup"><span data-stu-id="f3d1b-208">WPF XAML uses a partial-trust access model where if BAML is loaded under partial trust, access is restricted to <xref:System.Xaml.Permissions.XamlAccessLevel.AssemblyAccessTo%2A> for the assembly that is the BAML source.</span></span> <span data-ttu-id="f3d1b-209">Per rinvio, in WPF viene usato <xref:System.Xaml.IXamlObjectWriterFactory.GetParentSettings%2A?displayProperty=nameWithType> come un meccanismo per passare le informazioni sul livello di accesso.</span><span class="sxs-lookup"><span data-stu-id="f3d1b-209">For deferral, WPF uses <xref:System.Xaml.IXamlObjectWriterFactory.GetParentSettings%2A?displayProperty=nameWithType> as a mechanism for passing the access level information.</span></span>  
  
 <span data-ttu-id="f3d1b-210">Nella terminologia di XAML di WPF, un *tipo interno* è un tipo definito dall'assembly stesso che include il codice XAML di riferimento.</span><span class="sxs-lookup"><span data-stu-id="f3d1b-210">In WPF XAML terminology, an *internal type* is a type that is defined by the same assembly that also includes the referencing XAML.</span></span> <span data-ttu-id="f3d1b-211">Tale tipo può essere mappato tramite uno spazio dei nomi XAML viene deliberatamente omesso assembly = parte di un mapping, ad esempio, `xmlns:local="clr-namespace:WPFApplication1"`.</span><span class="sxs-lookup"><span data-stu-id="f3d1b-211">Such a type can be mapped through a XAML namespace that deliberately omits the assembly= portion of a mapping, for example, `xmlns:local="clr-namespace:WPFApplication1"`.</span></span>  <span data-ttu-id="f3d1b-212">Se BAML fa riferimento a un tipo interno e che disponga di tipo `internal` , livello di accesso verrà generato un `GeneratedInternalTypeHelper` classe per l'assembly.</span><span class="sxs-lookup"><span data-stu-id="f3d1b-212">If BAML references an internal type and that type has `internal` access level, this generates a `GeneratedInternalTypeHelper` class for the assembly.</span></span> <span data-ttu-id="f3d1b-213">Se si desidera evitare `GeneratedInternalTypeHelper`, è necessario utilizzare `public` , livello di accesso necessario scomporre la classe rilevante in un assembly separato e rendere tale assembly dipendente.</span><span class="sxs-lookup"><span data-stu-id="f3d1b-213">If you want to avoid `GeneratedInternalTypeHelper`, you either must use `public` access level, or must factor the relevant class into a separate assembly and make that assembly dependent.</span></span>  
  
## <a name="see-also"></a><span data-ttu-id="f3d1b-214">Vedere anche</span><span class="sxs-lookup"><span data-stu-id="f3d1b-214">See Also</span></span>  
 [<span data-ttu-id="f3d1b-215">Attributi CLR correlati a XAML per tipi e librerie personalizzati</span><span class="sxs-lookup"><span data-stu-id="f3d1b-215">XAML-Related CLR Attributes for Custom Types and Libraries</span></span>](../../../docs/framework/xaml-services/xaml-related-clr-attributes-for-custom-types-and-libraries.md)  
 [<span data-ttu-id="f3d1b-216">Servizi XAML</span><span class="sxs-lookup"><span data-stu-id="f3d1b-216">XAML Services</span></span>](../../../docs/framework/xaml-services/index.md)
