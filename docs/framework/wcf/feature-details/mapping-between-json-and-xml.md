---
title: Mapping tra JSON e XML
ms.date: 03/30/2017
ms.assetid: 22ee1f52-c708-4024-bbf0-572e0dae64af
ms.openlocfilehash: db34161ad3e2f7d2c9737e6a456b27bd70c5ebfb
ms.sourcegitcommit: 3d5d33f384eeba41b2dff79d096f47ccc8d8f03d
ms.translationtype: MT
ms.contentlocale: it-IT
ms.lasthandoff: 05/04/2018
ms.locfileid: "33496987"
---
# <a name="mapping-between-json-and-xml"></a><span data-ttu-id="e4738-102">Mapping tra JSON e XML</span><span class="sxs-lookup"><span data-stu-id="e4738-102">Mapping Between JSON and XML</span></span>
<span data-ttu-id="e4738-103">I lettori e i writer prodotti da <xref:System.Runtime.Serialization.Json.JsonReaderWriterFactory> forniscono una API XML sul contenuto JSON (JavaScript Object Notation).</span><span class="sxs-lookup"><span data-stu-id="e4738-103">The readers and writers produced by the <xref:System.Runtime.Serialization.Json.JsonReaderWriterFactory> provide an XML API over JavaScript Object Notation (JSON) content.</span></span> <span data-ttu-id="e4738-104">JSON codifica i dati utilizzando un sottoinsieme dei valori letterali di oggetto di JavaScript.</span><span class="sxs-lookup"><span data-stu-id="e4738-104">JSON encodes data using a subset of the object literals of JavaScript.</span></span> <span data-ttu-id="e4738-105">I lettori e i writer prodotti da questa factory vengono inoltre utilizzati per contenuto JSON viene inviato o ricevuto da applicazioni di Windows Communication Foundation (WCF) mediante il <xref:System.ServiceModel.Channels.WebMessageEncodingBindingElement> o il <xref:System.ServiceModel.WebHttpBinding>.</span><span class="sxs-lookup"><span data-stu-id="e4738-105">The readers and writers produced by this factory are also used when JSON content is being sent or received by Windows Communication Foundation (WCF) applications using the <xref:System.ServiceModel.Channels.WebMessageEncodingBindingElement> or the <xref:System.ServiceModel.WebHttpBinding>.</span></span>  
  
 <span data-ttu-id="e4738-106">In caso di inizializzazione con contenuto JSON, il lettore JSON si comporta nello stesso modo di un lettore XML testuale su un'istanza di XML.</span><span class="sxs-lookup"><span data-stu-id="e4738-106">When initialized with JSON content, the JSON reader behaves in the same way that a textual XML reader does over an instance of XML.</span></span> <span data-ttu-id="e4738-107">Il writer JSON, in presenza di una sequenza di chiamate prodotte da una certa istanza XML su un lettore XML testuale, scrive il contenuto JSON.</span><span class="sxs-lookup"><span data-stu-id="e4738-107">The JSON writer, when given a sequence of calls that on a textual XML reader produces a certain XML instance, writes out JSON content.</span></span> <span data-ttu-id="e4738-108">In questo argomento viene illustrato il mapping tra questa istanza di XML e il contenuto JSON, per l'utilizzo in scenari avanzati.</span><span class="sxs-lookup"><span data-stu-id="e4738-108">The mapping between this instance of XML and the JSON content is described in this topic for use in advanced scenarios.</span></span>  
  
 <span data-ttu-id="e4738-109">Internamente, JSON è rappresentato come un infoset XML quando vengono elaborate da WCF.</span><span class="sxs-lookup"><span data-stu-id="e4738-109">Internally, JSON is represented as an XML infoset when processed by WCF.</span></span> <span data-ttu-id="e4738-110">In genere non è necessario occuparsi di questa rappresentazione interna poiché il mapping è solo logico: JSON non viene normalmente convertito fisicamente in XML in memoria né in JSON da XML.</span><span class="sxs-lookup"><span data-stu-id="e4738-110">Normally you do not have to be concerned with this internal representation as the mapping is only a logical one: JSON is normally not physically converted to XML in memory or converted to JSON from XML.</span></span> <span data-ttu-id="e4738-111">Il mapping significa che le API XML sono utilizzate per accedere a contenuto JSON.</span><span class="sxs-lookup"><span data-stu-id="e4738-111">The mapping means that XML APIs are used to access JSON content.</span></span>  
  
 <span data-ttu-id="e4738-112">WCF Usa JSON, di norma è quello in cui il <xref:System.Runtime.Serialization.Json.DataContractJsonSerializer> viene automaticamente inserito dal <xref:System.ServiceModel.Description.WebScriptEnablingBehavior> comportamento, oppure il <xref:System.ServiceModel.Description.WebHttpBehavior> comportamento nei casi appropriati.</span><span class="sxs-lookup"><span data-stu-id="e4738-112">When WCF uses JSON, the usual scenario is that the <xref:System.Runtime.Serialization.Json.DataContractJsonSerializer> is automatically plugged in by the <xref:System.ServiceModel.Description.WebScriptEnablingBehavior> behavior, or by the <xref:System.ServiceModel.Description.WebHttpBehavior> behavior when appropriate.</span></span> <span data-ttu-id="e4738-113"><xref:System.Runtime.Serialization.Json.DataContractJsonSerializer> è in grado di comprendere il mapping tra JSON e l'infoset XML e si comporta come se stesse interagendo direttamente con JSON.</span><span class="sxs-lookup"><span data-stu-id="e4738-113">The <xref:System.Runtime.Serialization.Json.DataContractJsonSerializer> understands the mapping between JSON and the XML infoset and acts as if it is dealing with JSON directly.</span></span> <span data-ttu-id="e4738-114">È possibile utilizzare <xref:System.Runtime.Serialization.Json.DataContractJsonSerializer> con qualsiasi lettore o writer XML, a condizione che XML sia conforme al mapping seguente.</span><span class="sxs-lookup"><span data-stu-id="e4738-114">(It is possible to use the <xref:System.Runtime.Serialization.Json.DataContractJsonSerializer> with any XML reader or writer, with the understanding that the XML conforms to the following mapping.)</span></span>  
  
 <span data-ttu-id="e4738-115">Negli scenari avanzati, può rendersi necessario accedere direttamente al mapping seguente.</span><span class="sxs-lookup"><span data-stu-id="e4738-115">In advanced scenarios, it may become necessary to directly access the following mapping.</span></span> <span data-ttu-id="e4738-116">Questi scenari si verificano quando si desidera serializzare e deserializzare JSON in modalità personalizzate, senza basarsi su <xref:System.Runtime.Serialization.Json.DataContractJsonSerializer>o quando si interagisce direttamente con il tipo <xref:System.ServiceModel.Channels.Message> per messaggi che contengono JSON.</span><span class="sxs-lookup"><span data-stu-id="e4738-116">These scenarios occur when you want to serialize and deserialize JSON in custom ways, without relying on the <xref:System.Runtime.Serialization.Json.DataContractJsonSerializer>, or when dealing with the <xref:System.ServiceModel.Channels.Message> type directly for messages containing JSON.</span></span> <span data-ttu-id="e4738-117">Il mapping JSON-XML è utilizzato anche per la registrazione dei messaggi.</span><span class="sxs-lookup"><span data-stu-id="e4738-117">The JSON-XML mapping is also used for message logging.</span></span> <span data-ttu-id="e4738-118">Quando si utilizza la funzionalità di registrazione dei messaggi in WCF, i messaggi JSON vengono registrati come XML in base al mapping descritto nella sezione successiva.</span><span class="sxs-lookup"><span data-stu-id="e4738-118">When using the message logging feature in WCF, JSON messages is logged as XML according to the mapping described in the next section.</span></span>  
  
 <span data-ttu-id="e4738-119">Per chiarire il concetto di mapping, l'esempio seguente fa riferimento a un documento JSON.</span><span class="sxs-lookup"><span data-stu-id="e4738-119">To clarify the concept of a mapping, the following example is of a JSON document.</span></span>  
  
```json  
{"product":"pencil","price":12}  
```  
  
 <span data-ttu-id="e4738-120">Per leggere il documento JSON tramite uno dei lettori indicato in precedenza, utilizzare la stessa sequenza di chiamate a <xref:System.Xml.XmlDictionaryReader> utilizzata per leggere il documento XML seguente.</span><span class="sxs-lookup"><span data-stu-id="e4738-120">To read this JSON document using one of the readers previously mentioned, use the same sequence of <xref:System.Xml.XmlDictionaryReader> calls as you would to read the following XML document.</span></span>  
  
```xml  
<root type="object">  
    <product type="string">pencil</product>  
    <price type="number">12</price>  
</root>  
```  
  
 <span data-ttu-id="e4738-121">Inoltre, se il messaggio JSON nell'esempio viene ricevuto da WCF e registrato, vedrai il frammento XML nel log precedente.</span><span class="sxs-lookup"><span data-stu-id="e4738-121">Furthermore, if the JSON message in the example is received by WCF and logged, you would see the XML fragment in the preceding log.</span></span>  
  
## <a name="mapping-between-json-and-the-xml-infoset"></a><span data-ttu-id="e4738-122">Mapping tra JSON e l'InfoSet XML</span><span class="sxs-lookup"><span data-stu-id="e4738-122">Mapping Between JSON and the XML Infoset</span></span>  
 <span data-ttu-id="e4738-123">Formalmente, il mapping è tra JSON come descritto in [RFC 4627](http://go.microsoft.com/fwlink/?LinkId=98808) (tranne che con alcune limitazioni, flessibile e alcune altre restrizioni aggiunti) e il XML infoset (e non XML di testo) come descritto in [informazioni XML Impostare](http://go.microsoft.com/fwlink/?LinkId=98809) .</span><span class="sxs-lookup"><span data-stu-id="e4738-123">Formally, the mapping is between JSON as described in [RFC 4627](http://go.microsoft.com/fwlink/?LinkId=98808) (except with certain restrictions relaxed and certain other restrictions added) and the XML infoset (and not textual XML) as described in [XML Information Set](http://go.microsoft.com/fwlink/?LinkId=98809) .</span></span> <span data-ttu-id="e4738-124">Vedere l'argomento per le definizioni di *informazioni* e campi [tra parentesi quadre].</span><span class="sxs-lookup"><span data-stu-id="e4738-124">See this topic for the definitions of *information items* and fields in [square brackets].</span></span>  
  
 <span data-ttu-id="e4738-125">Un documento JSON vuoto esegue il mapping a un documento XML vuoto e un documento XML vuoto esegue il mapping a un documento JSON vuoto.</span><span class="sxs-lookup"><span data-stu-id="e4738-125">A blank JSON document maps to blank XML document, and a blank XML document maps to a blank JSON document.</span></span> <span data-ttu-id="e4738-126">Nel mapping da XML a JSON, non sono consentiti spazi vuoti all'inizio e alla fine del documento.</span><span class="sxs-lookup"><span data-stu-id="e4738-126">On the XML to JSON mapping, preceding whitespace and trailing whitespace after the document are not allowed.</span></span>  
  
 <span data-ttu-id="e4738-127">Il mapping viene definito tra un DII (Document Information Item) o un EII (Element Information Item) e JSON.</span><span class="sxs-lookup"><span data-stu-id="e4738-127">The mapping is defined between either a Document Information Item (DII) or an Element Information Item (EII) and JSON.</span></span> <span data-ttu-id="e4738-128">La proprietà [elemento del documento] di EII o DII, viene chiamata elemento JSON radice.</span><span class="sxs-lookup"><span data-stu-id="e4738-128">The EII, or the DII’s [document element] property, is referred to as the Root JSON Element.</span></span> <span data-ttu-id="e4738-129">Si noti che in questo mapping non sono supportati frammenti di documento (XML con più elementi radice).</span><span class="sxs-lookup"><span data-stu-id="e4738-129">Note that document fragments (XML with multiple root elements) are not supported in this mapping.</span></span>  
  
 <span data-ttu-id="e4738-130">Esempio: il documento seguente.</span><span class="sxs-lookup"><span data-stu-id="e4738-130">Example: The following document:</span></span>  
  
 `<?xml version="1.0"?>`  
  
 `<root type="number">42</root>`  
  
 <span data-ttu-id="e4738-131">E l'elemento seguente:</span><span class="sxs-lookup"><span data-stu-id="e4738-131">And the following element:</span></span>  
  
 `<root type="number">42</root>`  
  
 <span data-ttu-id="e4738-132">Entrambi hanno un mapping a JSON.</span><span class="sxs-lookup"><span data-stu-id="e4738-132">Both have a mapping to JSON.</span></span> <span data-ttu-id="e4738-133">Il <`root`> è l'elemento JSON radice in entrambi i casi.</span><span class="sxs-lookup"><span data-stu-id="e4738-133">The <`root`> element is the Root JSON Element in both cases.</span></span>  
  
 <span data-ttu-id="e4738-134">Nel caso di un DII, inoltre, è necessario prendere in considerazione gli elementi seguenti:</span><span class="sxs-lookup"><span data-stu-id="e4738-134">Furthermore, in the case of a DII, the following should be considered:</span></span>  
  
-   <span data-ttu-id="e4738-135">Alcuni elementi nell'elenco [figli] non devono essere presenti.</span><span class="sxs-lookup"><span data-stu-id="e4738-135">Some items in the [children] list must not be present.</span></span> <span data-ttu-id="e4738-136">Non fare affidamento su tale situazione in caso di lettura di XML mappato da JSON.</span><span class="sxs-lookup"><span data-stu-id="e4738-136">Do not rely on this fact when reading XML mapped from JSON.</span></span>  
  
-   <span data-ttu-id="e4738-137">L'elenco [figli] non contiene voci di informazioni di commento.</span><span class="sxs-lookup"><span data-stu-id="e4738-137">The [children] list holds no comment information items.</span></span>  
  
-   <span data-ttu-id="e4738-138">L'elenco [figli] non contiene voci di informazioni DTD.</span><span class="sxs-lookup"><span data-stu-id="e4738-138">The [children] list holds no DTD information items.</span></span>  
  
-   <span data-ttu-id="e4738-139">L'elenco [figli] non contiene alcun elemento di informazioni personali di informazioni (PI) (la \<? xml … > dichiarazione non è considerata una voce PI)</span><span class="sxs-lookup"><span data-stu-id="e4738-139">The [children] list holds no personal Information (PI) information items (the \<?xml…> declaration is not considered a PI information item)</span></span>  
  
-   <span data-ttu-id="e4738-140">Il set [notazioni] è vuoto.</span><span class="sxs-lookup"><span data-stu-id="e4738-140">The [notations] set is empty.</span></span>  
  
-   <span data-ttu-id="e4738-141">Il set [entità non analizzate] è vuoto.</span><span class="sxs-lookup"><span data-stu-id="e4738-141">The [unparsed entities] set is empty.</span></span>  
  
 <span data-ttu-id="e4738-142">Esempio: nel documento seguente non è contenuto alcun mapping a JSON perché [figli] contiene una PI e un commento.</span><span class="sxs-lookup"><span data-stu-id="e4738-142">Example: The following document has no mapping to JSON because [children] holds a PI and a comment.</span></span>  
  
 `<?xml version="1.0"?>`  
  
 `<!--comment--><?pi?>`  
  
 `<root type="number">42</root>`  
  
 <span data-ttu-id="e4738-143">L'EII per l'Elemento JSON radice ha le caratteristiche seguenti:</span><span class="sxs-lookup"><span data-stu-id="e4738-143">The EII for the Root JSON Element has the following characteristics:</span></span>  
  
-   <span data-ttu-id="e4738-144">[nome locale] ha il valore "root".</span><span class="sxs-lookup"><span data-stu-id="e4738-144">[local name] has the value "root".</span></span>  
  
-   <span data-ttu-id="e4738-145">[nome dello spazio dei nomi] non ha valore.</span><span class="sxs-lookup"><span data-stu-id="e4738-145">[namespace name] has no value.</span></span>  
  
-   <span data-ttu-id="e4738-146">[prefisso] non ha valore.</span><span class="sxs-lookup"><span data-stu-id="e4738-146">[prefix] has no value.</span></span>  
  
-   <span data-ttu-id="e4738-147">[figli] può contenere EII (che rappresentano elementi interni come descritto più avanti) o CII (Character Information Items come descritto più avanti) o nessuno dei due, ma non entrambi.</span><span class="sxs-lookup"><span data-stu-id="e4738-147">[children] may either contain EIIs (which represent Inner Elements as described further) or CIIs (Character Information Items as described further) or none of these, but not both.</span></span>  
  
-   <span data-ttu-id="e4738-148">[attributi] può contenere le voci di informazioni sugli attributi facoltativi seguenti (AII)</span><span class="sxs-lookup"><span data-stu-id="e4738-148">[attributes] may contain the following optional attribute information items (AIIs)</span></span>  
  
-   <span data-ttu-id="e4738-149">L'attributo di tipo JSON ("type") come descritto più avanti.</span><span class="sxs-lookup"><span data-stu-id="e4738-149">The JSON Type Attribute ("type") as described further.</span></span> <span data-ttu-id="e4738-150">Questo attributo è utilizzato per mantenere il tipo JSON (stringa, numero, booleano, oggetto, matrice o null) nell'XML di cui è stato eseguito il mapping.</span><span class="sxs-lookup"><span data-stu-id="e4738-150">This attribute is used to preserve the JSON type (string, number, boolean, object, array or null) in the mapped XML.</span></span>  
  
-   <span data-ttu-id="e4738-151">L'attributo del nome del contratto dati ("__type") come descritto più avanti.</span><span class="sxs-lookup"><span data-stu-id="e4738-151">The Data Contract Name Attribute ("__type") as described further.</span></span> <span data-ttu-id="e4738-152">Questo attributo può essere presente solo se è presente anche l'attributo del tipo JSON e il suo [valore normalizzato] è "object".</span><span class="sxs-lookup"><span data-stu-id="e4738-152">This attribute is can only be present if the JSON type attribute is also present and its [normalized value] is "object".</span></span> <span data-ttu-id="e4738-153">Questo attributo è utilizzato da `DataContractJsonSerializer` per mantenere informazioni sul tipo di contratto dati , ad esempio, nei casi polimorfici in cui viene serializzato un tipo derivato ed è previsto un tipo di base.</span><span class="sxs-lookup"><span data-stu-id="e4738-153">This attribute is used by the `DataContractJsonSerializer` to preserve data contract type information - for example, in polymorphic cases where a derived type is serialized and where a base type is expected.</span></span> <span data-ttu-id="e4738-154">Se non si utilizza `DataContractJsonSerializer`, nella maggior parte dei casi questo attributo viene ignorato.</span><span class="sxs-lookup"><span data-stu-id="e4738-154">If you are not working with the `DataContractJsonSerializer`, in most cases, this attribute is ignored.</span></span>  
  
-   <span data-ttu-id="e4738-155">[spazi dei nomi nell'ambito] contiene l'associazione di "xml" a "http://www.w3.org/XML/1998/namespace" come indicato dalla specifica infoset.</span><span class="sxs-lookup"><span data-stu-id="e4738-155">[in-scope namespaces] contains the binding of "xml" to "http://www.w3.org/XML/1998/namespace" as mandated by the infoset specification.</span></span>  
  
-   <span data-ttu-id="e4738-156">[figli], [attributi] e [spazi dei nomi nell'ambito] non devono avere altri elementi tranne quelli specificati in precedenza e [attributi dello spazio dei nomi] non deve avere membri, ma non fare affidamento su questa situazione in caso di lettura di XML mappato da JSON.</span><span class="sxs-lookup"><span data-stu-id="e4738-156">[children], [attributes] and [in-scope namespaces] must not have any items other than as specified previously and [namespace attributes] must have no members, but do not rely on these facts when reading XML mapped from JSON.</span></span>  
  
 <span data-ttu-id="e4738-157">Esempio: nel documento seguente non è presente alcun mapping a JSON perché [attributi dello spazio dei nomi] non è vuoto.</span><span class="sxs-lookup"><span data-stu-id="e4738-157">Example: The following document has no mapping to JSON because [namespace attributes] is not empty.</span></span>  
  
 `<?xml version="1.0"?>`  
  
 `<root  xmlns:a="myattributevalue">42</root>`  
  
 <span data-ttu-id="e4738-158">L'AII per l'attributo del tipo JSON ha le caratteristiche seguenti:</span><span class="sxs-lookup"><span data-stu-id="e4738-158">The AII for the JSON Type Attribute has the following characteristics:</span></span>  
  
-   <span data-ttu-id="e4738-159">[nome dello spazio dei nomi] non ha valore.</span><span class="sxs-lookup"><span data-stu-id="e4738-159">[namespace name] has no value.</span></span>  
  
-   <span data-ttu-id="e4738-160">[prefisso] non ha valore.</span><span class="sxs-lookup"><span data-stu-id="e4738-160">[prefix] has no value.</span></span>  
  
-   <span data-ttu-id="e4738-161">[nome locale] è "type".</span><span class="sxs-lookup"><span data-stu-id="e4738-161">[local name] is "type".</span></span>  
  
-   <span data-ttu-id="e4738-162">[valore normalizzato] è uno dei possibili valori del tipo descritto nella sezione seguente.</span><span class="sxs-lookup"><span data-stu-id="e4738-162">[normalized value] is one of the possible type values described in the following section.</span></span>  
  
-   <span data-ttu-id="e4738-163">[specificato] è `true`.</span><span class="sxs-lookup"><span data-stu-id="e4738-163">[specified] is `true`.</span></span>  
  
-   <span data-ttu-id="e4738-164">[tipo attributo] non ha valore.</span><span class="sxs-lookup"><span data-stu-id="e4738-164">[attribute type] has no value.</span></span>  
  
-   <span data-ttu-id="e4738-165">[riferimenti] non ha valore.</span><span class="sxs-lookup"><span data-stu-id="e4738-165">[references] has no value.</span></span>  
  
 <span data-ttu-id="e4738-166">L'AII per l'attributo del nome del contratto dati ha le caratteristiche seguenti:</span><span class="sxs-lookup"><span data-stu-id="e4738-166">The AII for the Data Contract Name Attribute has the following characteristics:</span></span>  
  
-   <span data-ttu-id="e4738-167">[nome dello spazio dei nomi] non ha valore.</span><span class="sxs-lookup"><span data-stu-id="e4738-167">[namespace name] has no value.</span></span>  
  
-   <span data-ttu-id="e4738-168">[prefisso] non ha valore.</span><span class="sxs-lookup"><span data-stu-id="e4738-168">[prefix] has no value.</span></span>  
  
-   <span data-ttu-id="e4738-169">[nome locale] è "__type (due trattini di sottolineatura seguiti da "type").</span><span class="sxs-lookup"><span data-stu-id="e4738-169">[local name] is "__type" (two underscores and then "type").</span></span>  
  
-   <span data-ttu-id="e4738-170">[valore normalizzato] è qualsiasi stringa Unicode valida, il mapping di questa stringa a JSON viene descritto nella sezione seguente.</span><span class="sxs-lookup"><span data-stu-id="e4738-170">[normalized value] is any valid Unicode string – the mapping of this string to JSON is described in the following section.</span></span>  
  
-   <span data-ttu-id="e4738-171">[specificato] è `true`.</span><span class="sxs-lookup"><span data-stu-id="e4738-171">[specified] is `true`.</span></span>  
  
-   <span data-ttu-id="e4738-172">[tipo attributo] non ha valore.</span><span class="sxs-lookup"><span data-stu-id="e4738-172">[attribute type] has no value.</span></span>  
  
-   <span data-ttu-id="e4738-173">[riferimenti] non ha valore.</span><span class="sxs-lookup"><span data-stu-id="e4738-173">[references] has no value.</span></span>  
  
 <span data-ttu-id="e4738-174">Gli elementi interni contenuti all'interno dell'Elemento JSON radice o altri elementi interni hanno le caratteristiche seguenti:</span><span class="sxs-lookup"><span data-stu-id="e4738-174">Inner elements contained within the Root JSON Element or other inner elements have the following characteristics:</span></span>  
  
-   <span data-ttu-id="e4738-175">[nome locale] può avere qualsiasi valore, come descritto più avanti</span><span class="sxs-lookup"><span data-stu-id="e4738-175">[local name] may have any value as described further</span></span>  
  
-   <span data-ttu-id="e4738-176">[nome dello spazio dei nomi], [prefisso], [figli], [attributi], [attributi dello spazio dei nomi] e [spazi dei nomi nell'ambito] sono soggetti alle stesse regole dell'Elemento JSON radice.</span><span class="sxs-lookup"><span data-stu-id="e4738-176">[namespace name], [prefix], [children], [attributes], [namespace attributes], and [in-scope namespaces] are subject to the same rules as the Root JSON Element.</span></span>  
  
 <span data-ttu-id="e4738-177">Sia nell'Elemento JSON radice che negli elementi interni, l'attributo del tipo JSON definisce il mapping a JSON, i [figli] possibili e la loro interpretazione.</span><span class="sxs-lookup"><span data-stu-id="e4738-177">In both the Root JSON Element and the inner elements, the JSON Type Attribute defines the mapping to JSON and the possible [children] and their interpretation.</span></span> <span data-ttu-id="e4738-178">Il [valore normalizzato] dell'attributo prevede la distinzione tra maiuscole e minuscole, deve essere in lettere minuscole e non può contenere spazio vuoto.</span><span class="sxs-lookup"><span data-stu-id="e4738-178">The attribute’s [normalized value] is case-sensitive and must be lowercase, and cannot contain whitespace.</span></span>  
  
|<span data-ttu-id="e4738-179">[valore normalizzato] dell'AII di `JSON Type Attribute`</span><span class="sxs-lookup"><span data-stu-id="e4738-179">[normalized value] of `JSON Type Attribute`’s AII</span></span>|<span data-ttu-id="e4738-180">[figli] consentiti dell'EII corrispondente</span><span class="sxs-lookup"><span data-stu-id="e4738-180">Allowed [children] of the corresponding EII</span></span>|<span data-ttu-id="e4738-181">Mapping a JSON</span><span class="sxs-lookup"><span data-stu-id="e4738-181">Mapping to JSON</span></span>|  
|---------------------------------------------------------|---------------------------------------------------|---------------------|  
|<span data-ttu-id="e4738-182">`string` (o assenza dell'AII del tipo JSON)</span><span class="sxs-lookup"><span data-stu-id="e4738-182">`string` (or absence of the JSON type AII)</span></span><br /><br /> <span data-ttu-id="e4738-183">Una `string` e l'assenza dell'AII del tipo JSON sono la stessa cosa e creano l'elemento predefinito `string`.</span><span class="sxs-lookup"><span data-stu-id="e4738-183">A `string` and the absence of the JSON type AII are the same makes `string` the default.</span></span><br /><br /> <span data-ttu-id="e4738-184">Pertanto, `<root> string1</root>``string` esegue il mapping alla  "string1" JSON.</span><span class="sxs-lookup"><span data-stu-id="e4738-184">So, `<root> string1</root>` maps to the JSON `string` "string1".</span></span>|<span data-ttu-id="e4738-185">0 o più Cii</span><span class="sxs-lookup"><span data-stu-id="e4738-185">0 or more CIIs</span></span>|<span data-ttu-id="e4738-186">Oggetto `string` JSON (JSON RFC, sezione 2.5).</span><span class="sxs-lookup"><span data-stu-id="e4738-186">A JSON `string` (JSON RFC, section 2.5).</span></span> <span data-ttu-id="e4738-187">Ogni `char` è un carattere che corrisponde al [character code] di CII.</span><span class="sxs-lookup"><span data-stu-id="e4738-187">Each `char` is a character that corresponds to the [character code] from the CII.</span></span> <span data-ttu-id="e4738-188">Se non sono presenti CII, esegue il mapping a una `string` JSON vuota.</span><span class="sxs-lookup"><span data-stu-id="e4738-188">If there are no CIIs, it maps to an empty JSON `string`.</span></span><br /><br /> <span data-ttu-id="e4738-189">Esempio: l'elemento seguente viene mappato a un frammento JSON:</span><span class="sxs-lookup"><span data-stu-id="e4738-189">Example: The following element maps to a JSON fragment:</span></span><br /><br /> `<root type="string">42</root>`<br /><br /> <span data-ttu-id="e4738-190">Il frammento JSON è "42".</span><span class="sxs-lookup"><span data-stu-id="e4738-190">The JSON fragment is "42".</span></span><br /><br /> <span data-ttu-id="e4738-191">Nel mapping da XML a JSON, i caratteri che devono essere preceduti dal carattere di escape vengono mappati ai caratteri di escape, tutti gli altri vengono mappati a caratteri non di escape.</span><span class="sxs-lookup"><span data-stu-id="e4738-191">On XML to JSON mapping, characters that must be escaped map to escaped characters, all others map to characters that are not escaped.</span></span> <span data-ttu-id="e4738-192">Il carattere "/" è speciale: viene sottoposta a escape anche se non deve essere (scritto come "\\/").</span><span class="sxs-lookup"><span data-stu-id="e4738-192">The "/" character is special – it is escaped even though it does not have to be (written out as "\\/").</span></span><br /><br /> <span data-ttu-id="e4738-193">Esempio: l'elemento seguente viene mappato a un frammento JSON.</span><span class="sxs-lookup"><span data-stu-id="e4738-193">Example: The following element maps to a JSON fragment.</span></span><br /><br /> `<root type="string">the "da/ta"</root>`<br /><br /> <span data-ttu-id="e4738-194">Il frammento JSON è "il \\" DirectAccess\\/ta\\"".</span><span class="sxs-lookup"><span data-stu-id="e4738-194">The JSON fragment is "the \\"da\\/ta\\"".</span></span><br /><br /> <span data-ttu-id="e4738-195">Nel mapping da JSON a XML, qualsiasi carattere preceduto o no da un carattere di escape viene mappato correttamente al [codice carattere] corrispondente.</span><span class="sxs-lookup"><span data-stu-id="e4738-195">On JSON to XML mapping, any escaped characters and characters that are not escaped map correctly to the corresponding [character code].</span></span><br /><br /> <span data-ttu-id="e4738-196">Esempio: il frammento JSON "\u0041BC" viene mappato all'elemento XML seguente.</span><span class="sxs-lookup"><span data-stu-id="e4738-196">Example: The JSON fragment "\u0041BC", maps to the following XML element.</span></span><br /><br /> `<root type="string">ABC</root>`<br /><br /> <span data-ttu-id="e4738-197">La stringa può essere racchiusa tra spazi vuoti ('ws' nella sezione 2 di JSON RFC) che non vengono mappati a XML.</span><span class="sxs-lookup"><span data-stu-id="e4738-197">The string can be surrounded by whitespace ('ws' in section 2 of the JSON RFC) that does not get mapped to XML.</span></span><br /><br /> <span data-ttu-id="e4738-198">Esempio: il frammento JSON            "ABC", (sono presenti spazi prima delle doppie virgolette di apertura) viene mappato all'elemento XML seguente.</span><span class="sxs-lookup"><span data-stu-id="e4738-198">Example: The JSON fragment           "ABC", (there are spaces before the first double quote), maps to the following XML element.</span></span><br /><br /> `<root type="string">ABC</root>`<br /><br /> <span data-ttu-id="e4738-199">Qualsiasi spazio vuoto in XML viene mappato a spazio vuoto in JSON.</span><span class="sxs-lookup"><span data-stu-id="e4738-199">Any whitespace in XML maps to whitespace in JSON.</span></span><br /><br /> <span data-ttu-id="e4738-200">Esempio: l'elemento XML seguente viene mappato a un frammento JSON.</span><span class="sxs-lookup"><span data-stu-id="e4738-200">Example: The following XML element maps to a JSON fragment.</span></span><br /><br /> `<root type="string">  A BC      </root>`<br /><br /> <span data-ttu-id="e4738-201">Il frammento JSON è " A BC ".</span><span class="sxs-lookup"><span data-stu-id="e4738-201">The JSON fragment is " A BC ".</span></span>|  
|`number`|<span data-ttu-id="e4738-202">1 o più CII</span><span class="sxs-lookup"><span data-stu-id="e4738-202">1 or more CIIs</span></span>|<span data-ttu-id="e4738-203">Un `number` JSON (JSON RFC, sezione 2.4), eventualmente racchiuso da spazio vuoto.</span><span class="sxs-lookup"><span data-stu-id="e4738-203">A JSON `number` (JSON RFC, section 2.4), possibly surrounded by whitespace.</span></span> <span data-ttu-id="e4738-204">Ogni carattere nella combinazione numero/spazio vuoto è un carattere che corrisponde al [codice carattere] da CII.</span><span class="sxs-lookup"><span data-stu-id="e4738-204">Each character in the number/whitespace combination is a character that corresponds to the [character code] from the CII.</span></span><br /><br /> <span data-ttu-id="e4738-205">Esempio: l'elemento seguente viene mappato a un frammento JSON.</span><span class="sxs-lookup"><span data-stu-id="e4738-205">Example: The following element maps to a JSON fragment.</span></span><br /><br /> `<root type="number">    42</root>`<br /><br /> <span data-ttu-id="e4738-206">Il frammento JSON è    42</span><span class="sxs-lookup"><span data-stu-id="e4738-206">The JSON fragment is    42</span></span><br /><br /> <span data-ttu-id="e4738-207">(Lo spazio vuoto viene mantenuto).</span><span class="sxs-lookup"><span data-stu-id="e4738-207">(Whitespace is preserved).</span></span>|  
|`boolean`|<span data-ttu-id="e4738-208">4 o 5 CII (il che corrisponde a `true` o `false`), possibilmente circondati da spazio vuoto aggiuntivo.</span><span class="sxs-lookup"><span data-stu-id="e4738-208">4 or 5 CIIs (which corresponds to `true` or `false`), possibly surrounded by additional whitespace CIIs.</span></span>|<span data-ttu-id="e4738-209">Una sequenza di CII che corrisponde alla stringa "true" viene mappata al valore letterale `true` e la sequenza di CII che corrisponde alla stringa "false" viene mappata al valore letterale `false`.</span><span class="sxs-lookup"><span data-stu-id="e4738-209">A CII sequence that corresponds to the string "true" is mapped to the literal `true`, and a CII sequence that corresponds to the string "false" is mapped to the literal `false`.</span></span> <span data-ttu-id="e4738-210">Lo spazio vuoto circostante viene mantenuto.</span><span class="sxs-lookup"><span data-stu-id="e4738-210">Surrounding whitespace is preserved.</span></span><br /><br /> <span data-ttu-id="e4738-211">Esempio: l'elemento seguente viene mappato a un frammento JSON.</span><span class="sxs-lookup"><span data-stu-id="e4738-211">Example: The following element maps to a JSON fragment.</span></span><br /><br /> `<root type="boolean"> false</root>`<br /><br /> <span data-ttu-id="e4738-212">Il frammento JSON è `false`.</span><span class="sxs-lookup"><span data-stu-id="e4738-212">The JSON fragment is `false`.</span></span>|  
|`null`|<span data-ttu-id="e4738-213">Nessuno consentito.</span><span class="sxs-lookup"><span data-stu-id="e4738-213">None allowed.</span></span>|<span data-ttu-id="e4738-214">Il valore letterale `null`.</span><span class="sxs-lookup"><span data-stu-id="e4738-214">The literal `null`.</span></span> <span data-ttu-id="e4738-215">Nel mapping da JSON a XML, `null` può essere racchiuso tra spazi vuoti ('ws' nella sezione 2) di cui non viene eseguito il mapping al codice XML.</span><span class="sxs-lookup"><span data-stu-id="e4738-215">On JSON to XML mapping, the `null` may be surrounded by whitespace (‘ws’ in section 2) that does not get mapped to XML.</span></span><br /><br /> <span data-ttu-id="e4738-216">Esempio: l'elemento seguente viene mappato a un frammento JSON.</span><span class="sxs-lookup"><span data-stu-id="e4738-216">Example: The following element maps to a JSON fragment.</span></span><br /><br /> `<root type="null"/>`<br /><br /> <span data-ttu-id="e4738-217">oppure</span><span class="sxs-lookup"><span data-stu-id="e4738-217">or</span></span><br /><br /> `<root type="null"></root>`<br /><br /> <span data-ttu-id="e4738-218">:</span><span class="sxs-lookup"><span data-stu-id="e4738-218">:</span></span><br /><br /> <span data-ttu-id="e4738-219">In entrambi i casi il frammento JSON è `Null`.</span><span class="sxs-lookup"><span data-stu-id="e4738-219">The JSON fragment in both cases is `Null`.</span></span>|  
|`object`|<span data-ttu-id="e4738-220">0 o più EII.</span><span class="sxs-lookup"><span data-stu-id="e4738-220">0 or more EIIs.</span></span>|<span data-ttu-id="e4738-221">`begin-object` (parentesi graffa aperta) come nella sezione 2.2 di JSON RFC, seguito da un record del membro per ogni EII come descritto più avanti.</span><span class="sxs-lookup"><span data-stu-id="e4738-221">A `begin-object` (left curly brace) as in section 2.2 of the JSON RFC, followed by a member record for each EII as described further.</span></span> <span data-ttu-id="e4738-222">Se esiste più di un EII, sono presenti separatori di valore (virgole) tra il record dei membri.</span><span class="sxs-lookup"><span data-stu-id="e4738-222">If there is more than one EII, there are value-separators (commas) between the member records.</span></span> <span data-ttu-id="e4738-223">Tutto è seguito da un fine oggetto (parentesi graffa chiusa).</span><span class="sxs-lookup"><span data-stu-id="e4738-223">All this is followed by an end-object (right curly brace).</span></span><br /><br /> <span data-ttu-id="e4738-224">Esempio: l'elemento seguente viene mappato al frammento JSON.</span><span class="sxs-lookup"><span data-stu-id="e4738-224">Example: The following element maps to the JSON fragment.</span></span><br /><br /> <span data-ttu-id="e4738-225">\<tipo radice = "oggetto" ></span><span class="sxs-lookup"><span data-stu-id="e4738-225">\<root type="object"></span></span><br /><br /> <span data-ttu-id="e4738-226">\<tipo type1 = "string" > aaa\</type1 ></span><span class="sxs-lookup"><span data-stu-id="e4738-226">\<type1 type="string">aaa\</type1></span></span><br /><br /> <span data-ttu-id="e4738-227">\<tipo type2 = "string" > bbb\</type2 ></span><span class="sxs-lookup"><span data-stu-id="e4738-227">\<type2 type="string">bbb\</type2></span></span><br /><br /> <span data-ttu-id="e4738-228">\</ root ></span><span class="sxs-lookup"><span data-stu-id="e4738-228">\</root ></span></span><br /><br /> <span data-ttu-id="e4738-229">Il frammento JSON è {"type1":"aaa","type2":"bbb"}.</span><span class="sxs-lookup"><span data-stu-id="e4738-229">The JSON fragment is {"type1":"aaa","type2":"bbb"}.</span></span><br /><br /> <span data-ttu-id="e4738-230">Se nel mapping da XML a JSON è presente l'attributo tipo di contratto dati, all'inizio viene inserito un record del membro aggiuntivo.</span><span class="sxs-lookup"><span data-stu-id="e4738-230">If the Data Contract Type Attribute is present on XML to JSON mapping, then an additional Member Record is inserted at the beginning.</span></span> <span data-ttu-id="e4738-231">Il suo nome è il [nome locale] dell'attributo tipo di contratto dati ("__type") e il suo valore è il [valore normalizzato] dell'attributo.</span><span class="sxs-lookup"><span data-stu-id="e4738-231">Its name is the [local name] of the Data Contract Type Attribute ("__type"), and its value is the attribute's [normalized value].</span></span> <span data-ttu-id="e4738-232">Viceversa, in JSON per il mapping di XML, se il primo membro-nome del record è il [nome locale] dell'attributo di tipo di contratto dati (vale a dire, "\_digi_ta"), un attributo di tipo di contratto dati corrispondente è presente nel codice XML mappato, ma non è un EII corrispondente presente.</span><span class="sxs-lookup"><span data-stu-id="e4738-232">Conversely, on JSON to XML mapping, if the first member-record’s name is the [local name] of the Data Contract Type Attribute (that is, "\__type"), a corresponding Data Contract Type Attribute is present in the mapped XML, but a corresponding EII is not present.</span></span> <span data-ttu-id="e4738-233">Si noti che, perché questo mapping speciale si applichi, il record del membro deve essere per primo nell'oggetto JSON.</span><span class="sxs-lookup"><span data-stu-id="e4738-233">Note that this member record must occur first in the JSON object for this special mapping to apply.</span></span> <span data-ttu-id="e4738-234">Ciò si discosta dall'elaborazione JSON abituale, in cui l'ordine dei record dei membri non è importante.</span><span class="sxs-lookup"><span data-stu-id="e4738-234">This represents a departure from usual JSON processing, where the order of member records is not significant.</span></span><br /><br /> <span data-ttu-id="e4738-235">Esempio:</span><span class="sxs-lookup"><span data-stu-id="e4738-235">Example:</span></span><br /><br /> <span data-ttu-id="e4738-236">il frammento JSON seguente viene mappato a XML.</span><span class="sxs-lookup"><span data-stu-id="e4738-236">The following JSON fragment maps to XML.</span></span><br /><br /> `{"__type":"Person","name":"John"}`<br /><br /> <span data-ttu-id="e4738-237">L'XML è il codice seguente.</span><span class="sxs-lookup"><span data-stu-id="e4738-237">The XML is the following code.</span></span><br /><br /> `<root type="object" __type="Person">   <name type="string">John</name> </root>`<br /><br /> <span data-ttu-id="e4738-238">Si noti che il \_Type AII è presente, ma non esiste alcun \_Type EII.</span><span class="sxs-lookup"><span data-stu-id="e4738-238">Notice that the \__type AII is present, but there is no \__type EII.</span></span><br /><br /> <span data-ttu-id="e4738-239">Se, tuttavia, l'ordine in JSON è invertito come illustrato nell'esempio seguente.</span><span class="sxs-lookup"><span data-stu-id="e4738-239">However, if the order in the JSON is reversed as shown in the following example.</span></span><br /><br /> <span data-ttu-id="e4738-240">{"name": "John","\_Type": "Person"}</span><span class="sxs-lookup"><span data-stu-id="e4738-240">{"name":"John","\__type":"Person"}</span></span><br /><br /> <span data-ttu-id="e4738-241">Viene illustrato l'XML corrispondente.</span><span class="sxs-lookup"><span data-stu-id="e4738-241">The corresponding XML is shown.</span></span><br /><br /> `<root type="object">   <name type="string">John</name>   <__type type="string">Person</__type> </root>`<br /><br /> <span data-ttu-id="e4738-242">Vale a dire \_Type cessa di avere un significato speciale e viene mappato a un EII come di consueto, non ad AII.</span><span class="sxs-lookup"><span data-stu-id="e4738-242">That is, \__type ceases to have special meaning and maps to an EII as usual, not AII.</span></span><br /><br /> <span data-ttu-id="e4738-243">Le regole sull'utilizzo o meno di caratteri di escape per il [valore normalizzato] di AII quando mappato a un valore JSON sono identiche a quelle per le stringhe JSON, come specificato nella riga "string" di questa tabella.</span><span class="sxs-lookup"><span data-stu-id="e4738-243">Escaping/unescaping rules for the AII’s [normalized value] when mapped to a JSON value are the same as for JSON strings, specified in the "string" row of this table.</span></span><br /><br /> <span data-ttu-id="e4738-244">Esempio:</span><span class="sxs-lookup"><span data-stu-id="e4738-244">Example:</span></span><br /><br /> `<root type="object" __type="\abc" />`<br /><br /> <span data-ttu-id="e4738-245">all'esempio precedente può essere mappato al JSON seguente.</span><span class="sxs-lookup"><span data-stu-id="e4738-245">to the previous example can be mapped to the following JSON.</span></span><br /><br /> `{"__type":"\\abc"}`<br /><br /> <span data-ttu-id="e4738-246">In un mapping da XML a JSON, non deve essere del primo EII [nome locale] "\_Type".</span><span class="sxs-lookup"><span data-stu-id="e4738-246">On an XML to JSON mapping, the first EII’s [local name] must not be "\__type".</span></span><br /><br /> <span data-ttu-id="e4738-247">Lo spazio vuoto (`ws`) non viene mai generato nel mapping da XML a JSON per gli oggetti e viene ignorato nel mapping da JSON a XML.</span><span class="sxs-lookup"><span data-stu-id="e4738-247">Whitespace (`ws`) is never generated on XML to JSON mapping for objects and is ignored on JSON to XML mapping.</span></span><br /><br /> <span data-ttu-id="e4738-248">Esempio: il frammento JASON seguente viene mappato a un elemento XML.</span><span class="sxs-lookup"><span data-stu-id="e4738-248">Example: The following JSON fragment maps to an XML element.</span></span><br /><br /> <span data-ttu-id="e4738-249">{   "ccc"   :  "aaa",   "ddd"    :"bbb"}</span><span class="sxs-lookup"><span data-stu-id="e4738-249">{   "ccc"   :  "aaa",   "ddd"    :"bbb"}</span></span><br /><br /> <span data-ttu-id="e4738-250">Nel codice seguente viene illustrato l'elemento XML.</span><span class="sxs-lookup"><span data-stu-id="e4738-250">The XML element is shown in the following code.</span></span><br /><br /> `<root type="object">    <ccc type="string">aaa</ccc>    <ddd type="string">bbb</bar> </root >`|  
<span data-ttu-id="e4738-251">raggio '</span><span class="sxs-lookup"><span data-stu-id="e4738-251">ray\`</span></span>|<span data-ttu-id="e4738-252">0 o più EII</span><span class="sxs-lookup"><span data-stu-id="e4738-252">0 or more EIIs</span></span>|<span data-ttu-id="e4738-253">Un inizio di matrice (parentesi quadra aperta) come nella sezione 2.3 di JSON RFC, seguita da un record della matrice per ogni EII come descritto più avanti.</span><span class="sxs-lookup"><span data-stu-id="e4738-253">A begin-array (left square bracket) as in section 2.3 of the JSON RFC, followed by an array record for each EII as described further.</span></span> <span data-ttu-id="e4738-254">Se esiste più di un EII, sono presenti separatori di valore (virgole) tra i record delle matrici.</span><span class="sxs-lookup"><span data-stu-id="e4738-254">If there is more than one EII, there are value-separators (commas) between the array records.</span></span> <span data-ttu-id="e4738-255">Il tutto, è seguito da un fine matrice.</span><span class="sxs-lookup"><span data-stu-id="e4738-255">All this is followed by an end-array.</span></span><br /><br /> <span data-ttu-id="e4738-256">Esempio: l'elemento XML seguente viene mappato a un frammento JSON.</span><span class="sxs-lookup"><span data-stu-id="e4738-256">Example: The following XML element maps to a JSON fragment.</span></span><br /><br /> `<root type="array"/>    <item type="string">aaa</item>    <item type="string">bbb</item> </root >`<br /><br /> <span data-ttu-id="e4738-257">Il frammento JSON è ["aaa","bbb"]</span><span class="sxs-lookup"><span data-stu-id="e4738-257">The JSON fragment is ["aaa","bbb"]</span></span><br /><br /> <span data-ttu-id="e4738-258">Lo spazio vuoto (`ws`) non viene mai generato nel mapping da XML a JSON per le matrici e viene ignorato nel mapping da JSON a XML.</span><span class="sxs-lookup"><span data-stu-id="e4738-258">Whitespace (`ws`) is never generated on XML to JSON mapping for arrays and is ignored on JSON to XML mapping.</span></span><br /><br /> <span data-ttu-id="e4738-259">Esempio: frammento di AJSON.</span><span class="sxs-lookup"><span data-stu-id="e4738-259">Example: AJSON fragment.</span></span><br /><br /> <span data-ttu-id="e4738-260">[     "aaa",     "bbb"]</span><span class="sxs-lookup"><span data-stu-id="e4738-260">[     "aaa",     "bbb"]</span></span><br /><br /> <span data-ttu-id="e4738-261">L'elemento XML su cui viene eseguito il mapping.</span><span class="sxs-lookup"><span data-stu-id="e4738-261">The XML element that it maps to.</span></span><br /><br /> `<root type="array"/>    <item type="string">aaa</item>    <item type="string">bbb</item> </root >`|  
  
 <span data-ttu-id="e4738-262">I record dei membri funzionano come segue:</span><span class="sxs-lookup"><span data-stu-id="e4738-262">Member Records work as follows:</span></span>  
  
-   <span data-ttu-id="e4738-263">Il [nome locale] dell'elemento interno viene mappato alla parte `string` di `member`, come definito nella sezione 2.2 di JSON RFC.</span><span class="sxs-lookup"><span data-stu-id="e4738-263">Inner element’s [local name] maps to the `string` part of the `member` as defined in section 2.2 of the JSON RFC.</span></span>  
  
 <span data-ttu-id="e4738-264">Esempio: l'elemento seguente viene mappato a un frammento JSON.</span><span class="sxs-lookup"><span data-stu-id="e4738-264">Example: The following element maps to a JSON fragment.</span></span>  
  
 `<root type="object"/>`  
  
 `<myLocalName type="string">aaa</myLocalName>`  
  
 `</root >`  
  
 <span data-ttu-id="e4738-265">Viene visualizzato il frammento JSON seguente.</span><span class="sxs-lookup"><span data-stu-id="e4738-265">The following JSON fragment is displayed.</span></span>  
  
 `{"myLocalName":"aaa"}`  
  
-   <span data-ttu-id="e4738-266">Nel mapping da XML a JSON, i caratteri che devono essere preceduti dal carattere di escape in JSON sono preceduti dal carattere di escape, gli altri no.</span><span class="sxs-lookup"><span data-stu-id="e4738-266">On the XML to JSON mapping, the characters that must be escaped in JSON are escaped, and the others are not escaped.</span></span> <span data-ttu-id="e4738-267">Il carattere "/",viene preceduto da un carattere di escape anche se ciò non è necessario (non richiede il carattere di escape nel mapping da JSON a XML).</span><span class="sxs-lookup"><span data-stu-id="e4738-267">The "/" character, even though it is not a character that must be escaped, is escaped nevertheless (it does not have to be escaped on JSON to XML mapping).</span></span> <span data-ttu-id="e4738-268">Ciò è necessario per supportare il formato ASP.NET AJAX per i dati `DateTime` in JSON.</span><span class="sxs-lookup"><span data-stu-id="e4738-268">This is required to support the ASP.NET AJAX format for `DateTime` data in JSON.</span></span>  
  
-   <span data-ttu-id="e4738-269">Nel mapping da JSON a XML, vengono presi tutti i caratteri (compresi quelli senza carattere di escape, se necessario) per formare una `string` che produce un [nome locale].</span><span class="sxs-lookup"><span data-stu-id="e4738-269">On the JSON to XML mapping, all characters (including the not escaped characters, if necessary) are taken to form a `string` that produces a [local name].</span></span>  
  
-   <span data-ttu-id="e4738-270">I [figli] dell'elemento interno vengono mappati al valore nella sezione 2.2, secondo `JSON Type Attribute` come per `Root JSON Element`.</span><span class="sxs-lookup"><span data-stu-id="e4738-270">Inner elements [children] map to the value in section 2.2, according to the `JSON Type Attribute` just like for the `Root JSON Element`.</span></span> <span data-ttu-id="e4738-271">Sono consentiti più livelli di annidamento di EII (incluso l'annidamento all'interno di matrici).</span><span class="sxs-lookup"><span data-stu-id="e4738-271">Multiple levels of nesting of EIIs (including nesting within arrays) are allowed.</span></span>  
  
 <span data-ttu-id="e4738-272">Esempio: l'elemento seguente viene mappato a un frammento JSON.</span><span class="sxs-lookup"><span data-stu-id="e4738-272">Example: The following element maps to a JSON fragment.</span></span>  
  
 `<root type="object">`  
  
 `<myLocalName1 type="string">myValue1</myLocalName1>`  
  
 `<myLocalName2 type="number">2</myLocalName2>`  
  
 `<myLocalName3 type="object">`  
  
 `<myNestedName1 type="boolean">true</myNestedName1>`  
  
 `<myNestedName2 type="null"/>`  
  
 `</myLocalName3>`  
  
 `</root >`  
  
 <span data-ttu-id="e4738-273">Viene mappato al frammento JSON seguente.</span><span class="sxs-lookup"><span data-stu-id="e4738-273">The following JSON fragment is what it maps to.</span></span>  
  
 `{"myLocalName1":"myValue1","myLocalName2":2,"myLocalName3":{"myNestedName1":true,"myNestedName2":null}}`  
  
> [!NOTE]
>  <span data-ttu-id="e4738-274">Nel mapping precedente non esiste alcun passaggio di codifica XML.</span><span class="sxs-lookup"><span data-stu-id="e4738-274">There is no XML encoding step in the preceding mapping.</span></span> <span data-ttu-id="e4738-275">Pertanto, WCF supporta solo documenti JSON in cui tutti i caratteri nei nomi delle chiavi siano caratteri validi nei nomi degli elementi XML.</span><span class="sxs-lookup"><span data-stu-id="e4738-275">Therefore, WCF only supports JSON documents where all characters in key names are valid characters in XML element names.</span></span> <span data-ttu-id="e4738-276">Il documento JSON {"<":"a"}, ad esempio, non è supportato perché < non è un nome valido per un elemento XML.</span><span class="sxs-lookup"><span data-stu-id="e4738-276">For example, the JSON document {"<":"a"} is not supported because < is not a valid name for an XML element.</span></span>  
  
 <span data-ttu-id="e4738-277">La situazione inversa (caratteri validi in XML ma non in JSON) non causa alcun problema perché il mapping precedente include passaggi con/senza caratteri di escape in JSON.</span><span class="sxs-lookup"><span data-stu-id="e4738-277">The reverse situation (characters valid in XML but not in JSON) does not cause any problems because the preceding mapping includes JSON escaping/unescaping steps.</span></span>  
  
 <span data-ttu-id="e4738-278">I record di matrici funzionano come segue:</span><span class="sxs-lookup"><span data-stu-id="e4738-278">Array Records work as follows:</span></span>  
  
-   <span data-ttu-id="e4738-279">Il [nome locale] dell'elemento interno è "item".</span><span class="sxs-lookup"><span data-stu-id="e4738-279">Inner element’s [local name] is "item".</span></span>  
  
-   <span data-ttu-id="e4738-280">I [figli] dell'elemento interno vengono mappati al valore nella sezione 2.3, secondo l'attributo Type di JSON così come per l'elemento JSON radice.</span><span class="sxs-lookup"><span data-stu-id="e4738-280">Inner element’s [children] map to the value in section 2.3, according to the JSON Type Attribute as is does for the Root JSON Element.</span></span> <span data-ttu-id="e4738-281">Sono consentiti più livelli di annidamento di EII (incluso l'annidamento all'interno di oggetti).</span><span class="sxs-lookup"><span data-stu-id="e4738-281">Multiple levels of nesting of EIIs (including nesting within objects) are allowed.</span></span>  
  
 <span data-ttu-id="e4738-282">Esempio: l'elemento seguente viene mappato a un frammento JSON.</span><span class="sxs-lookup"><span data-stu-id="e4738-282">Example: The following element maps to a JSON fragment.</span></span>  
  
 `<root type="array"/>`  
  
 `<item type="string">myValue1</item>`  
  
 `<item type="number">2</item>`  
  
 `<item type="array">`  
  
 `<item type="boolean">true</item>`  
  
 `<item type="null"/>`  
  
 `</item>`  
  
 `</root >`  
  
 <span data-ttu-id="e4738-283">Quello che segue è il frammento JSON.</span><span class="sxs-lookup"><span data-stu-id="e4738-283">The following is the JSON fragment.</span></span>  
  
 `["myValue1",2,[true,null]]`  
  
## <a name="see-also"></a><span data-ttu-id="e4738-284">Vedere anche</span><span class="sxs-lookup"><span data-stu-id="e4738-284">See Also</span></span>  
 <xref:System.Runtime.Serialization.Json.JsonReaderWriterFactory>  
 <xref:System.Runtime.Serialization.Json.DataContractJsonSerializer>  
 [<span data-ttu-id="e4738-285">Serializzazione JSON autonoma</span><span class="sxs-lookup"><span data-stu-id="e4738-285">Stand-Alone JSON Serialization</span></span>](../../../../docs/framework/wcf/feature-details/stand-alone-json-serialization.md)
