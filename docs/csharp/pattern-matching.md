---
title: Criteri di ricerca - Guida a C#
description: Informazioni sulle espressioni di criteri di ricerca in C#
keywords: .NET, .NET Core, C#
ms.date: 01/24/2017
ms.author: wiwagn
ms.topic: article
ms.prod: .net
ms.technology: devlang-csharp
ms.devlang: csharp
ms.assetid: 1e575c32-2e2b-4425-9dca-7d118f3ed15b
ms.openlocfilehash: 0c77c3c3da9983d20cdd86db18f60f83b86b07ea
ms.sourcegitcommit: 281070dee88db86ec3bb4634d5f558d1a4e159dd
ms.translationtype: HT
ms.contentlocale: it-IT
ms.lasthandoff: 11/11/2017
---
# <a name="pattern-matching"></a><span data-ttu-id="278d9-104">Criteri di ricerca</span><span class="sxs-lookup"><span data-stu-id="278d9-104">Pattern Matching</span></span> #

<span data-ttu-id="278d9-105">I criteri verificano che un valore abbia una determinata *forma* e possono *estrarre* informazioni dal valore quando ha la forma corrispondente.</span><span class="sxs-lookup"><span data-stu-id="278d9-105">Patterns test that a value has a certain *shape*, and can *extract* information from the value when it has the matching shape.</span></span> <span data-ttu-id="278d9-106">I criteri di ricerca offrono una sintassi più concisa per gli algoritmi già in uso.</span><span class="sxs-lookup"><span data-stu-id="278d9-106">Pattern matching provides more concise syntax for algorithms you already use today.</span></span> <span data-ttu-id="278d9-107">Usando la sintassi esistente vengono già creati algoritmi di criteri di ricerca.</span><span class="sxs-lookup"><span data-stu-id="278d9-107">You already create pattern matching algorithms using existing syntax.</span></span> <span data-ttu-id="278d9-108">Vengono scritte istruzioni `if` o `switch` che testano i valori.</span><span class="sxs-lookup"><span data-stu-id="278d9-108">You write `if` or `switch` statements that test values.</span></span> <span data-ttu-id="278d9-109">Quindi, quando le istruzioni corrispondono, si estraggono e si usano le informazioni del valore.</span><span class="sxs-lookup"><span data-stu-id="278d9-109">Then, when those statements match, you extract and use information from that value.</span></span> <span data-ttu-id="278d9-110">I nuovi elementi di sintassi sono estensioni di istruzioni già note: `is` e `switch`.</span><span class="sxs-lookup"><span data-stu-id="278d9-110">The new syntax elements are extensions to statements you are already familiar with: `is` and `switch`.</span></span> <span data-ttu-id="278d9-111">Queste nuove estensioni associano il test di un valore all'estrazione delle informazioni.</span><span class="sxs-lookup"><span data-stu-id="278d9-111">These new extensions combine testing a value and extracting that information.</span></span>

<span data-ttu-id="278d9-112">In questo argomento viene descritta la nuova sintassi per illustrare come creare codice leggibile e conciso.</span><span class="sxs-lookup"><span data-stu-id="278d9-112">In this topic, we'll look at the new syntax to show you how it enables readable, concise code.</span></span> <span data-ttu-id="278d9-113">I criteri di ricerca consentono di usare termini in cui dati e codice sono separati, a differenza delle progettazioni orientate a oggetti in cui i dati e i metodi che li modificano sono strettamente associati.</span><span class="sxs-lookup"><span data-stu-id="278d9-113">Pattern matching enables idioms where data and the code are separated, unlike object oriented designs where data and the methods that manipulate them are tightly coupled.</span></span>

<span data-ttu-id="278d9-114">Per descrivere questi nuovi termini, verranno usate strutture che rappresentano forme geometriche usando istruzioni di criteri di ricerca.</span><span class="sxs-lookup"><span data-stu-id="278d9-114">To illustrate these new idioms, let's work with structures that represent geometric shapes using pattern matching statements.</span></span> <span data-ttu-id="278d9-115">È probabile che si abbia già acquisito dimestichezza con la compilazione delle gerarchie di classi e la creazione di [metodi virtuali e metodi sottoposti a override](methods.md#inherited) per personalizzare il comportamento degli oggetti in base al tipo di runtime dell'oggetto.</span><span class="sxs-lookup"><span data-stu-id="278d9-115">You are probably familiar with building class hierarchies and creating [virtual methods and overridden methods](methods.md#inherited) to customize object behavior based on the runtime type of the object.</span></span>

<span data-ttu-id="278d9-116">Queste tecniche non sono possibili con dati che non sono strutturati in una gerarchia di classi.</span><span class="sxs-lookup"><span data-stu-id="278d9-116">Those techniques aren't possible for data that isn't structured in a class hierarchy.</span></span> <span data-ttu-id="278d9-117">Quando dati e metodi sono separati, è necessario usare altri strumenti.</span><span class="sxs-lookup"><span data-stu-id="278d9-117">When data and methods are separate, you need other tools.</span></span> <span data-ttu-id="278d9-118">I costrutti dei nuovi *criteri di ricerca* offrono una sintassi più chiara per esaminare i dati e modificare il flusso di controllo in base a qualsiasi condizione dei dati.</span><span class="sxs-lookup"><span data-stu-id="278d9-118">The new *pattern matching* constructs enable cleaner syntax to examine data and manipulate control flow based on any condition of that data.</span></span> <span data-ttu-id="278d9-119">Si scrivono già istruzioni `if` e `switch` che testano il valore di una variabile.</span><span class="sxs-lookup"><span data-stu-id="278d9-119">You already write `if` statements and `switch` that test a variable's value.</span></span> <span data-ttu-id="278d9-120">Si scrivono istruzioni `is` che testano il tipo di una variabile.</span><span class="sxs-lookup"><span data-stu-id="278d9-120">You write `is` statements that test a variable's type.</span></span> <span data-ttu-id="278d9-121">I *criteri di ricerca* aggiungono nuove funzionalità alle istruzioni.</span><span class="sxs-lookup"><span data-stu-id="278d9-121">*Pattern matching* adds new capabilities to those statements.</span></span>

<span data-ttu-id="278d9-122">In questo argomento verrà creato un metodo che calcola l'area di diverse forme geometriche.</span><span class="sxs-lookup"><span data-stu-id="278d9-122">In this topic, you'll build a method  that computes the area of different geometric shapes.</span></span> <span data-ttu-id="278d9-123">L'operazione verrà tuttavia eseguita senza ricorrere a tecniche orientate a oggetti compilare una gerarchia di classi per le diverse forme.</span><span class="sxs-lookup"><span data-stu-id="278d9-123">But, you'll do it without resorting to object oriented techniques and building a class hierarchy for the different shapes.</span></span>
<span data-ttu-id="278d9-124">Verranno usati invece i *criteri di ricerca*.</span><span class="sxs-lookup"><span data-stu-id="278d9-124">You'll use *pattern matching* instead.</span></span> <span data-ttu-id="278d9-125">Per sottolineare ulteriormente che non verrà usata l'ereditarietà, ogni forma verrà specificata come `struct` anziché come classe.</span><span class="sxs-lookup"><span data-stu-id="278d9-125">To further emphasize that we're not using inheritance, you'll make each shape a `struct` instead of a class.</span></span> <span data-ttu-id="278d9-126">Si noti che poiché tipi `struct` diversi non possono specificare un tipo di base comune definito dall'utente, l'ereditarietà non è una progettazione possibile.</span><span class="sxs-lookup"><span data-stu-id="278d9-126">Note that different `struct` types cannot specify a common user defined base type, so inheritance is not a possible design.</span></span>
<span data-ttu-id="278d9-127">Procedendo nell'esempio, confrontare il codice a un eventuale codice strutturato come gerarchia di oggetti.</span><span class="sxs-lookup"><span data-stu-id="278d9-127">As you go through this sample, contrast this code with how it would be structured as an object hierarchy.</span></span> <span data-ttu-id="278d9-128">Quando i dati in cui è necessario eseguire le query e che devono essere modificati non sono costituiti da una gerarchia di classi, i criteri di ricerca offrono progettazioni molto eleganti.</span><span class="sxs-lookup"><span data-stu-id="278d9-128">When the data you must query and manipulate is not a class hierarchy, pattern matching enables very elegant designs.</span></span>

<span data-ttu-id="278d9-129">Anziché iniziare con una definizione della forma astratta e l'aggiunta di diverse classi di forme specifiche, iniziare con definizioni di soli dati semplici per ogni forma geometrica:</span><span class="sxs-lookup"><span data-stu-id="278d9-129">Rather than starting with an abstract shape definition and adding different specific shape classes, let's start instead with simple data only definitions for each of the geometric shapes:</span></span>

[!code-csharp[ShapeDefinitions](../../samples/csharp/PatternMatching/Shapes.cs#01_ShapeDefinitions "Shape definitions")]

<span data-ttu-id="278d9-130">Da queste strutture scrivere un metodo che calcola l'area di una forma.</span><span class="sxs-lookup"><span data-stu-id="278d9-130">From these structures, let's write a method that computes the area of some shape.</span></span>

## <a name="the-is-type-pattern-expression"></a><span data-ttu-id="278d9-131">Espressione del criterio di tipo `is`</span><span class="sxs-lookup"><span data-stu-id="278d9-131">The `is` type pattern expression</span></span>

<span data-ttu-id="278d9-132">Prima di C# 7, era necessario testare ogni tipo di una serie di istruzioni `if` e `is`:</span><span class="sxs-lookup"><span data-stu-id="278d9-132">Before C# 7, you'd need to test each type in a series of `if` and `is` statements:</span></span>

[!code-csharp[ClassicIsExpression](../../samples/csharp/PatternMatching/GeometricUtilities.cs#02_ClassicIsExpression "Classic type pattern using is")]

<span data-ttu-id="278d9-133">Il codice precedente è un'espressione classica del *criterio di tipo*: si esegue il test di una variabile per determinarne il tipo ed eseguire un'azione diversa in base al tipo.</span><span class="sxs-lookup"><span data-stu-id="278d9-133">That code above is a classic expression of the *type pattern*: You're testing a variable to determine its type and taking a different action based on that type.</span></span>

<span data-ttu-id="278d9-134">Questo codice diventa più semplice con l'uso di estensioni dell'espressione `is` per l'assegnazione di una variabile se il test ha esito positivo:</span><span class="sxs-lookup"><span data-stu-id="278d9-134">This code becomes simpler using extensions to the `is` expression to assign a variable if the test succeeds:</span></span>

[!code-csharp[IsPatternExpression](../../samples/csharp/PatternMatching/GeometricUtilities.cs#03_IsPatternExpression "is pattern expression")]

<span data-ttu-id="278d9-135">In questa versione aggiornata l'espressione `is` esegue il test della variabile e la assegna a una nuova variabile del tipo appropriato.</span><span class="sxs-lookup"><span data-stu-id="278d9-135">In this updated version, the `is` expression both tests the variable and assigns it to a new variable of the proper type.</span></span> <span data-ttu-id="278d9-136">Si noti anche che questa versione include il tipo `Rectangle` che è uno `struct`.</span><span class="sxs-lookup"><span data-stu-id="278d9-136">Also, notice that this version includes the `Rectangle` type, which is a `struct`.</span></span> <span data-ttu-id="278d9-137">La nuova espressione `is` può essere usata con tipi di valore e tipi di riferimento.</span><span class="sxs-lookup"><span data-stu-id="278d9-137">The new `is` expression works with value types as well as reference types.</span></span>

<span data-ttu-id="278d9-138">Le regole del linguaggio per i criteri di ricerca consentono di evitare un uso errato dei risultati di un'espressione di confronto.</span><span class="sxs-lookup"><span data-stu-id="278d9-138">Language rules for pattern matching expressions help you avoid misusing the results of a match expression.</span></span> <span data-ttu-id="278d9-139">Nell'esempio precedente le variabili `s`, `c` e `r` sono nell'ambito e assegnate definitivamente solo quando le relative espressioni di criteri di ricerca hanno risultati `true`.</span><span class="sxs-lookup"><span data-stu-id="278d9-139">In the example above, the variables `s`, `c`, and `r` are only in scope and definitely assigned when the respective pattern match expressions have `true` results.</span></span> <span data-ttu-id="278d9-140">Se si tenta di usare una variabile in un altro percorso, il codice genera errori del compilatore.</span><span class="sxs-lookup"><span data-stu-id="278d9-140">If you try to use either variable in another location, your code generates compiler errors.</span></span>

<span data-ttu-id="278d9-141">Vengono ora esaminate entrambe le regole nel dettaglio iniziando con l'ambito.</span><span class="sxs-lookup"><span data-stu-id="278d9-141">Let's examine both of those rules in detail, beginning with scope.</span></span> <span data-ttu-id="278d9-142">La variabile `c` è nell'ambito solo nel ramo `else` della prima istruzione `if`.</span><span class="sxs-lookup"><span data-stu-id="278d9-142">The variable `c` is in scope only in the `else` branch of the first `if` statement.</span></span> <span data-ttu-id="278d9-143">La variabile `s` è nell'ambito nel metodo `ComputeArea`.</span><span class="sxs-lookup"><span data-stu-id="278d9-143">The variable `s` is in scope in the method `ComputeArea`.</span></span> <span data-ttu-id="278d9-144">Ciò accade perché ogni ramo di un'istruzione `if` definisce un ambito separato per le variabili.</span><span class="sxs-lookup"><span data-stu-id="278d9-144">That's because each branch of an `if` statement establishes a separate scope for variables.</span></span> <span data-ttu-id="278d9-145">Tuttavia, l'istruzione `if` stessa non esegue questa operazione.</span><span class="sxs-lookup"><span data-stu-id="278d9-145">However, the `if` statement itself does not.</span></span> <span data-ttu-id="278d9-146">Ciò significa che le variabili dichiarate nell'istruzione `if` sono nello stesso ambito dell'istruzione `if` (in questo caso, il metodo). Questo comportamento non è specifico dei criteri di ricerca, ma è il comportamento definito per gli ambiti delle variabili e le istruzioni `if` e `else`.</span><span class="sxs-lookup"><span data-stu-id="278d9-146">That means variables declared in the `if` statement are in the same scope as the `if` statement (the method in this case.) This behavior is not specific to pattern matching, but is the defined behavior for variable scopes and `if` and `else` statements.</span></span>

<span data-ttu-id="278d9-147">Le variabili `c` e `s` vengono assegnate quando le rispettive istruzioni `if` sono vere a causa del meccanismo di assegnazione definitiva quando sono vere.</span><span class="sxs-lookup"><span data-stu-id="278d9-147">The variables `c` and `s` are assigned when the respective `if` statements are true because of the definitely assigned when true mechanism.</span></span>

> [!TIP]
> <span data-ttu-id="278d9-148">Gli esempi di questo argomento usano il costrutto consigliato dove un'espressione `is` di criteri di ricerca assegna in modo definitivo la variabile di corrispondenza nel ramo `true` dell'istruzione `if`.</span><span class="sxs-lookup"><span data-stu-id="278d9-148">The samples in this topic use the recommended construct where a pattern match `is` expression definitely assigns the match variable in the `true` branch of the `if` statement.</span></span>
> <span data-ttu-id="278d9-149">È possibile invertire la logica affermando che `if (!(shape is Square s))` e la variabile `s` vengono assegnate definitivamente solo nel ramo `false`.</span><span class="sxs-lookup"><span data-stu-id="278d9-149">You could reverse the logic by saying `if (!(shape is Square s))` and the variable `s` would be definitely assigned only in the `false` branch.</span></span> <span data-ttu-id="278d9-150">Sebbene sia valido in C#, questo approccio non è consigliabile poiché risulta più complesso seguire la logica.</span><span class="sxs-lookup"><span data-stu-id="278d9-150">While this is valid C#, it is not recommended because it is more confusing to follow the logic.</span></span>

<span data-ttu-id="278d9-151">Queste regole comportano l'impossibilità di accedere accidentalmente al risultato di un'espressione di criteri di ricerca quando i criteri non vengono soddisfatti.</span><span class="sxs-lookup"><span data-stu-id="278d9-151">These rules mean that you are unlikely to accidentally access the result of a pattern match expression when that pattern was not met.</span></span>

## <a name="using-pattern-matching-switch-statements"></a><span data-ttu-id="278d9-152">Uso di istruzioni `switch` di criteri di ricerca</span><span class="sxs-lookup"><span data-stu-id="278d9-152">Using pattern matching `switch` statements</span></span>

<span data-ttu-id="278d9-153">È possibile sia necessario in seguito supportare altri tipi di forme.</span><span class="sxs-lookup"><span data-stu-id="278d9-153">As time goes on, you may need to support other shape types.</span></span> <span data-ttu-id="278d9-154">Man mano che aumenta il numero di condizioni da testare, l'uso di espressioni di criteri di ricerca `is` può risultare troppo complesso.</span><span class="sxs-lookup"><span data-stu-id="278d9-154">As the number of conditions you are testing grows, you'll find that using the `is` pattern matching expressions can become cumbersome.</span></span> <span data-ttu-id="278d9-155">Oltre a richiedere istruzioni `if` in ogni tipo da controllare, le espressioni `is` sono limitate all'esecuzione di test se l'input corrisponde a un singolo tipo.</span><span class="sxs-lookup"><span data-stu-id="278d9-155">In addition to requiring `if` statements on each type you want to check, the `is` expressions are limited to testing if the input matches a single type.</span></span> <span data-ttu-id="278d9-156">In questo caso, le espressioni di criteri di ricerca `switch` risultano una scelta migliore.</span><span class="sxs-lookup"><span data-stu-id="278d9-156">In this case, you'll find that the `switch` pattern matching expressions becomes a better choice.</span></span> 

<span data-ttu-id="278d9-157">L'istruzione `switch` tradizionale era un'espressione di criteri che supportava i criteri costanti.</span><span class="sxs-lookup"><span data-stu-id="278d9-157">The traditional `switch` statement was a pattern expression: it supported the constant pattern.</span></span>
<span data-ttu-id="278d9-158">Era possibile confrontare una variabile con qualsiasi costante in un'istruzione `case`:</span><span class="sxs-lookup"><span data-stu-id="278d9-158">You could compare a variable to any constant used in a `case` statement:</span></span>

[!code-csharp[ClassicSwitch](../../samples/csharp/PatternMatching/GeometricUtilities.cs#04_ClassicSwitch "Classic switch statement")]

<span data-ttu-id="278d9-159">Gli unici criteri supportati dall'istruzione `switch` erano i criteri costanti.</span><span class="sxs-lookup"><span data-stu-id="278d9-159">The only pattern supported by the `switch` statement was the constant pattern.</span></span> <span data-ttu-id="278d9-160">Era presente un'ulteriore limitazione ai tipi numerici e al tipo `string`.</span><span class="sxs-lookup"><span data-stu-id="278d9-160">It was further limited to numeric types and the `string` type.</span></span>
<span data-ttu-id="278d9-161">Queste limitazioni sono state rimosse ed è ora possibile scrivere un'istruzione `switch` usando i criteri di tipo:</span><span class="sxs-lookup"><span data-stu-id="278d9-161">Those restrictions have been removed, and you can now write a `switch` statement using the type pattern:</span></span>

[!code-csharp[Switch Type Pattern](../../samples/csharp/PatternMatching/GeometricUtilities.cs#05_SwitchTypePattern "Compute with `switch` expression")]

<span data-ttu-id="278d9-162">L'istruzione `switch` di criteri di ricerca usa una sintassi già nota agli sviluppatori che hanno usato l'istruzione `switch` di tipo C.</span><span class="sxs-lookup"><span data-stu-id="278d9-162">The pattern matching `switch` statement uses familiar syntax to developers who have used the traditional C-style `switch` statement.</span></span> <span data-ttu-id="278d9-163">Viene valutata ogni istruzione `case` e viene eseguito il codice sottostante la condizione che corrisponde alla variabile di input.</span><span class="sxs-lookup"><span data-stu-id="278d9-163">Each `case` is evaluated and the code beneath the condition that matches the input variable is executed.</span></span> <span data-ttu-id="278d9-164">L'esecuzione del codice non può "passare" da un'espressione case alla successiva. La sintassi dell'istruzione `case` richiede che ogni `case` termini con `break`, `return` o `goto`.</span><span class="sxs-lookup"><span data-stu-id="278d9-164">Code execution cannot "fall through" from one case expression to the next; the syntax of the `case` statement requires that each `case` end with a `break`, `return`, or `goto`.</span></span>

> [!NOTE]
> <span data-ttu-id="278d9-165">Le istruzioni `goto` per il passaggio a un'altra etichetta sono valide solo per il criterio costante, l'istruzione switch classica.</span><span class="sxs-lookup"><span data-stu-id="278d9-165">The `goto` statements to jump to another label are valid only for the constant pattern, the classic switch statement.</span></span>

<span data-ttu-id="278d9-166">L'istruzione `switch` è governata da nuove regole importanti.</span><span class="sxs-lookup"><span data-stu-id="278d9-166">There are important new rules governing the `switch` statement.</span></span> <span data-ttu-id="278d9-167">Le limitazioni al tipo della variabile nell'espressione `switch` sono state rimosse.</span><span class="sxs-lookup"><span data-stu-id="278d9-167">The restrictions on the type of the variable in the `switch` expression have been removed.</span></span>
<span data-ttu-id="278d9-168">È possibile usare tutti i tipi, ad esempio `object`.</span><span class="sxs-lookup"><span data-stu-id="278d9-168">Any type, such as `object` in this example, may be used.</span></span> <span data-ttu-id="278d9-169">Le espressioni case non sono più limitate ai valori costanti.</span><span class="sxs-lookup"><span data-stu-id="278d9-169">The case expressions are no longer limited to constant values.</span></span> <span data-ttu-id="278d9-170">La rimozione di questa limitazione significa che la ridisposizione delle sezioni `switch` può modificare il comportamento di un programma.</span><span class="sxs-lookup"><span data-stu-id="278d9-170">Removing that limitation means that reordering `switch` sections may change a program's behavior.</span></span>

<span data-ttu-id="278d9-171">Quando sono limitate ai valori costanti, solo un'etichetta `case` può corrispondere al valore dell'espressione `switch`.</span><span class="sxs-lookup"><span data-stu-id="278d9-171">When limited to constant values, no more than one `case` label could match the value of the `switch` expression.</span></span> <span data-ttu-id="278d9-172">Se a questo si aggiungeva la regola per la quale ogni sezione `switch` non doveva passare alla sezione successiva ne conseguiva che le sezioni `switch` potevano essere ridisposte in qualsiasi ordine senza effetti sul comportamento.</span><span class="sxs-lookup"><span data-stu-id="278d9-172">Combine that with the rule that every `switch` section must not fall through to the next section, and it followed that the `switch` sections could be rearranged in any order without affecting behavior.</span></span>
<span data-ttu-id="278d9-173">Ora, con espressioni `switch` più generalizzate, l'ordine di ogni sezione è rilevante.</span><span class="sxs-lookup"><span data-stu-id="278d9-173">Now, with more generalized `switch` expressions, the order of each section matters.</span></span> <span data-ttu-id="278d9-174">Le espressioni `switch` vengono valutate in ordine testuale.</span><span class="sxs-lookup"><span data-stu-id="278d9-174">The `switch` expressions are evaluated in textual order.</span></span> <span data-ttu-id="278d9-175">L'esecuzione si trasferisce alla prima etichetta `switch` che corrisponde all'espressione `switch`.</span><span class="sxs-lookup"><span data-stu-id="278d9-175">Execution transfers to the first `switch` label that matches the `switch` expression.</span></span>  
<span data-ttu-id="278d9-176">Si noti che il caso `default` verrà eseguito solo se non corrispondano altre etichette case.</span><span class="sxs-lookup"><span data-stu-id="278d9-176">Note that the `default` case will only be executed if no other case labels match.</span></span> <span data-ttu-id="278d9-177">Il caso `default` viene valutato per ultimo, indipendentemente dall'ordine testuale.</span><span class="sxs-lookup"><span data-stu-id="278d9-177">The `default` case is evaluated last, regardless of its textual order.</span></span> <span data-ttu-id="278d9-178">Se non è presente alcun caso `default` e nessuna delle altre istruzioni `case` corrisponde, l'esecuzione continua con l'istruzione che segue l'istruzione `switch`.</span><span class="sxs-lookup"><span data-stu-id="278d9-178">If there is no `default` case, and none of the other `case` statements match, execution continues at the statement following the `switch` statement.</span></span> <span data-ttu-id="278d9-179">Non viene eseguito il codice di alcuna etichetta `case`.</span><span class="sxs-lookup"><span data-stu-id="278d9-179">None of the `case` labels code is executed.</span></span>

## <a name="when-clauses-in-case-expressions"></a><span data-ttu-id="278d9-180">Clausole `when` nelle espressioni `case`</span><span class="sxs-lookup"><span data-stu-id="278d9-180">`when` clauses in `case` expressions</span></span>

<span data-ttu-id="278d9-181">È possibile creare casi speciali per le forme con area 0 usando una clausola `when` nell'etichetta `case`.</span><span class="sxs-lookup"><span data-stu-id="278d9-181">You can make special cases for those shapes that have 0 area by using a `when` clause on the `case` label.</span></span> <span data-ttu-id="278d9-182">Un quadrato con una lunghezza del lato pari a 0 o un cerchio con raggio pari a 0 ha un'area 0.</span><span class="sxs-lookup"><span data-stu-id="278d9-182">A square with a side length of 0, or a circle with a radius of 0 has a 0 area.</span></span> <span data-ttu-id="278d9-183">Questa condizione viene specificata usando una clausola `when` nell'etichetta `case`:</span><span class="sxs-lookup"><span data-stu-id="278d9-183">You specify that condition using a `when` clause on the `case` label:</span></span>  

[!code-csharp[ComputeDegenerateShapes](../../samples/csharp/PatternMatching/GeometricUtilities.cs#07_ComputeDegenerateShapes "Compute shapes with 0 area")]

<span data-ttu-id="278d9-184">Questa modifica illustra alcune considerazioni importanti sulla nuova sintassi.</span><span class="sxs-lookup"><span data-stu-id="278d9-184">This change demonstrates a few important points about the new syntax.</span></span> <span data-ttu-id="278d9-185">Innanzitutto, è possibile applicare più etichette `case` a una sezione `switch`.</span><span class="sxs-lookup"><span data-stu-id="278d9-185">First, multiple `case` labels can be applied to one `switch` section.</span></span> <span data-ttu-id="278d9-186">Il blocco di istruzioni viene eseguito quando una delle etichette è `true`.</span><span class="sxs-lookup"><span data-stu-id="278d9-186">The statement block is executed when any of those labels is `true`.</span></span> <span data-ttu-id="278d9-187">In questa istanza se l'espressione `switch` è un cerchio o un quadrato con area 0, il metodo restituisce la costante 0.</span><span class="sxs-lookup"><span data-stu-id="278d9-187">In this instance, if the `switch` expression is either a circle or a square with 0 area, the method returns the constant 0.</span></span>

<span data-ttu-id="278d9-188">Questo esempio illustra due variabili diverse in due etichette `case` per il primo blocco `switch`.</span><span class="sxs-lookup"><span data-stu-id="278d9-188">This example introduces two different variables in the two `case` labels for the first `switch` block.</span></span> <span data-ttu-id="278d9-189">Si noti che le istruzioni in questo blocco `switch` non usano la variabile `c` per il cerchio o `s` per il quadrato.</span><span class="sxs-lookup"><span data-stu-id="278d9-189">Notice that the statements in this `switch` block do not use either the variables `c` (for the circle) or `s` (for the square).</span></span>
<span data-ttu-id="278d9-190">Nessuna delle variabili è assegnata in modo definitivo in questo blocco `switch`.</span><span class="sxs-lookup"><span data-stu-id="278d9-190">Neither of those variables is definitely assigned in this `switch` block.</span></span>
<span data-ttu-id="278d9-191">Se uno di questi casi corrisponde, significa che una delle variabili è stata assegnata.</span><span class="sxs-lookup"><span data-stu-id="278d9-191">If either of these cases match, clearly one of the variables has been assigned.</span></span>
<span data-ttu-id="278d9-192">Tuttavia, non è possibile sapere *quale* variabile è stata assegnata in fase di compilazione poiché entrambi i casi possono corrispondere in fase di esecuzione.</span><span class="sxs-lookup"><span data-stu-id="278d9-192">However, it is impossible to tell *which* has been assigned at compile-time, because either case could match at runtime.</span></span> <span data-ttu-id="278d9-193">Per questo motivo, nella maggior parte dei casi in cui vengono usate più etichette `case` per lo stesso blocco, non verrà introdotta una nuova variabile nell'istruzione `case` o verrà usata solo la variabile nella clausola `when`.</span><span class="sxs-lookup"><span data-stu-id="278d9-193">For that reason, most times when you use multiple `case` labels for the same block, you won't introduce a new variable in the `case` statement, or you will only use the variable in the `when` clause.</span></span>

<span data-ttu-id="278d9-194">Dopo aver aggiunto le forme con area 0, si aggiungono due tipi di forme aggiuntivi, un rettangolo e un triangolo:</span><span class="sxs-lookup"><span data-stu-id="278d9-194">Having added those shapes with 0 area, let's add a couple more shape types: a rectangle and a triangle:</span></span>

[!code-csharp[AddRectangleAndTriangle](../../samples/csharp/PatternMatching/GeometricUtilities.cs#09_AddRectangleAndTriangle "Add rectangle and triangle")]

 <span data-ttu-id="278d9-195">Questo set di modifiche aggiunge etichette `case` per il caso degenere ed etichette e blocchi per ogni nuova forma.</span><span class="sxs-lookup"><span data-stu-id="278d9-195">This set of changes adds `case` labels for the degenerate case, and labels and blocks for each of the new shapes.</span></span> 

<span data-ttu-id="278d9-196">È possibile infine aggiungere un caso `null` per assicurarsi che l'argomento non sia `null`:</span><span class="sxs-lookup"><span data-stu-id="278d9-196">Finally, you can add a `null` case to ensure the argument is not `null`:</span></span>

[!code-csharp[NullCase](../../samples/csharp/PatternMatching/GeometricUtilities.cs#10_NullCase "Add null case")]

<span data-ttu-id="278d9-197">Lo speciale comportamento del criterio `null` è interessante perché la costante `null` nel criterio non ha un tipo, ma può essere convertita in qualsiasi tipo di riferimento o nullable.</span><span class="sxs-lookup"><span data-stu-id="278d9-197">The special behavior for the `null` pattern is interesting because the constant `null` in the pattern does not have a type but can be converted to any reference type or nullable type.</span></span> <span data-ttu-id="278d9-198">Anziché convertire una costante `null` in un tipo, il linguaggio definisce che un valore `null` non corrisponderà ad alcun criterio del tipo, indipendentemente dal tipo in fase di compilazione della variabile.</span><span class="sxs-lookup"><span data-stu-id="278d9-198">Rather than convert a `null` to any type, the language defines that a `null` value will not match any type pattern, regardless of the compile-time type of the variable.</span></span> <span data-ttu-id="278d9-199">Questo comportamento rende il nuovo criterio del tipo basato su `switch` coerente con l'istruzione `is`: le istruzioni `is` restituiscono sempre `false` quando il valore controllato è `null`.</span><span class="sxs-lookup"><span data-stu-id="278d9-199">This behavior makes the new `switch` based type pattern consistent with the `is` statement: `is` statements always return `false` when the value being checked is `null`.</span></span> <span data-ttu-id="278d9-200">È anche più semplice: dopo aver controllato il tipo, non è necessario un controllo null aggiuntivo.</span><span class="sxs-lookup"><span data-stu-id="278d9-200">It's also simpler: once you have checked the type, you don't need an additional null check.</span></span> <span data-ttu-id="278d9-201">Questo è dimostrato dal fatto che non è presente alcun controllo null in nessuno dei blocchi di casi degli esempi precedenti: i controlli non sono necessari poiché la corrispondenza del criterio del tipo garantisce già un valore non null.</span><span class="sxs-lookup"><span data-stu-id="278d9-201">You can see that from the fact that there are no null checks in any of the case blocks of the samples above: they are not necessary, since matching the type pattern guarantees a non-null value.</span></span>

## <a name="var-declarations-in-case-expressions"></a><span data-ttu-id="278d9-202">`var`le dichiarazioni in `case` espressioni</span><span class="sxs-lookup"><span data-stu-id="278d9-202">`var` declarations in `case` expressions</span></span>

<span data-ttu-id="278d9-203">L'introduzione di `var` come una delle espressioni match introduce le nuove regole per la corrispondenza.</span><span class="sxs-lookup"><span data-stu-id="278d9-203">The introduction of `var` as one of the match expressions introduces new rules to the pattern match.</span></span>

<span data-ttu-id="278d9-204">La prima regola è che il `var` dichiarazione segue le regole di inferenza del tipo normale: il tipo viene dedotto il tipo statico dell'espressione switch.</span><span class="sxs-lookup"><span data-stu-id="278d9-204">The first rule is that the `var` declaration follows the normal type inference rules: The type is inferred to be the static type of the switch expression.</span></span> <span data-ttu-id="278d9-205">Da questa regola, il tipo corrisponde sempre.</span><span class="sxs-lookup"><span data-stu-id="278d9-205">From that rule, the type always matches.</span></span>

<span data-ttu-id="278d9-206">La seconda regola è che un `var` dichiarazione di non includere il controllo null che includono altre espressioni di tipo modello.</span><span class="sxs-lookup"><span data-stu-id="278d9-206">The second rule is that a `var` declaration does not have the null check that other type pattern expressions include.</span></span> <span data-ttu-id="278d9-207">Pertanto, la variabile può essere null e un controllo null è necessario in questo caso.</span><span class="sxs-lookup"><span data-stu-id="278d9-207">That means the variable may be null, and a null check is necessary in that case.</span></span>

<span data-ttu-id="278d9-208">Le due regole che indicano in molti casi, un `var` dichiarazione in un `case` espressione corrisponde alle stesse condizioni un `default` espressione.</span><span class="sxs-lookup"><span data-stu-id="278d9-208">Those two rules mean that in many instances, a `var` declaration in a `case` expression matches the same conditions as a `default` expression.</span></span>
<span data-ttu-id="278d9-209">Perché è preferibile a qualsiasi case non predefinita di `default` caso, il `default` caso non verrà mai eseguita.</span><span class="sxs-lookup"><span data-stu-id="278d9-209">Because any non-default case is preferred to the `default` case, the `default` case will never execute.</span></span>

> [!NOTE]
> <span data-ttu-id="278d9-210">Il compilatore non genera un avviso in questi casi in cui un `default` case è stato scritto, ma non verrà mai eseguita.</span><span class="sxs-lookup"><span data-stu-id="278d9-210">The compiler does not emit a warning in those cases where a `default` case has been written but will never execute.</span></span> <span data-ttu-id="278d9-211">Questo comportamento è coerente con l'attuale `switch` comportamento dell'istruzione in cui sono stati elencati tutti i casi possibili.</span><span class="sxs-lookup"><span data-stu-id="278d9-211">This is consistent with current `switch` statement behavior where all possible cases have been listed.</span></span>

<span data-ttu-id="278d9-212">La terza regola introduce viene utilizzato in un `var` case può essere utile.</span><span class="sxs-lookup"><span data-stu-id="278d9-212">The third rule introduces uses where a `var` case may be useful.</span></span> <span data-ttu-id="278d9-213">Si supponga che si sta eseguendo un criterio di ricerca in cui l'input è una stringa e si sta cercando valori comando noto.</span><span class="sxs-lookup"><span data-stu-id="278d9-213">Imagine that you are doing a pattern match where the input is a string and you are searching for known command values.</span></span> <span data-ttu-id="278d9-214">È possibile scrivere simile al seguente:</span><span class="sxs-lookup"><span data-stu-id="278d9-214">You might write something like:</span></span>

[!code-csharp[VarCaseExpression](../../samples/csharp/PatternMatching/Program.cs#VarCaseExpression "use a var case expression to filter white space")]

<span data-ttu-id="278d9-215">Il `var` caso corrispondenze `null`, una stringa vuota o qualsiasi stringa che contiene solo spazi vuoti.</span><span class="sxs-lookup"><span data-stu-id="278d9-215">The `var` case matches `null`, the empty string, or any string that contains only whitespace.</span></span> <span data-ttu-id="278d9-216">Si noti che il codice precedente utilizza il `?.` operatore per assicurare che non accidentalmente genera un <xref:System.NullReferenceException>.</span><span class="sxs-lookup"><span data-stu-id="278d9-216">Notice that the preceding code uses the `?.` operator to ensure that it does not accidentally throw a <xref:System.NullReferenceException>.</span></span> <span data-ttu-id="278d9-217">Il `default` case gestisce qualsiasi altro valore di stringa non riconosciute dal parser comando.</span><span class="sxs-lookup"><span data-stu-id="278d9-217">The `default` case handles any other string values that are not understood by this command parser.</span></span>

<span data-ttu-id="278d9-218">Questo è un esempio in cui si desidera considerare un `var` caso l'espressione che è diverso da quello di un `default` espressione.</span><span class="sxs-lookup"><span data-stu-id="278d9-218">This is one example where you may want to consider a `var` case expression that is distinct from a `default` expression.</span></span>

## <a name="conclusions"></a><span data-ttu-id="278d9-219">Conclusioni</span><span class="sxs-lookup"><span data-stu-id="278d9-219">Conclusions</span></span>

<span data-ttu-id="278d9-220">I *costrutti dei criteri di ricerca* consentono di gestire in modo semplice il flusso di controllo tra variabili e tipi diversi non correlati a una gerarchia di ereditarietà.</span><span class="sxs-lookup"><span data-stu-id="278d9-220">*Pattern Matching constructs* enable you to easily manage control flow among different variables and types that are not related by an inheritance hierarchy.</span></span> <span data-ttu-id="278d9-221">È anche possibile controllare la logica per usare qualsiasi condizione testata sulla variabile.</span><span class="sxs-lookup"><span data-stu-id="278d9-221">You can also control logic to use any condition you test on the variable.</span></span> <span data-ttu-id="278d9-222">Sono anche disponibili criteri e termini che è possibile usare per compilare applicazioni più distribuite, dove i dati e i metodi che modificano i dati sono separati.</span><span class="sxs-lookup"><span data-stu-id="278d9-222">It enables patterns and idioms that you'll need more often as you build more distributed applications, where data and the methods that manipulate that data are separate.</span></span> <span data-ttu-id="278d9-223">Sarà possibile notare che gli struct delle forme usati nell'esempio non contengono metodi, ma solo proprietà di sola lettura.</span><span class="sxs-lookup"><span data-stu-id="278d9-223">You'll notice that the shape structs used in this sample do not contain any methods, just read-only properties.</span></span>
<span data-ttu-id="278d9-224">I criteri di ricerca possono essere usati con qualsiasi tipo di dati.</span><span class="sxs-lookup"><span data-stu-id="278d9-224">Pattern Matching works with any data type.</span></span> <span data-ttu-id="278d9-225">Vengono scritte espressioni che esaminano l'oggetto ed eseguono decisioni per il flusso di controllo in base alle condizioni.</span><span class="sxs-lookup"><span data-stu-id="278d9-225">You write expressions that examine the object, and make control flow decisions based on those conditions.</span></span>

<span data-ttu-id="278d9-226">Confrontare il codice dell'esempio con la progettazione che deriverebbe dalla creazione di una gerarchia di classi per una `Shape` astratta e le forme derivate specifiche ognuna con la propria implementazione di un metodo virtuale per il calcolo dell'area.</span><span class="sxs-lookup"><span data-stu-id="278d9-226">Compare the code from this sample with the design that would follow from creating a class hierarchy for an abstract `Shape` and specific derived shapes each with their own implementation of a virtual method to calculate the area.</span></span> <span data-ttu-id="278d9-227">Spesso sarà possibile osservare che le espressioni di criteri di ricerca possono essere uno strumento utile quando si usano dati e si vogliono separare le esigenze di archiviazione di dati da quelle di comportamento.</span><span class="sxs-lookup"><span data-stu-id="278d9-227">You'll often find that pattern matching expressions can be a very useful tool when you are working with data and want to separate the data storage concerns from the behavior concerns.</span></span>

