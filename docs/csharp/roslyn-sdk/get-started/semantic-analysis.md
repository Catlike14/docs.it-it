---
title: Introduzione all'analisi semantica
description: Questa esercitazione offre una panoramica dell'utilizzo dell'analisi semantica con .NET Compiler SDK.
author: billwagner
ms.author: wiwagn
ms.date: 02/06/2018
ms.topic: conceptual
ms.prod: .net
ms.devlang: devlang-csharp
ms.custom: mvc
ms.openlocfilehash: 04bd57dfd32a51bf5d7e3a573e34140b0feec90f
ms.sourcegitcommit: 3a96c706e4dbb4667bf3bf37edac9e1666646f93
ms.translationtype: HT
ms.contentlocale: it-IT
ms.lasthandoff: 02/27/2018
---
# <a name="get-started-with-semantic-analysis"></a><span data-ttu-id="b8d50-103">Introduzione all'analisi semantica</span><span class="sxs-lookup"><span data-stu-id="b8d50-103">Get started with semantic analysis</span></span>

<span data-ttu-id="b8d50-104">In questa esercitazione si presuppone una certa familiarità con l'API Syntax.</span><span class="sxs-lookup"><span data-stu-id="b8d50-104">This tutorial assumes you're familiar with the Syntax API.</span></span> <span data-ttu-id="b8d50-105">L'articolo [Introduzione all'analisi della sintassi](syntax-analysis.md) offre informazioni introduttive sufficienti.</span><span class="sxs-lookup"><span data-stu-id="b8d50-105">The [get started with syntax analysis](syntax-analysis.md) article provides sufficient introduction.</span></span>

<span data-ttu-id="b8d50-106">In questa esercitazione verranno esplorate le API **Symbol** e **Binding**.</span><span class="sxs-lookup"><span data-stu-id="b8d50-106">In this tutorial, you explore the **Symbol** and **Binding APIs**.</span></span> <span data-ttu-id="b8d50-107">Queste API offrono informazioni sul _significato semantico_ di un programma</span><span class="sxs-lookup"><span data-stu-id="b8d50-107">These APIs provide information about the _semantic meaning_ of a program.</span></span> <span data-ttu-id="b8d50-108">e consentono di porre domande sui tipi rappresentati da qualsiasi simbolo nel programma e ottenere risposte.</span><span class="sxs-lookup"><span data-stu-id="b8d50-108">They enable you to ask and answer questions about the types represented by any symbol in your program.</span></span>

## <a name="understanding-compilations-and-symbols"></a><span data-ttu-id="b8d50-109">Informazioni su compilazioni e simboli</span><span class="sxs-lookup"><span data-stu-id="b8d50-109">Understanding Compilations and Symbols</span></span>

<span data-ttu-id="b8d50-110">Man mano che si lavora con .NET Compiler SDK si acquisirà familiarità con le distinzioni tra API Syntax e API Semantic.</span><span class="sxs-lookup"><span data-stu-id="b8d50-110">As you work more with the .NET Compiler SDK, you become familiar with the distinctions between Syntax API and the Semantic API.</span></span> <span data-ttu-id="b8d50-111">L'**API Syntax** consente di esaminare la _struttura_ di un programma.</span><span class="sxs-lookup"><span data-stu-id="b8d50-111">The **Syntax API** allows you to look at the _structure_ of a program.</span></span> <span data-ttu-id="b8d50-112">Tuttavia, spesso servono informazioni più dettagliate sulla semantica o il _significato_ di un programma.</span><span class="sxs-lookup"><span data-stu-id="b8d50-112">However, often you want richer information about the semantics or _meaning_ of a program.</span></span> <span data-ttu-id="b8d50-113">Anche se un singolo file o frammento di codice Visual Basic o C# può essere analizzato sintatticamente in isolamento, non ha molto senso porsi domande del tipo "qual è il tipo di questa variabile" in un contesto isolato.</span><span class="sxs-lookup"><span data-stu-id="b8d50-113">While a loose code file or snippet of VB or C# code can be syntactically analyzed in isolation, it's not meaningful to ask questions such as "what's the type of this variable" in a vacuum.</span></span> <span data-ttu-id="b8d50-114">Il significato di un nome di tipo potrebbe essere dipendente da riferimenti ad assembly, importazioni di spazi dei nomi o altri file di codice.</span><span class="sxs-lookup"><span data-stu-id="b8d50-114">The meaning of a type name may be dependent on assembly references, namespace imports, or other code files.</span></span> <span data-ttu-id="b8d50-115">Queste domande possono ottenere risposta tramite l'**API Semantic**, in particolare la classe <xref:Microsoft.CodeAnalysis.Compilation?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="b8d50-115">Those questions are answered using the **Semantic API**, specifically the <xref:Microsoft.CodeAnalysis.Compilation?displayProperty=nameWithType> class.</span></span>

<span data-ttu-id="b8d50-116">Un'istanza di <xref:Microsoft.CodeAnalysis.Compilation> è paragonabile a un singolo progetto, dal punto di vista del compilatore e rappresenta tutti gli elementi necessari per compilare un programma Visual Basic o C#.</span><span class="sxs-lookup"><span data-stu-id="b8d50-116">An instance of <xref:Microsoft.CodeAnalysis.Compilation> is analogous to a single project as seen by the compiler and represents everything needed to compile a Visual Basic or C# program.</span></span> <span data-ttu-id="b8d50-117">La **compilazione** include il set di file di origine da compilare, i riferimenti agli assembly e le opzioni del compilatore.</span><span class="sxs-lookup"><span data-stu-id="b8d50-117">The **compilation** includes the set of source files to be compiled, assembly references, compiler options.</span></span> <span data-ttu-id="b8d50-118">È possibile ragionare sul significato del codice usando tutte le altre informazioni in questo contesto.</span><span class="sxs-lookup"><span data-stu-id="b8d50-118">You can reason about the meaning of the code using all the other information in this context.</span></span> <span data-ttu-id="b8d50-119"><xref:Microsoft.CodeAnalysis.Compilation> consente di trovare i **simboli**, ovvero entità come i tipi, gli spazi dei nomi, i membri e le variabili a cui fanno riferimento i nomi e altre espressioni.</span><span class="sxs-lookup"><span data-stu-id="b8d50-119">A <xref:Microsoft.CodeAnalysis.Compilation> allows you to find **Symbols** - entities such as types, namespaces, members, and variables which names and other expressions refer to.</span></span> <span data-ttu-id="b8d50-120">Il processo di associazione di nomi ed espressioni a **simboli** viene chiamato **associazione**.</span><span class="sxs-lookup"><span data-stu-id="b8d50-120">The process of associating names and expressions with **Symbols** is called **Binding**.</span></span>

<span data-ttu-id="b8d50-121">Come <xref:Microsoft.CodeAnalysis.SyntaxTree?displayProperty=nameWithType>, <xref:Microsoft.CodeAnalysis.Compilation> è una classe astratta con derivati specifici del linguaggio.</span><span class="sxs-lookup"><span data-stu-id="b8d50-121">Like <xref:Microsoft.CodeAnalysis.SyntaxTree?displayProperty=nameWithType>, <xref:Microsoft.CodeAnalysis.Compilation> is an abstract class with language-specific derivatives.</span></span> <span data-ttu-id="b8d50-122">Quando si crea un'istanza di Compilation, è necessario richiamare un metodo factory sulla classe <xref:Microsoft.CodeAnalysis.CSharp.CSharpCompilation?displayProperty=nameWithType> (o <xref:Microsoft.CodeAnalysis.VisualBasic.VisualBasicCompilation?displayProperty=nameWithType>).</span><span class="sxs-lookup"><span data-stu-id="b8d50-122">When creating an instance of Compilation, you must invoke a factory method on the <xref:Microsoft.CodeAnalysis.CSharp.CSharpCompilation?displayProperty=nameWithType> (or <xref:Microsoft.CodeAnalysis.VisualBasic.VisualBasicCompilation?displayProperty=nameWithType>) class.</span></span>

## <a name="querying-symbols"></a><span data-ttu-id="b8d50-123">Esecuzione di query sui simboli</span><span class="sxs-lookup"><span data-stu-id="b8d50-123">Querying symbols</span></span>

<span data-ttu-id="b8d50-124">In questa esercitazione, viene esaminato ancora una volta il programma "Hello World".</span><span class="sxs-lookup"><span data-stu-id="b8d50-124">In this tutorial, you look at the "Hello World" program again.</span></span> <span data-ttu-id="b8d50-125">In questo caso si esegue una query sui simboli nel programma per scoprire quali tipi rappresentano questi simboli.</span><span class="sxs-lookup"><span data-stu-id="b8d50-125">This time, you query the symbols in the program to understand what types those symbols represent.</span></span> <span data-ttu-id="b8d50-126">Verrà eseguita una query per recuperare i tipi in uno spazio dei nomi e si imparerà a trovare i metodi disponibili per un tipo.</span><span class="sxs-lookup"><span data-stu-id="b8d50-126">You query for the types in a namespace, and learn to find the methods available on a type.</span></span>

> [!IMPORTANT]
> <span data-ttu-id="b8d50-127">Per gli esempi seguenti è richiesta l'installazione di **.NET Compiler SDK** come parte di Visual Studio 2017.</span><span class="sxs-lookup"><span data-stu-id="b8d50-127">The following samples require the **.NET Compiler SDK** installed as part of Visual Studio 2017.</span></span> <span data-ttu-id="b8d50-128">È possibile trovare .NET Compiler SDK come ultimo componente facoltativo nell'elenco del carico di lavoro **Sviluppo di estensioni di Visual Studio**.</span><span class="sxs-lookup"><span data-stu-id="b8d50-128">You can find the .NET Compiler SDK as the last optional component listed under the **Visual Studio extension development** workload.</span></span> <span data-ttu-id="b8d50-129">I modelli non vengono installati senza questo componente.</span><span class="sxs-lookup"><span data-stu-id="b8d50-129">The templates aren't installed without this component.</span></span>

<span data-ttu-id="b8d50-130">È possibile visualizzare il codice completo per questo esempio nel [repository degli esempi di GitHub](https://github.com/dotnet/samples/csharp/roslyn-sdk/SemanticQuickStart).</span><span class="sxs-lookup"><span data-stu-id="b8d50-130">You can see the finished code for this sample in [our GitHub samples repository](https://github.com/dotnet/samples/csharp/roslyn-sdk/SemanticQuickStart).</span></span>

> [!NOTE]
> <span data-ttu-id="b8d50-131">I tipi di albero della sintassi usano l'ereditarietà per descrivere i diversi elementi della sintassi validi in posizioni diverse nel programma.</span><span class="sxs-lookup"><span data-stu-id="b8d50-131">The Syntax Tree types use inheritance to describe the different syntax elements that are valid at different locations in the program.</span></span> <span data-ttu-id="b8d50-132">L'uso di queste API spesso significa eseguire il cast di proprietà o membri di raccolte in tipi derivati specifici.</span><span class="sxs-lookup"><span data-stu-id="b8d50-132">Using these APIs often means casting properties or collection members to specific derived types.</span></span> <span data-ttu-id="b8d50-133">Negli esempi seguenti, l'assegnazione e i cast sono istruzioni separate, con variabili tipizzate in modo esplicito.</span><span class="sxs-lookup"><span data-stu-id="b8d50-133">In the following examples, the assignment and the casts are separate statements, using explicitly typed variables.</span></span> <span data-ttu-id="b8d50-134">È possibile leggere il codice per visualizzare i tipi restituiti dell'API e il tipo di runtime degli oggetti restituiti.</span><span class="sxs-lookup"><span data-stu-id="b8d50-134">You can read the code to see the return types of the API and the runtime type of the objects returned.</span></span> <span data-ttu-id="b8d50-135">In pratica, è più comune usare variabili tipizzate in modo implicito e basarsi sui nomi delle API per descrivere il tipo di oggetti in corso di analisi.</span><span class="sxs-lookup"><span data-stu-id="b8d50-135">In practice, it's more common to use implicitly typed variables and rely on API names to describe the type of objects being examined.</span></span>

<span data-ttu-id="b8d50-136">Creare un nuovo progetto C# **Stand-Alone Code Analysis Tool** (Strumento di analisi del codice autonomo):</span><span class="sxs-lookup"><span data-stu-id="b8d50-136">Create a new C# **Stand-Alone Code Analysis Tool** project:</span></span>

* <span data-ttu-id="b8d50-137">In Visual Studio scegliere **File** > **Nuovo** > **Progetto** per visualizzare la finestra di dialogo Nuovo progetto.</span><span class="sxs-lookup"><span data-stu-id="b8d50-137">In Visual Studio, choose **File** > **New** > **Project** to display the New Project dialog.</span></span>
* <span data-ttu-id="b8d50-138">In **Visual C#** > **Estendibilità** scegliere **Stand-Alone Code Analysis Tool** (Strumento di analisi del codice autonomo).</span><span class="sxs-lookup"><span data-stu-id="b8d50-138">Under **Visual C#** > **Extensibility**, choose **Stand-Alone Code Analysis Tool**.</span></span>
* <span data-ttu-id="b8d50-139">Denominare il progetto "**SemanticQuickStart**" e fare clic su OK.</span><span class="sxs-lookup"><span data-stu-id="b8d50-139">Name your project "**SemanticQuickStart**" and click OK.</span></span>

<span data-ttu-id="b8d50-140">Verrà analizzato il semplice programma "Hello World!"</span><span class="sxs-lookup"><span data-stu-id="b8d50-140">You're going to analyze the basic "Hello World!"</span></span> <span data-ttu-id="b8d50-141">mostrato in precedenza.</span><span class="sxs-lookup"><span data-stu-id="b8d50-141">program shown earlier.</span></span>
<span data-ttu-id="b8d50-142">Aggiungere il testo per il programma Hello World come costante nella classe `Program`:</span><span class="sxs-lookup"><span data-stu-id="b8d50-142">Add the text for the Hello World program as a constant in your `Program` class:</span></span>

[!code-csharp[Declare the program test](../../../../samples/csharp/roslyn-sdk/SemanticQuickStart/SemanticQuickStart/Program.cs#1 "Declare a constant string for the program text to analyze")]

<span data-ttu-id="b8d50-143">Aggiungere poi il codice seguente per creare l'albero della sintassi per il testo del codice nella costante `programText`.</span><span class="sxs-lookup"><span data-stu-id="b8d50-143">Next, add the following code to build the syntax tree for the code text in the `programText` constant.</span></span>  <span data-ttu-id="b8d50-144">Aggiungere la riga seguente al metodo `Main`:</span><span class="sxs-lookup"><span data-stu-id="b8d50-144">Add the following line to your `Main` method:</span></span>

[!code-csharp[Create the tree](../../../../samples/csharp/roslyn-sdk/SemanticQuickStart/SemanticQuickStart/Program.cs#2 "Create the syntax tree")]

<span data-ttu-id="b8d50-145">Compilare poi un'istanza di <xref:Microsoft.CodeAnalysis.CSharp.CSharpCompilation> dall'albero già creato.</span><span class="sxs-lookup"><span data-stu-id="b8d50-145">Next, build a <xref:Microsoft.CodeAnalysis.CSharp.CSharpCompilation> from the tree you already created.</span></span> <span data-ttu-id="b8d50-146">L'esempio "Hello World" si basa sui tipi <xref:System.String> e <xref:System.Console>.</span><span class="sxs-lookup"><span data-stu-id="b8d50-146">The "Hello World" sample relies on the <xref:System.String> and <xref:System.Console> types.</span></span> <span data-ttu-id="b8d50-147">È necessario fare riferimento all'assembly che dichiara i due tipi nella compilazione.</span><span class="sxs-lookup"><span data-stu-id="b8d50-147">You need to reference the assembly that declares those two types in your compilation.</span></span> <span data-ttu-id="b8d50-148">Aggiungere la riga seguente al metodo `Main` per creare una compilazione dell'albero della sintassi, incluso il riferimento all'assembly appropriato:</span><span class="sxs-lookup"><span data-stu-id="b8d50-148">Add the following line to your `Main` method to create a compilation of your syntax tree, including the reference to the appropriate assembly:</span></span>

[!code-csharp[Create the compilation](../../../../samples/csharp/roslyn-sdk/SemanticQuickStart/SemanticQuickStart/Program.cs#3 "Create the compilation for the semantic model")]

<span data-ttu-id="b8d50-149">Il metodo <xref:Microsoft.CodeAnalysis.CSharp.CSharpCompilation.AddReferences%2A?displayProperty=nameWithType> aggiunge i riferimenti alla compilazione.</span><span class="sxs-lookup"><span data-stu-id="b8d50-149">The <xref:Microsoft.CodeAnalysis.CSharp.CSharpCompilation.AddReferences%2A?displayProperty=nameWithType> method adds references to the compilation.</span></span> <span data-ttu-id="b8d50-150">Il metodo <xref:Microsoft.CodeAnalysis.MetadataReference.CreateFromFile(System.String,Microsoft.CodeAnalysis.MetadataReferenceProperties,Microsoft.CodeAnalysis.DocumentationProvider)> carica un assembly come riferimento.</span><span class="sxs-lookup"><span data-stu-id="b8d50-150">The <xref:Microsoft.CodeAnalysis.MetadataReference.CreateFromFile(System.String,Microsoft.CodeAnalysis.MetadataReferenceProperties,Microsoft.CodeAnalysis.DocumentationProvider)> method loads an assembly as a reference.</span></span> 

## <a name="querying-the-semantic-model"></a><span data-ttu-id="b8d50-151">Esecuzione di query sul modello semantico</span><span class="sxs-lookup"><span data-stu-id="b8d50-151">Querying the semantic model</span></span>

<span data-ttu-id="b8d50-152">Dopo aver creato un <xref:Microsoft.CodeAnalysis.Compilation> è possibile richiedere un <xref:Microsoft.CodeAnalysis.SemanticModel> per qualsiasi <xref:Microsoft.CodeAnalysis.SyntaxTree> contenuto in tale <xref:Microsoft.CodeAnalysis.Compilation>.</span><span class="sxs-lookup"><span data-stu-id="b8d50-152">Once you have a <xref:Microsoft.CodeAnalysis.Compilation> you can ask it for a <xref:Microsoft.CodeAnalysis.SemanticModel> for any <xref:Microsoft.CodeAnalysis.SyntaxTree> contained in that <xref:Microsoft.CodeAnalysis.Compilation>.</span></span> <span data-ttu-id="b8d50-153">È possibile considerare il modello semantico come fonte di tutte le informazioni che si ottengono in genere da IntelliSense.</span><span class="sxs-lookup"><span data-stu-id="b8d50-153">You can think of the semantic model as the source for all the information would normally get from intellisense.</span></span> <span data-ttu-id="b8d50-154">Un oggetto <xref:Microsoft.CodeAnalysis.SemanticModel> può rispondere a domande quali "Quali nomi sono nell'ambito in questa posizione?"</span><span class="sxs-lookup"><span data-stu-id="b8d50-154">A <xref:Microsoft.CodeAnalysis.SemanticModel> can answer questions like "What names are in scope at this location?"</span></span> <span data-ttu-id="b8d50-155">"Quali membri sono accessibili da questo metodo?"</span><span class="sxs-lookup"><span data-stu-id="b8d50-155">"What members are accessible from this method?"</span></span> <span data-ttu-id="b8d50-156">"Quali variabili vengono usate in questo blocco di testo?"</span><span class="sxs-lookup"><span data-stu-id="b8d50-156">"What variables are used in this block of text?"</span></span> <span data-ttu-id="b8d50-157">e "A cosa fa riferimento questo nome/espressione?"</span><span class="sxs-lookup"><span data-stu-id="b8d50-157">and "What does this name/expression refer to?"</span></span> <span data-ttu-id="b8d50-158">Aggiungere questa istruzione per creare il modello semantico:</span><span class="sxs-lookup"><span data-stu-id="b8d50-158">Add this statement to create the semantic model:</span></span>

[!code-csharp[Create the semantic model](../../../../samples/csharp/roslyn-sdk/SemanticQuickStart/SemanticQuickStart/Program.cs#4 "Create the semantic model")]

## <a name="binding-a-name"></a><span data-ttu-id="b8d50-159">Associazione di un nome</span><span class="sxs-lookup"><span data-stu-id="b8d50-159">Binding a name</span></span>

<span data-ttu-id="b8d50-160"><xref:Microsoft.CodeAnalysis.Compilation> crea <xref:Microsoft.CodeAnalysis.SemanticModel> da <xref:Microsoft.CodeAnalysis.SyntaxTree>.</span><span class="sxs-lookup"><span data-stu-id="b8d50-160">The <xref:Microsoft.CodeAnalysis.Compilation> creates the  <xref:Microsoft.CodeAnalysis.SemanticModel> from the <xref:Microsoft.CodeAnalysis.SyntaxTree>.</span></span> <span data-ttu-id="b8d50-161">Dopo aver creato il modello, è possibile eseguire query per trovare la prima direttiva `using` e recuperare informazioni sui simboli per lo spazio dei nomi `System`.</span><span class="sxs-lookup"><span data-stu-id="b8d50-161">After creating the model, you can query it to find the first `using` directive, and retrieve the symbol information for the `System` namespace.</span></span> <span data-ttu-id="b8d50-162">Aggiungere queste due righe al metodo `Main` per creare il modello semantico e recuperare il simbolo per la prima istruzione using:</span><span class="sxs-lookup"><span data-stu-id="b8d50-162">Add these two lines to your `Main` method to create the semantic model and retrieve the symbol for the first using statement:</span></span>

[!code-csharp[Find the namespace symbol for the first using](../../../../samples/csharp/roslyn-sdk/SemanticQuickStart/SemanticQuickStart/Program.cs#5 "Find the namespace symbol for the first using")]

<span data-ttu-id="b8d50-163">Il codice precedente mostra come ottenere un oggetto <xref:Microsoft.CodeAnalysis.SemanticModel> per <xref:Microsoft.CodeAnalysis.SyntaxTree> di HelloWorld.</span><span class="sxs-lookup"><span data-stu-id="b8d50-163">The preceding code shows how to obtain a <xref:Microsoft.CodeAnalysis.SemanticModel> object for your HelloWorld <xref:Microsoft.CodeAnalysis.SyntaxTree>.</span></span> <span data-ttu-id="b8d50-164">Dopo aver ottenuto il modello, il nome nella prima direttiva `using` viene associato per recuperare un <xref:Microsoft.CodeAnalysis.SymbolInfo?displayProperty=nameWithType> per lo spazio dei nomi `System`.</span><span class="sxs-lookup"><span data-stu-id="b8d50-164">Once the model is obtained, the name in the first `using` directive is bound to retrieve a <xref:Microsoft.CodeAnalysis.SymbolInfo?displayProperty=nameWithType> for the `System` namespace.</span></span> <span data-ttu-id="b8d50-165">Il codice precedente dimostra anche che si usa il **modello della sintassi** per trovare la struttura del codice e il **modello semantico** per comprenderne il significato.</span><span class="sxs-lookup"><span data-stu-id="b8d50-165">The preceding code also illustrates that you use the **syntax model** to find the structure of the code; you use the **semantic model** to understand its meaning.</span></span> <span data-ttu-id="b8d50-166">Il **modello della sintassi** individua la stringa `System` nell'istruzione using.</span><span class="sxs-lookup"><span data-stu-id="b8d50-166">The **syntax model** finds the string `System` in the using statement.</span></span> <span data-ttu-id="b8d50-167">Il **modello semantico** include tutte le informazioni sui tipi definiti nello spazio dei nomi `System`.</span><span class="sxs-lookup"><span data-stu-id="b8d50-167">The **semantic model** has all the information about the types defined in the `System` namespace.</span></span>

<span data-ttu-id="b8d50-168">Dall'oggetto <xref:Microsoft.CodeAnalysis.SymbolInfo> è possibile ottenere <xref:Microsoft.CodeAnalysis.ISymbol?displayProperty=nameWithType> usando la proprietà <xref:Microsoft.CodeAnalysis.SymbolInfo.Symbol?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="b8d50-168">From the <xref:Microsoft.CodeAnalysis.SymbolInfo> object you can obtain the <xref:Microsoft.CodeAnalysis.ISymbol?displayProperty=nameWithType> using the <xref:Microsoft.CodeAnalysis.SymbolInfo.Symbol?displayProperty=nameWithType> property.</span></span> <span data-ttu-id="b8d50-169">Questa proprietà restituisce il simbolo a cui fa riferimento questa espressione.</span><span class="sxs-lookup"><span data-stu-id="b8d50-169">This property returns the symbol this expression refers to.</span></span> <span data-ttu-id="b8d50-170">Per le espressioni che non fanno riferimento ad alcun elemento (ad esempio, i valori letterali numerici) questa proprietà è `null`.</span><span class="sxs-lookup"><span data-stu-id="b8d50-170">For expressions that don't refer to anything (such as numeric literals) this property is `null`.</span></span> <span data-ttu-id="b8d50-171">Quando <xref:Microsoft.CodeAnalysis.SymbolInfo.Symbol?displayProperty=nameWithType> non è null, <xref:Microsoft.CodeAnalysis.ISymbol.Kind?displayProperty=nameWithType> indica il tipo del simbolo.</span><span class="sxs-lookup"><span data-stu-id="b8d50-171">When the <xref:Microsoft.CodeAnalysis.SymbolInfo.Symbol?displayProperty=nameWithType> is not null, the <xref:Microsoft.CodeAnalysis.ISymbol.Kind?displayProperty=nameWithType> denotes the type of the symbol.</span></span> <span data-ttu-id="b8d50-172">In questo esempio, la proprietà <xref:Microsoft.CodeAnalysis.ISymbol.Kind?displayProperty=nameWithType> è un <xref:Microsoft.CodeAnalysis.SymbolKind.Namespace?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="b8d50-172">In this example, the <xref:Microsoft.CodeAnalysis.ISymbol.Kind?displayProperty=nameWithType> property is a <xref:Microsoft.CodeAnalysis.SymbolKind.Namespace?displayProperty=nameWithType>.</span></span> <span data-ttu-id="b8d50-173">Aggiungere il codice seguente al metodo `Main`.</span><span class="sxs-lookup"><span data-stu-id="b8d50-173">Add the following code to your `Main` method.</span></span> <span data-ttu-id="b8d50-174">Recupera il simbolo per lo spazio dei nomi `System` e quindi visualizza tutti gli spazi dei nomi figlio dichiarati nello spazio dei nomi `System`:</span><span class="sxs-lookup"><span data-stu-id="b8d50-174">It retrieves the symbol for the `System` namespace and then displays all the child namespaces declared in the `System` namespace:</span></span>

[!code-csharp[Display all the child namespaces](../../../../samples/csharp/roslyn-sdk/SemanticQuickStart/SemanticQuickStart/Program.cs#6 "Display all the child namespaces from this compilation")]

<span data-ttu-id="b8d50-175">Eseguire il programma. L'output dovrebbe essere il seguente:</span><span class="sxs-lookup"><span data-stu-id="b8d50-175">Run the program and you should see the following output:</span></span>

```
Collections
Configuration
Deployment
Diagnostics
Globalization
IO
Reflection
Resources
Runtime
Security
StubHelpers
Text
Threading
Press any key to continue . . .
```

> [!NOTE]
> <span data-ttu-id="b8d50-176">L'output non include ogni spazio dei nomi figlio dello spazio dei nomi `System`.</span><span class="sxs-lookup"><span data-stu-id="b8d50-176">The output does not include every namespace that is a child namespace of the `System` namespace.</span></span> <span data-ttu-id="b8d50-177">Viene visualizzato ogni spazio dei nomi presente in questa compilazione, che fa riferimento solo all'assembly in cui è dichiarato `System.String`.</span><span class="sxs-lookup"><span data-stu-id="b8d50-177">It displays every namespace that is present in this compilation, which only references the assembly where `System.String` is declared.</span></span> <span data-ttu-id="b8d50-178">Gli eventuali spazi dei nomi dichiarati in altri assembly non sono noti per questa compilazione</span><span class="sxs-lookup"><span data-stu-id="b8d50-178">Any namespaces declared in other assemblies are not known to this compilation</span></span>

### <a name="binding-an-expression"></a><span data-ttu-id="b8d50-179">Associazione di un'espressione</span><span class="sxs-lookup"><span data-stu-id="b8d50-179">Binding an expression</span></span>

<span data-ttu-id="b8d50-180">Il codice precedente mostra come trovare un simbolo mediante l'associazione a un nome.</span><span class="sxs-lookup"><span data-stu-id="b8d50-180">The preceding code shows how to find a symbol by binding to a name.</span></span> <span data-ttu-id="b8d50-181">Esistono altre espressioni in un programma C# che possono essere associate e non sono nomi.</span><span class="sxs-lookup"><span data-stu-id="b8d50-181">There are other expressions in a C# program that can be bound that aren't names.</span></span> <span data-ttu-id="b8d50-182">Per illustrare questa funzionalità, si esaminerà l'associazione a un semplice valore letterale stringa.</span><span class="sxs-lookup"><span data-stu-id="b8d50-182">To demonstrate this capability, let's access the binding to a simple string literal.</span></span>

<span data-ttu-id="b8d50-183">Il programma "Hello World" contiene un <xref:Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax?displayProperty=nameWithType>, ovvero la stringa "Hello, World!"</span><span class="sxs-lookup"><span data-stu-id="b8d50-183">The "Hello World" program contains a <xref:Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax?displayProperty=nameWithType>, the "Hello, World!"</span></span> <span data-ttu-id="b8d50-184">visualizzata nella console.</span><span class="sxs-lookup"><span data-stu-id="b8d50-184">string displayed to the console.</span></span>

<span data-ttu-id="b8d50-185">È possibile trovare la stringa "Hello, World!"</span><span class="sxs-lookup"><span data-stu-id="b8d50-185">You find the "Hello, World!"</span></span> <span data-ttu-id="b8d50-186">individuando il singolo valore letterale stringa nel programma.</span><span class="sxs-lookup"><span data-stu-id="b8d50-186">string by locating the single string literal in the program.</span></span> <span data-ttu-id="b8d50-187">Dopo aver individuato il nodo della sintassi, è possibile ottenere le informazioni sul tipo per tale nodo dal modello semantico.</span><span class="sxs-lookup"><span data-stu-id="b8d50-187">Then, once you've located the syntax node, get the type info for that node from the semantic model.</span></span> <span data-ttu-id="b8d50-188">Aggiungere il codice seguente al metodo `Main`:</span><span class="sxs-lookup"><span data-stu-id="b8d50-188">Add the following code to your `Main` method:</span></span>

[!code-csharp[Find the namespace symbol for the only using](../../../../samples/csharp/roslyn-sdk/SemanticQuickStart/SemanticQuickStart/Program.cs#7 "Find the namespace symbol for the only using")]

<span data-ttu-id="b8d50-189">Lo struct <xref:Microsoft.CodeAnalysis.TypeInfo?displayProperty=nameWithType> include una proprietà <xref:Microsoft.CodeAnalysis.TypeInfo.Type?displayProperty=nameWithType> che consente l'accesso alle informazioni semantiche sul tipo del valore letterale.</span><span class="sxs-lookup"><span data-stu-id="b8d50-189">The <xref:Microsoft.CodeAnalysis.TypeInfo?displayProperty=nameWithType> struct includes a <xref:Microsoft.CodeAnalysis.TypeInfo.Type?displayProperty=nameWithType> property that enables access to the semantic information about the type of the literal.</span></span> <span data-ttu-id="b8d50-190">In questo esempio, si tratta del tipo `string`.</span><span class="sxs-lookup"><span data-stu-id="b8d50-190">In this example, that's the `string` type.</span></span> <span data-ttu-id="b8d50-191">Aggiungere una dichiarazione che assegna questa proprietà a una variabile locale:</span><span class="sxs-lookup"><span data-stu-id="b8d50-191">Add a declaration that assigns this property to a local variable:</span></span>

[!code-csharp[Find the semantic information about the string type](../../../../samples/csharp/roslyn-sdk/SemanticQuickStart/SemanticQuickStart/Program.cs#8 "Use the string literal to access the semantic information in the string type.")]

<span data-ttu-id="b8d50-192">Per completare questa esercitazione, verrà definita una query LINQ che crea una sequenza di tutti i metodi pubblici dichiarati nel tipo `string` che restituiscono `string`.</span><span class="sxs-lookup"><span data-stu-id="b8d50-192">To finish this tutorial, let's build a LINQ query that creates a sequence of all the public methods declared on the `string` type that return a `string`.</span></span> <span data-ttu-id="b8d50-193">Questa query diventa complessa, quindi viene creata riga per riga per poi essere ricostruita come singola query.</span><span class="sxs-lookup"><span data-stu-id="b8d50-193">This query gets complex, so let's build it line by line, then reconstruct it as a single query.</span></span> <span data-ttu-id="b8d50-194">L'origine per questa query è la sequenza di tutti i membri dichiarati nel tipo `string`:</span><span class="sxs-lookup"><span data-stu-id="b8d50-194">The source for this query is the sequence of all members declared on the `string` type:</span></span>

[!code-csharp[Access the sequence of members on the string type](../../../../samples/csharp/roslyn-sdk/SemanticQuickStart/SemanticQuickStart/Program.cs#9 "Access the sequence of members on the string type.")]

<span data-ttu-id="b8d50-195">Questa sequenza di origine contiene tutti i membri, incluse le proprietà e i campi, quindi filtrarla tramite il metodo <xref:System.Collections.Immutable.ImmutableArray%601.OfType%2A?displayProperty=nameWithType> per trovare gli elementi corrispondenti a oggetti <xref:Microsoft.CodeAnalysis.IMethodSymbol?diplayProperty=nameWithType>:</span><span class="sxs-lookup"><span data-stu-id="b8d50-195">That source sequence conatins all members, including properties and fields, so filter it using the <xref:System.Collections.Immutable.ImmutableArray%601.OfType%2A?displayProperty=nameWithType> method to find elements that are <xref:Microsoft.CodeAnalysis.IMethodSymbol?diplayProperty=nameWithType> objects:</span></span>

[!code-csharp[Filter the sequence to only methods](../../../../samples/csharp/roslyn-sdk/SemanticQuickStart/SemanticQuickStart/Program.cs#10 "Find the subset of the collection that is the methods.")]

<span data-ttu-id="b8d50-196">Aggiungere poi un altro filtro per restituire solo i metodi pubblici che restituiscono `string`:</span><span class="sxs-lookup"><span data-stu-id="b8d50-196">Next, add another filter to return only those methods that are public and return a `string`:</span></span>

[!code-csharp[Filter on return type and accessibility](../../../../samples/csharp/roslyn-sdk/SemanticQuickStart/SemanticQuickStart/Program.cs#11 "Find only the public methods that return a string.")]

<span data-ttu-id="b8d50-197">Selezionare solo la proprietà del nome e solo i nomi distinti rimuovendo qualsiasi overload:</span><span class="sxs-lookup"><span data-stu-id="b8d50-197">Select only the name property, and only distinct names by removing any overloads:</span></span>

[!code-csharp[find the distinct names.](../../../../samples/csharp/roslyn-sdk/SemanticQuickStart/SemanticQuickStart/Program.cs#12 "Use the string literal to access the semantic information in the string type.")]

<span data-ttu-id="b8d50-198">È anche possibile creare la query completa usando la sintassi di query LINQ e quindi visualizzare tutti i nomi di metodo nella console:</span><span class="sxs-lookup"><span data-stu-id="b8d50-198">You can also build the full query using the LINQ query syntax, and then display all the method names in  the console:</span></span>

[!code-csharp[build and display the results of this query.](../../../../samples/csharp/roslyn-sdk/SemanticQuickStart/SemanticQuickStart/Program.cs#12 "Build and display the results of the query.")]

<span data-ttu-id="b8d50-199">Compilare ed eseguire il programma.</span><span class="sxs-lookup"><span data-stu-id="b8d50-199">Build and run the program.</span></span> <span data-ttu-id="b8d50-200">È necessario visualizzare il seguente output:</span><span class="sxs-lookup"><span data-stu-id="b8d50-200">You should see the following output:</span></span>

```
Join
Substring
Trim
TrimStart
TrimEnd
Normalize
PadLeft
PadRight
ToLower
ToLowerInvariant
ToUpper
ToUpperInvariant
ToString
Insert
Replace
Remove
Format
Copy
Concat
Intern
IsInterned
Press any key to continue . . .
```
<span data-ttu-id="b8d50-201">È stata usata l'API Semantic per trovare e visualizzare informazioni sui simboli che fanno parte di questo programma.</span><span class="sxs-lookup"><span data-stu-id="b8d50-201">You've used the Semantic API to find and display information about the symbols that are part of this program.</span></span>
