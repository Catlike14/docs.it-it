---
title: Classi e oggetti in C# - Panoramica del linguaggio C#
description: "Introduzione a C# Leggere questa panoramica su classi, oggetti ed ereditarietà"
keywords: ".NET, csharp, classe, istanza, oggetto, ereditarietà, polimorfismo"
author: BillWagner
ms.author: wiwagn
ms.date: 08/10/2016
ms.topic: article
ms.prod: .net
ms.technology: devlang-csharp
ms.devlang: csharp
ms.assetid: 63a89bde-0f05-4bc4-b0cd-4f693854f0cd
ms.openlocfilehash: 97559a6e7b24f4a61b49dd4f050747a6d0ccbda0
ms.sourcegitcommit: d95a91d685565f4d95c8773b558752864a6a3d7e
ms.translationtype: HT
ms.contentlocale: it-IT
ms.lasthandoff: 03/12/2018
---
# <a name="classes-and-objects"></a><span data-ttu-id="e87f0-105">Classi e oggetti</span><span class="sxs-lookup"><span data-stu-id="e87f0-105">Classes and objects</span></span>

<span data-ttu-id="e87f0-106">Le *classi* sono il tipo C# più importante.</span><span class="sxs-lookup"><span data-stu-id="e87f0-106">*Classes* are the most fundamental of C#’s types.</span></span> <span data-ttu-id="e87f0-107">Una classe è una struttura di dati che combina in una singola unità lo stato (campi) e le azioni (metodi e altri membri di funzione).</span><span class="sxs-lookup"><span data-stu-id="e87f0-107">A class is a data structure that combines state (fields) and actions (methods and other function members) in a single unit.</span></span> <span data-ttu-id="e87f0-108">Una classe fornisce una definizione per *istanze* della classe create dinamicamente, note anche come *oggetti*.</span><span class="sxs-lookup"><span data-stu-id="e87f0-108">A class provides a definition for dynamically created *instances* of the class, also known as *objects*.</span></span> <span data-ttu-id="e87f0-109">Le classi supportano l'*ereditarietà* e il *polimorfismo*, meccanismi in base ai quali le *classi derivate* possono estendere e specializzare le *classi di base*.</span><span class="sxs-lookup"><span data-stu-id="e87f0-109">Classes support *inheritance* and *polymorphism*, mechanisms whereby *derived classes* can extend and specialize *base classes*.</span></span>

<span data-ttu-id="e87f0-110">Le nuove classi vengono create tramite dichiarazioni di classe.</span><span class="sxs-lookup"><span data-stu-id="e87f0-110">New classes are created using class declarations.</span></span> <span data-ttu-id="e87f0-111">Una dichiarazione di classe inizia con un'intestazione che specifica gli attributi e i modificatori della classe, il nome della classe, la classe di base (se disponibile) e le interfacce implementate dalla classe.</span><span class="sxs-lookup"><span data-stu-id="e87f0-111">A class declaration starts with a header that specifies the attributes and modifiers of the class, the name of the class, the base class (if given), and the interfaces implemented by the class.</span></span> <span data-ttu-id="e87f0-112">L'intestazione è seguita dal corpo della classe, costituito da un elenco di dichiarazioni di membro scritte tra i delimitatori `{` e `}`.</span><span class="sxs-lookup"><span data-stu-id="e87f0-112">The header is followed by the class body, which consists of a list of member declarations written between the delimiters `{` and `}`.</span></span>

<span data-ttu-id="e87f0-113">Di seguito è riportata una dichiarazione di una classe semplice denominata `Point`:</span><span class="sxs-lookup"><span data-stu-id="e87f0-113">The following is a declaration of a simple class named `Point`:</span></span>

[!code-csharp[PointClass](../../../samples/snippets/csharp/tour/classes-and-objects/Point.cs#L3-L11)]

<span data-ttu-id="e87f0-114">Le istanze delle classi vengono create usando l'operatore `new`, che alloca memoria per una nuova istanza, richiama un costruttore per inizializzare l'istanza e restituisce un riferimento all'istanza.</span><span class="sxs-lookup"><span data-stu-id="e87f0-114">Instances of classes are created using the `new` operator, which allocates memory for a new instance, invokes a constructor to initialize the instance, and returns a reference to the instance.</span></span> <span data-ttu-id="e87f0-115">Le istruzioni seguenti creano due oggetti Point e archiviano i riferimenti agli oggetti in due variabili:</span><span class="sxs-lookup"><span data-stu-id="e87f0-115">The following statements create two Point objects and store references to those objects in two variables:</span></span>

[!code-csharp[PointExample](../../../samples/snippets/csharp/tour/classes-and-objects/Program.cs#L9-L10)]

<span data-ttu-id="e87f0-116">La memoria occupata da un oggetto viene automaticamente recuperata nel momento in cui l'oggetto non è più raggiungibile.</span><span class="sxs-lookup"><span data-stu-id="e87f0-116">The memory occupied by an object is automatically reclaimed when the object is no longer reachable.</span></span> <span data-ttu-id="e87f0-117">In C# non è possibile, né necessario, deallocare oggetti in modo esplicito.</span><span class="sxs-lookup"><span data-stu-id="e87f0-117">It is neither necessary nor possible to explicitly deallocate objects in C#.</span></span>

## <a name="members"></a><span data-ttu-id="e87f0-118">Membri</span><span class="sxs-lookup"><span data-stu-id="e87f0-118">Members</span></span>

<span data-ttu-id="e87f0-119">I membri di una classe possono essere membri statici o membri di istanza.</span><span class="sxs-lookup"><span data-stu-id="e87f0-119">The members of a class are either static members or instance members.</span></span> <span data-ttu-id="e87f0-120">I primi appartengono a classi, mentre i secondi appartengono a oggetti, ovvero a istanze di classi.</span><span class="sxs-lookup"><span data-stu-id="e87f0-120">Static members belong to classes, and instance members belong to objects (instances of classes).</span></span>

<span data-ttu-id="e87f0-121">Di seguito viene fornita una panoramica dei tipi di membri che può contenere una classe.</span><span class="sxs-lookup"><span data-stu-id="e87f0-121">The following provides an overview of the kinds of members a class can contain.</span></span>

* <span data-ttu-id="e87f0-122">Costanti</span><span class="sxs-lookup"><span data-stu-id="e87f0-122">Constants</span></span>
    - <span data-ttu-id="e87f0-123">Valori costanti associati alla classe</span><span class="sxs-lookup"><span data-stu-id="e87f0-123">Constant values associated with the class</span></span>
* <span data-ttu-id="e87f0-124">Campi</span><span class="sxs-lookup"><span data-stu-id="e87f0-124">Fields</span></span>
    - <span data-ttu-id="e87f0-125">Variabili della classe</span><span class="sxs-lookup"><span data-stu-id="e87f0-125">Variables of the class</span></span>
* <span data-ttu-id="e87f0-126">Metodi</span><span class="sxs-lookup"><span data-stu-id="e87f0-126">Methods</span></span>
    - <span data-ttu-id="e87f0-127">Calcoli e azioni che possono essere eseguiti dalla classe</span><span class="sxs-lookup"><span data-stu-id="e87f0-127">Computations and actions that can be performed by the class</span></span>
* <span data-ttu-id="e87f0-128">Proprietà</span><span class="sxs-lookup"><span data-stu-id="e87f0-128">Properties</span></span>
    - <span data-ttu-id="e87f0-129">Azioni associate alla lettura e alla scrittura di proprietà denominate della classe</span><span class="sxs-lookup"><span data-stu-id="e87f0-129">Actions associated with reading and writing named properties of the class</span></span>
* <span data-ttu-id="e87f0-130">Indicizzatori</span><span class="sxs-lookup"><span data-stu-id="e87f0-130">Indexers</span></span>
    - <span data-ttu-id="e87f0-131">Azioni associate all'indicizzazione di istanze della classe, come una matrice</span><span class="sxs-lookup"><span data-stu-id="e87f0-131">Actions associated with indexing instances of the class like an array</span></span>
* <span data-ttu-id="e87f0-132">Eventi</span><span class="sxs-lookup"><span data-stu-id="e87f0-132">Events</span></span>
    - <span data-ttu-id="e87f0-133">Notifiche che possono essere generate dalla classe</span><span class="sxs-lookup"><span data-stu-id="e87f0-133">Notifications that can be generated by the class</span></span>
* <span data-ttu-id="e87f0-134">Operatori</span><span class="sxs-lookup"><span data-stu-id="e87f0-134">Operators</span></span>
    - <span data-ttu-id="e87f0-135">Conversioni e operatori di espressione supportati dalla classe</span><span class="sxs-lookup"><span data-stu-id="e87f0-135">Conversions and expression operators supported by the class</span></span>
* <span data-ttu-id="e87f0-136">Costruttori</span><span class="sxs-lookup"><span data-stu-id="e87f0-136">Constructors</span></span>
    - <span data-ttu-id="e87f0-137">Azioni necessarie per inizializzare istanze della classe o la classe stessa</span><span class="sxs-lookup"><span data-stu-id="e87f0-137">Actions required to initialize instances of the class or the class itself</span></span>
* <span data-ttu-id="e87f0-138">Finalizzatori</span><span class="sxs-lookup"><span data-stu-id="e87f0-138">Finalizers</span></span>
    - <span data-ttu-id="e87f0-139">Azioni da eseguire prima che istanze della classe vengano eliminate in modo permanente</span><span class="sxs-lookup"><span data-stu-id="e87f0-139">Actions to perform before instances of the class are permanently discarded</span></span>
* <span data-ttu-id="e87f0-140">Tipi</span><span class="sxs-lookup"><span data-stu-id="e87f0-140">Types</span></span>
    - <span data-ttu-id="e87f0-141">Tipi annidati dichiarati dalla classe</span><span class="sxs-lookup"><span data-stu-id="e87f0-141">Nested types declared by the class</span></span>

## <a name="accessibility"></a><span data-ttu-id="e87f0-142">Accessibilità</span><span class="sxs-lookup"><span data-stu-id="e87f0-142">Accessibility</span></span>

<span data-ttu-id="e87f0-143">A ogni membro di una classe è associata una caratteristica di accessibilità, che controlla le aree di testo del programma in grado di accedere al membro.</span><span class="sxs-lookup"><span data-stu-id="e87f0-143">Each member of a class has an associated accessibility, which controls the regions of program text that are able to access the member.</span></span> <span data-ttu-id="e87f0-144">Esistono cinque diverse forme di accessibilità,</span><span class="sxs-lookup"><span data-stu-id="e87f0-144">There are five possible forms of accessibility.</span></span> <span data-ttu-id="e87f0-145">riepilogate nella tabella seguente.</span><span class="sxs-lookup"><span data-stu-id="e87f0-145">These are summarized below.</span></span>

* `public`
    - <span data-ttu-id="e87f0-146">Accesso non limitato</span><span class="sxs-lookup"><span data-stu-id="e87f0-146">Access not limited</span></span>
* `protected`
    - <span data-ttu-id="e87f0-147">Accesso limitato a questa classe o alle classi derivate da questa classe</span><span class="sxs-lookup"><span data-stu-id="e87f0-147">Access limited to this class or classes derived from this class</span></span>
* `internal`
    - <span data-ttu-id="e87f0-148">Accesso limitato all'assembly corrente (file EXE, file DLL e cosi via.)</span><span class="sxs-lookup"><span data-stu-id="e87f0-148">Access limited to the current assembly (.exe, .dll, etc.)</span></span>
* `protected internal`
    - <span data-ttu-id="e87f0-149">Accesso limitato alla classe principale o alle classi derivate dalla classe principale</span><span class="sxs-lookup"><span data-stu-id="e87f0-149">Access limited to the containing class or classes derived from the containing class</span></span>
* `private`
    - <span data-ttu-id="e87f0-150">Accesso limitato a questa classe</span><span class="sxs-lookup"><span data-stu-id="e87f0-150">Access limited to this class</span></span>
* `private protected`
    - <span data-ttu-id="e87f0-151">Accesso limitato alla classe principale o alle classi derivate dal tipo principale all'interno dello stesso assembly</span><span class="sxs-lookup"><span data-stu-id="e87f0-151">Access limited to the containing class or classes derived from the containing type within the same assembly</span></span>

## <a name="type-parameters"></a><span data-ttu-id="e87f0-152">Parametri di tipo</span><span class="sxs-lookup"><span data-stu-id="e87f0-152">Type parameters</span></span>

<span data-ttu-id="e87f0-153">Una definizione di classe può specificare un set di parametri di tipo se si fa seguire il nome della classe da un elenco di nomi di parametri di tipo, racchiuso tra parentesi uncinate.</span><span class="sxs-lookup"><span data-stu-id="e87f0-153">A class definition may specify a set of type parameters by following the class name with angle brackets enclosing a list of type parameter names.</span></span> <span data-ttu-id="e87f0-154">I parametri di tipo possono essere quindi usati nel corpo delle dichiarazioni di classe per definire i membri della classe.</span><span class="sxs-lookup"><span data-stu-id="e87f0-154">The type parameters can then be used in the body of the class declarations to define the members of the class.</span></span> <span data-ttu-id="e87f0-155">Nell'esempio seguente i parametri di tipo di `Pair` sono `TFirst` e `TSecond`:</span><span class="sxs-lookup"><span data-stu-id="e87f0-155">In the following example, the type parameters of `Pair` are `TFirst` and `TSecond`:</span></span>

[!code-csharp[Pair](../../../samples/snippets/csharp/tour/classes-and-objects/Pair.cs#L3-L7)]

<span data-ttu-id="e87f0-156">Un tipo di classe dichiarato per accettare parametri di tipo prende il nome di *tipo di classe generico*.</span><span class="sxs-lookup"><span data-stu-id="e87f0-156">A class type that is declared to take type parameters is called a *generic class type*.</span></span> <span data-ttu-id="e87f0-157">Possono essere generici anche i tipi struct, interfaccia e delegato.</span><span class="sxs-lookup"><span data-stu-id="e87f0-157">Struct, interface and delegate types can also be generic.</span></span>
<span data-ttu-id="e87f0-158">Quando si usa la classe generica, è necessario specificare argomenti di tipo per ogni parametro di tipo:</span><span class="sxs-lookup"><span data-stu-id="e87f0-158">When the generic class is used, type arguments must be provided for each of the type parameters:</span></span>

[!code-csharp[PairExample](../../../samples/snippets/csharp/tour/classes-and-objects/Program.cs#L15-L17)]

<span data-ttu-id="e87f0-159">Un tipo generico per il quale sono stati specificati argomenti di tipo, come `Pair<int,string>` nell'esempio precedente, prende il nome di *tipo costruito*.</span><span class="sxs-lookup"><span data-stu-id="e87f0-159">A generic type with type arguments provided, like `Pair<int,string>` above, is called a *constructed type*.</span></span>

## <a name="base-classes"></a><span data-ttu-id="e87f0-160">Classi di base</span><span class="sxs-lookup"><span data-stu-id="e87f0-160">Base classes</span></span>

<span data-ttu-id="e87f0-161">Una dichiarazione di classe può specificare una classe di base se si fa seguire il nome della classe e i parametri di tipo dai due punti e dal nome della classe di base.</span><span class="sxs-lookup"><span data-stu-id="e87f0-161">A class declaration may specify a base class by following the class name and type parameters with a colon and the name of the base class.</span></span> <span data-ttu-id="e87f0-162">L'omissione della specifica della classe di base equivale alla derivazione dal tipo `object`.</span><span class="sxs-lookup"><span data-stu-id="e87f0-162">Omitting a base class specification is the same as deriving from type `object`.</span></span> <span data-ttu-id="e87f0-163">Nell'esempio seguente la classe di base di `Point3D` è `Point` e quella di `Point` è `object`:</span><span class="sxs-lookup"><span data-stu-id="e87f0-163">In the following example, the base class of `Point3D` is `Point`, and the base class of `Point` is `object`:</span></span>

[!code-csharp[Point3DClass](../../../samples/snippets/csharp/tour/classes-and-objects/Point.cs#L3-L20)]

<span data-ttu-id="e87f0-164">Una classe eredita i membri della relativa classe di base.</span><span class="sxs-lookup"><span data-stu-id="e87f0-164">A class inherits the members of its base class.</span></span> <span data-ttu-id="e87f0-165">L'ereditarietà prevede che una classe contenga in modo implicito tutti i membri della relativa classe di base (ad eccezione dell'istanza e dei costruttori statici) e i relativi finalizzatori.</span><span class="sxs-lookup"><span data-stu-id="e87f0-165">Inheritance means that a class implicitly contains all members of its base class, except for the instance and static constructors, and the finalizers of the base class.</span></span> <span data-ttu-id="e87f0-166">Una classe derivata può aggiungere nuovi membri a quelli ereditati, ma non può rimuovere la definizione di un membro ereditato.</span><span class="sxs-lookup"><span data-stu-id="e87f0-166">A derived class can add new members to those it inherits, but it cannot remove the definition of an inherited member.</span></span> <span data-ttu-id="e87f0-167">Nell'esempio precedente `Point3D` eredita i campi `x` e `y` da `Point` e ogni istanza di `Point3D` contiene tre campi: `x`, `y` e `z`.</span><span class="sxs-lookup"><span data-stu-id="e87f0-167">In the previous example, `Point3D` inherits the `x` and `y` fields from `Point`, and every `Point3D` instance contains three fields, `x`, `y`, and `z`.</span></span>

<span data-ttu-id="e87f0-168">Un tipo di classe viene implicitamente convertito in uno dei relativi tipi di classe di base.</span><span class="sxs-lookup"><span data-stu-id="e87f0-168">An implicit conversion exists from a class type to any of its base class types.</span></span> <span data-ttu-id="e87f0-169">Una variabile di un tipo di classe, quindi, può fare riferimento a un'istanza della classe o a un'istanza di una classe derivata.</span><span class="sxs-lookup"><span data-stu-id="e87f0-169">Therefore, a variable of a class type can reference an instance of that class or an instance of any derived class.</span></span> <span data-ttu-id="e87f0-170">Nel caso delle dichiarazioni di classe precedenti, ad esempio, una variabile di tipo `Point` può fare riferimento a `Point` o `Point3D`:</span><span class="sxs-lookup"><span data-stu-id="e87f0-170">For example, given the previous class declarations, a variable of type `Point` can reference either a `Point` or a `Point3D`:</span></span>

[!code-csharp[Point3DExample](../../../samples/snippets/csharp/tour/classes-and-objects/Program.cs#L22-L23)]

## <a name="fields"></a><span data-ttu-id="e87f0-171">Campi</span><span class="sxs-lookup"><span data-stu-id="e87f0-171">Fields</span></span>

<span data-ttu-id="e87f0-172">Un *campo* è una variabile associata a una classe o a un'istanza di una classe.</span><span class="sxs-lookup"><span data-stu-id="e87f0-172">A *field* is a variable that is associated with a class or with an instance of a class.</span></span>

<span data-ttu-id="e87f0-173">Un campo dichiarato con il modificatore static definisce un campo statico,</span><span class="sxs-lookup"><span data-stu-id="e87f0-173">A field declared with the static modifier defines a static field.</span></span> <span data-ttu-id="e87f0-174">che identifica esattamente una posizione di memoria.</span><span class="sxs-lookup"><span data-stu-id="e87f0-174">A static field identifies exactly one storage location.</span></span> <span data-ttu-id="e87f0-175">Indipendentemente dal numero di istanze di una classe create, esiste una sola copia di un campo statico.</span><span class="sxs-lookup"><span data-stu-id="e87f0-175">No matter how many instances of a class are created, there is only ever one copy of a static field.</span></span>

<span data-ttu-id="e87f0-176">Un campo dichiarato senza il modificatore static definisce un campo di istanza.</span><span class="sxs-lookup"><span data-stu-id="e87f0-176">A field declared without the static modifier defines an instance field.</span></span> <span data-ttu-id="e87f0-177">Ogni istanza di una classe contiene una copia separata di tutti i campi di istanza della classe.</span><span class="sxs-lookup"><span data-stu-id="e87f0-177">Every instance of a class contains a separate copy of all the instance fields of that class.</span></span>

<span data-ttu-id="e87f0-178">Nell'esempio seguente ogni istanza della classe `Color` include una copia distinta dei campi di istanza `r`, `g` e `b`, mentre esiste una sola copia dei campi statici `Black`, `White`, `Red`, `Green` e `Blue`.</span><span class="sxs-lookup"><span data-stu-id="e87f0-178">In the following example, each instance of the `Color` class has a separate copy of the `r`, `g`, and `b` instance fields, but there is only one copy of the `Black`, `White`, `Red`, `Green`, and `Blue` static fields:</span></span>

[!code-csharp[ColorClass](../../../samples/snippets/csharp/tour/classes-and-objects/Color.cs#L3-L17)]

<span data-ttu-id="e87f0-179">Come illustrato nell'esempio precedente, i *campi di sola lettura* possono essere dichiarati con un modificatore `readonly`.</span><span class="sxs-lookup"><span data-stu-id="e87f0-179">As shown in the previous example, *read-only fields* may be declared with a `readonly` modifier.</span></span> <span data-ttu-id="e87f0-180">L'assegnazione a un campo `readonly` può avvenire solo nell'ambito della dichiarazione del campo o in un costruttore della stessa classe.</span><span class="sxs-lookup"><span data-stu-id="e87f0-180">Assignment to a `readonly` field can only occur as part of the field’s declaration or in a constructor in the same class.</span></span>

## <a name="methods"></a><span data-ttu-id="e87f0-181">Metodi</span><span class="sxs-lookup"><span data-stu-id="e87f0-181">Methods</span></span>

<span data-ttu-id="e87f0-182">Un *metodo* è un membro che implementa un calcolo o un'azione che può essere eseguita da un oggetto o una classe.</span><span class="sxs-lookup"><span data-stu-id="e87f0-182">A *method* is a member that implements a computation or action that can be performed by an object or class.</span></span> <span data-ttu-id="e87f0-183">I *metodi statici* sono accessibili tramite la classe,</span><span class="sxs-lookup"><span data-stu-id="e87f0-183">*Static methods* are accessed through the class.</span></span> <span data-ttu-id="e87f0-184">mentre i *metodi di istanza* sono accessibili tramite istanze della classe.</span><span class="sxs-lookup"><span data-stu-id="e87f0-184">*Instance methods* are accessed through instances of the class.</span></span>

<span data-ttu-id="e87f0-185">I metodi possono avere un elenco di *parametri*, che rappresentano valori o riferimenti a variabili passati al metodo, e un *tipo restituito*, che specifica il tipo di valore calcolato e restituito dal metodo.</span><span class="sxs-lookup"><span data-stu-id="e87f0-185">Methods may have a list of *parameters*, which represent values or variable references passed to the method, and a *return type*, which specifies the type of the value computed and returned by the method.</span></span> <span data-ttu-id="e87f0-186">Il tipo restituito da un metodo è `void` se non viene restituito un valore.</span><span class="sxs-lookup"><span data-stu-id="e87f0-186">A method’s return type is `void` if it does not return a value.</span></span>

<span data-ttu-id="e87f0-187">Come i tipi, anche i metodi possono avere un set di parametri di tipo per i quali è necessario specificare argomenti di tipo quando vengono chiamati.</span><span class="sxs-lookup"><span data-stu-id="e87f0-187">Like types, methods may also have a set of type parameters, for which type arguments must be specified when the method is called.</span></span> <span data-ttu-id="e87f0-188">A differenza dei tipi, gli argomenti di tipo possono essere spesso dedotti dagli argomenti di una chiamata al metodo e non devono essere assegnati in modo esplicito.</span><span class="sxs-lookup"><span data-stu-id="e87f0-188">Unlike types, the type arguments can often be inferred from the arguments of a method call and need not be explicitly given.</span></span>

<span data-ttu-id="e87f0-189">La *firma* di un metodo deve essere univoca nell'ambito della classe in cui viene dichiarato il metodo.</span><span class="sxs-lookup"><span data-stu-id="e87f0-189">The *signature* of a method must be unique in the class in which the method is declared.</span></span> <span data-ttu-id="e87f0-190">La firma di un metodo è costituita dal nome del metodo, dal numero di parametri di tipo e dal numero, dai modificatori e dai tipi dei rispettivi parametri.</span><span class="sxs-lookup"><span data-stu-id="e87f0-190">The signature of a method consists of the name of the method, the number of type parameters and the number, modifiers, and types of its parameters.</span></span> <span data-ttu-id="e87f0-191">Nella firma di un metodo non è incluso il tipo restituito.</span><span class="sxs-lookup"><span data-stu-id="e87f0-191">The signature of a method does not include the return type.</span></span>

### <a name="parameters"></a><span data-ttu-id="e87f0-192">Parametri</span><span class="sxs-lookup"><span data-stu-id="e87f0-192">Parameters</span></span>

<span data-ttu-id="e87f0-193">I parametri consentono di passare ai metodi valori o riferimenti a variabili.</span><span class="sxs-lookup"><span data-stu-id="e87f0-193">Parameters are used to pass values or variable references to methods.</span></span> <span data-ttu-id="e87f0-194">I parametri di un metodo ottengono i valori effettivi dagli *argomenti* specificati quando viene richiamato il metodo.</span><span class="sxs-lookup"><span data-stu-id="e87f0-194">The parameters of a method get their actual values from the *arguments* that are specified when the method is invoked.</span></span> <span data-ttu-id="e87f0-195">Esistono quattro tipi di parametri: parametri di valore, parametri di riferimento, i parametri di output e matrici di parametri.</span><span class="sxs-lookup"><span data-stu-id="e87f0-195">There are four kinds of parameters: value parameters, reference parameters, output parameters, and parameter arrays.</span></span>

<span data-ttu-id="e87f0-196">Un *parametro di valore* viene usato per passare argomenti di input.</span><span class="sxs-lookup"><span data-stu-id="e87f0-196">A *value parameter* is used for passing input arguments.</span></span> <span data-ttu-id="e87f0-197">Corrisponde a una variabile locale che ottiene il valore iniziale dall'argomento passato per il parametro.</span><span class="sxs-lookup"><span data-stu-id="e87f0-197">A value parameter corresponds to a local variable that gets its initial value from the argument that was passed for the parameter.</span></span> <span data-ttu-id="e87f0-198">Eventuali modifiche a un parametro di valore non interessano l'argomento passato per il parametro.</span><span class="sxs-lookup"><span data-stu-id="e87f0-198">Modifications to a value parameter do not affect the argument that was passed for the parameter.</span></span> 

<span data-ttu-id="e87f0-199">I parametri di valore possono essere facoltativi specificando un valore predefinito. In questo caso gli argomenti corrispondenti possono essere omessi.</span><span class="sxs-lookup"><span data-stu-id="e87f0-199">Value parameters can be optional, by specifying a default value so that corresponding arguments can be omitted.</span></span>

<span data-ttu-id="e87f0-200">Un *parametro di riferimento* viene usato per passare argomenti per riferimento.</span><span class="sxs-lookup"><span data-stu-id="e87f0-200">A *reference parameter* is used for passing arguments by reference.</span></span> <span data-ttu-id="e87f0-201">L'argomento passato per un parametro di riferimento deve essere una variabile con un valore definito e, durante l'esecuzione del metodo, il parametro di riferimento rappresenta lo stesso percorso di archiviazione della variabile di argomento.</span><span class="sxs-lookup"><span data-stu-id="e87f0-201">The argument passed for a reference parameter must be a variable with a definite value, and during execution of the method, the reference parameter represents the same storage location as the argument variable.</span></span> <span data-ttu-id="e87f0-202">Un parametro di riferimento viene dichiarato con il modificatore `ref`.</span><span class="sxs-lookup"><span data-stu-id="e87f0-202">A reference parameter is declared with the `ref` modifier.</span></span> <span data-ttu-id="e87f0-203">Nell'esempio seguente viene illustrato l'uso di parametri `ref`.</span><span class="sxs-lookup"><span data-stu-id="e87f0-203">The following example shows the use of `ref` parameters.</span></span>

[!code-csharp[swapExample](../../../samples/snippets/csharp/tour/classes-and-objects/RefExample.cs#L3-L18)]

<span data-ttu-id="e87f0-204">Un *parametro di output* viene usato per passare argomenti per riferimento.</span><span class="sxs-lookup"><span data-stu-id="e87f0-204">An *output parameter* is used for passing arguments by reference.</span></span> <span data-ttu-id="e87f0-205">È simile a un parametro di riferimento, ad eccezione del fatto che non è necessario assegnare in modo esplicito un valore per l'argomento specificato dal chiamante.</span><span class="sxs-lookup"><span data-stu-id="e87f0-205">It's similar to a reference parameter, except that it doesn't require that you explicitly assign a value to the caller-provided argument.</span></span> <span data-ttu-id="e87f0-206">Un parametro di output viene dichiarato con il modificatore `out`.</span><span class="sxs-lookup"><span data-stu-id="e87f0-206">An output parameter is declared with the `out` modifier.</span></span> <span data-ttu-id="e87f0-207">L'esempio seguente illustra come usare i parametri `out` con la sintassi introdotta in C# 7.</span><span class="sxs-lookup"><span data-stu-id="e87f0-207">The following example shows the use of `out` parameters using the syntax introduced in C# 7.</span></span>

[!code-csharp[OutExample](../../../samples/snippets/csharp/tour/classes-and-objects/OutExample.cs#L3-L17)]

<span data-ttu-id="e87f0-208">Una *matrice di parametri* consente di passare un numero variabile di argomenti a un metodo.</span><span class="sxs-lookup"><span data-stu-id="e87f0-208">A *parameter array* permits a variable number of arguments to be passed to a method.</span></span> <span data-ttu-id="e87f0-209">Una matrice di parametri viene dichiarata con il modificatore `params`.</span><span class="sxs-lookup"><span data-stu-id="e87f0-209">A parameter array is declared with the `params` modifier.</span></span> <span data-ttu-id="e87f0-210">Solo l'ultimo parametro di un metodo può essere costituito da una matrice di parametri, che deve essere sempre di tipo unidimensionale.</span><span class="sxs-lookup"><span data-stu-id="e87f0-210">Only the last parameter of a method can be a parameter array, and the type of a parameter array must be a single-dimensional array type.</span></span> <span data-ttu-id="e87f0-211">I metodi Write e WriteLine della classe <xref:System.Console?displayProperty=nameWithType> sono ottimi esempi per illustrare l'uso delle matrici di parametri.</span><span class="sxs-lookup"><span data-stu-id="e87f0-211">The Write and WriteLine methods of the <xref:System.Console?displayProperty=nameWithType> class are good examples of parameter array usage.</span></span> <span data-ttu-id="e87f0-212">Vengono dichiarati come illustrato di seguito.</span><span class="sxs-lookup"><span data-stu-id="e87f0-212">They are declared as follows.</span></span>

[!code-csharp[ConsoleExample](../../../samples/snippets/csharp/tour/classes-and-objects/Program.cs#L78-L83)]

<span data-ttu-id="e87f0-213">All'interno di un metodo, una matrice di parametri si comporta esattamente come un normale parametro di tipo matrice.</span><span class="sxs-lookup"><span data-stu-id="e87f0-213">Within a method that uses a parameter array, the parameter array behaves exactly like a regular parameter of an array type.</span></span> <span data-ttu-id="e87f0-214">In una chiamata di un metodo con una matrice di parametri, tuttavia, è possibile passare un singolo argomento di tipo matrice di parametri oppure un qualsiasi numero di argomenti di tipo elemento della matrice di parametri.</span><span class="sxs-lookup"><span data-stu-id="e87f0-214">However, in an invocation of a method with a parameter array, it is possible to pass either a single argument of the parameter array type or any number of arguments of the element type of the parameter array.</span></span> <span data-ttu-id="e87f0-215">Nel secondo caso, un'istanza di matrice viene automaticamente creata e inizializzata con gli argomenti specificati.</span><span class="sxs-lookup"><span data-stu-id="e87f0-215">In the latter case, an array instance is automatically created and initialized with the given arguments.</span></span> <span data-ttu-id="e87f0-216">Questo esempio</span><span class="sxs-lookup"><span data-stu-id="e87f0-216">This example</span></span>

[!code-csharp[StringFormat](../../../samples/snippets/csharp/tour/classes-and-objects/Program.cs#L55-L55)]

<span data-ttu-id="e87f0-217">è equivalente alla sintassi seguente.</span><span class="sxs-lookup"><span data-stu-id="e87f0-217">is equivalent to writing the following.</span></span>

[!code-csharp[StringFormat2](../../../samples/snippets/csharp/tour/classes-and-objects/Program.cs#L30-L35)]

### <a name="method-body-and-local-variables"></a><span data-ttu-id="e87f0-218">Corpo del metodo e variabili locali</span><span class="sxs-lookup"><span data-stu-id="e87f0-218">Method body and local variables</span></span>

<span data-ttu-id="e87f0-219">Il corpo di un metodo specifica le istruzioni da eseguire quando viene richiamato il metodo.</span><span class="sxs-lookup"><span data-stu-id="e87f0-219">A method’s body specifies the statements to execute when the method is invoked.</span></span>

<span data-ttu-id="e87f0-220">Il corpo di un metodo può dichiarare variabili specifiche per la chiamata del metodo.</span><span class="sxs-lookup"><span data-stu-id="e87f0-220">A method body can declare variables that are specific to the invocation of the method.</span></span> <span data-ttu-id="e87f0-221">Queste variabili prendono il nome di *variabili locali*.</span><span class="sxs-lookup"><span data-stu-id="e87f0-221">Such variables are called *local variables*.</span></span> <span data-ttu-id="e87f0-222">Una dichiarazione di variabile locale specifica un nome di tipo, un nome di variabile e possibilmente un valore iniziale.</span><span class="sxs-lookup"><span data-stu-id="e87f0-222">A local variable declaration specifies a type name, a variable name, and possibly an initial value.</span></span> <span data-ttu-id="e87f0-223">Nell'esempio seguente viene dichiarata una variabile locale `i` con un valore iniziale pari a zero e una variabile locale `j` senza valore iniziale.</span><span class="sxs-lookup"><span data-stu-id="e87f0-223">The following example declares a local variable `i` with an initial value of zero and a local variable `j` with no initial value.</span></span>

[!code-csharp[Squares](../../../samples/snippets/csharp/tour/classes-and-objects/Squares.cs#L3-L17)]

<span data-ttu-id="e87f0-224">In C# è necessario *assegnare esplicitamente* una variabile locale prima di poterne ottenere il valore.</span><span class="sxs-lookup"><span data-stu-id="e87f0-224">C# requires a local variable to be *definitely assigned* before its value can be obtained.</span></span> <span data-ttu-id="e87f0-225">Se ad esempio nella dichiarazione della variabile locale `i` precedente non fosse stato incluso un valore iniziale, il compilatore avrebbe segnalato un errore ogni volta che la variabile `i` veniva usata, perché `i` non era assegnata esplicitamente in quei punti del programma.</span><span class="sxs-lookup"><span data-stu-id="e87f0-225">For example, if the declaration of the previous `i` did not include an initial value, the compiler would report an error for the subsequent usages of `i` because `i` would not be definitely assigned at those points in the program.</span></span>

<span data-ttu-id="e87f0-226">Un metodo può usare istruzioni `return` per restituire il controllo al chiamante.</span><span class="sxs-lookup"><span data-stu-id="e87f0-226">A method can use `return` statements to return control to its caller.</span></span> <span data-ttu-id="e87f0-227">In un metodo che restituisce `void`, le istruzioni `return` non possono specificare un'espressione.</span><span class="sxs-lookup"><span data-stu-id="e87f0-227">In a method returning `void`, `return` statements cannot specify an expression.</span></span> <span data-ttu-id="e87f0-228">In un metodo che restituisce un valore diverso da void, le istruzioni `return` devono includere un'espressione che calcola il valore restituito.</span><span class="sxs-lookup"><span data-stu-id="e87f0-228">In a method returning non-void, `return` statements must include an expression that computes the return value.</span></span>

### <a name="static-and-instance-methods"></a><span data-ttu-id="e87f0-229">Metodi statici e di istanza</span><span class="sxs-lookup"><span data-stu-id="e87f0-229">Static and instance methods</span></span>

<span data-ttu-id="e87f0-230">Un metodo dichiarato con un modificatore static è un *metodo statico*.</span><span class="sxs-lookup"><span data-stu-id="e87f0-230">A method declared with a static modifier is a *static method*.</span></span> <span data-ttu-id="e87f0-231">Questo metodo non agisce su un'istanza specifica e può accedere direttamente solo a membri statici.</span><span class="sxs-lookup"><span data-stu-id="e87f0-231">A static method does not operate on a specific instance and can only directly access static members.</span></span>

<span data-ttu-id="e87f0-232">Un metodo dichiarato senza un modificatore static è un *metodo di istanza*.</span><span class="sxs-lookup"><span data-stu-id="e87f0-232">A method declared without a static modifier is an *instance method*.</span></span> <span data-ttu-id="e87f0-233">Questo metodo agisce su un'istanza specifica e può accedere a membri statici e di istanza.</span><span class="sxs-lookup"><span data-stu-id="e87f0-233">An instance method operates on a specific instance and can access both static and instance members.</span></span> <span data-ttu-id="e87f0-234">L'istanza in cui è stato richiamato un metodo di istanza è accessibile in modo esplicito come `this`.</span><span class="sxs-lookup"><span data-stu-id="e87f0-234">The instance on which an instance method was invoked can be explicitly accessed as `this`.</span></span> <span data-ttu-id="e87f0-235">È un errore fare riferimento a `this` in un metodo statico.</span><span class="sxs-lookup"><span data-stu-id="e87f0-235">It is an error to refer to `this` in a static method.</span></span>

<span data-ttu-id="e87f0-236">La classe `Entity` seguente contiene sia membri statici sia membri di istanza.</span><span class="sxs-lookup"><span data-stu-id="e87f0-236">The following `Entity` class has both static and instance members.</span></span>

[!code-csharp[Entity](../../../samples/snippets/csharp/tour/classes-and-objects/Entity.cs#L16-L36)]

<span data-ttu-id="e87f0-237">Ogni istanza `Entity` contiene un numero di serie (e probabilmente anche altre informazioni non illustrate qui).</span><span class="sxs-lookup"><span data-stu-id="e87f0-237">Each `Entity` instance contains a serial number (and presumably some other information that is not shown here).</span></span> <span data-ttu-id="e87f0-238">Il costruttore `Entity` (simile a un metodo di istanza) inizializza la nuova istanza con il successivo numero di serie disponibile.</span><span class="sxs-lookup"><span data-stu-id="e87f0-238">The `Entity` constructor (which is like an instance method) initializes the new instance with the next available serial number.</span></span> <span data-ttu-id="e87f0-239">Poiché il costruttore è un membro di istanza, è consentito accedere sia al campo di istanza `serialNo` sia al campo statico `nextSerialNo`.</span><span class="sxs-lookup"><span data-stu-id="e87f0-239">Because the constructor is an instance member, it is permitted to access both the `serialNo` instance field and the `nextSerialNo` static field.</span></span>

<span data-ttu-id="e87f0-240">I metodi statici `GetNextSerialNo` e `SetNextSerialNo` possono accedere al campo statico `nextSerialNo`, ma si verificherebbe un errore se accedessero direttamente al campo di istanza `serialNo`.</span><span class="sxs-lookup"><span data-stu-id="e87f0-240">The `GetNextSerialNo` and `SetNextSerialNo` static methods can access the `nextSerialNo` static field, but it would be an error for them to directly access the `serialNo` instance field.</span></span>

<span data-ttu-id="e87f0-241">Nell'esempio seguente viene illustrato l'uso della classe Entity.</span><span class="sxs-lookup"><span data-stu-id="e87f0-241">The following example shows the use of the Entity class.</span></span>

[!code-csharp[EntityExample](../../../samples/snippets/csharp/tour/classes-and-objects/Entity.cs#L3-L15)]

<span data-ttu-id="e87f0-242">Osservare come, mentre i metodi statici `SetNextSerialNo` e `GetNextSerialNo` vengono richiamati sulla classe, il metodo di istanza `GetSerialNo` viene richiamato su istanze della classe.</span><span class="sxs-lookup"><span data-stu-id="e87f0-242">Note that the `SetNextSerialNo` and `GetNextSerialNo` static methods are invoked on the class whereas the `GetSerialNo` instance method is invoked on instances of the class.</span></span>

### <a name="virtual-override-and-abstract-methods"></a><span data-ttu-id="e87f0-243">Metodi virtuali, di override e astratti</span><span class="sxs-lookup"><span data-stu-id="e87f0-243">Virtual, override, and abstract methods</span></span>

<span data-ttu-id="e87f0-244">Se una dichiarazione di metodo di istanza include un modificatore `virtual`, il metodo viene definito *metodo virtuale*.</span><span class="sxs-lookup"><span data-stu-id="e87f0-244">When an instance method declaration includes a `virtual` modifier, the method is said to be a *virtual method*.</span></span> <span data-ttu-id="e87f0-245">Se non è presente alcun modificatore virtual, il metodo diventa un *metodo non virtuale*.</span><span class="sxs-lookup"><span data-stu-id="e87f0-245">When no virtual modifier is present, the method is said to be a *nonvirtual method*.</span></span>

<span data-ttu-id="e87f0-246">Quando viene richiamato un metodo virtuale, il *tipo in fase di esecuzione* dell'istanza per cui viene eseguita la chiamata determina l'implementazione effettiva del metodo da richiamare.</span><span class="sxs-lookup"><span data-stu-id="e87f0-246">When a virtual method is invoked, the *run-time type* of the instance for which that invocation takes place determines the actual method implementation to invoke.</span></span> <span data-ttu-id="e87f0-247">In una chiamata a un metodo non virtuale, il fattore determinante è il *tipo in fase di compilazione* dell'istanza.</span><span class="sxs-lookup"><span data-stu-id="e87f0-247">In a nonvirtual method invocation, the *compile-time type* of the instance is the determining factor.</span></span>

<span data-ttu-id="e87f0-248">Un metodo virtuale non può essere *sottoposto a override* in una classe derivata.</span><span class="sxs-lookup"><span data-stu-id="e87f0-248">A virtual method can be *overridden* in a derived class.</span></span> <span data-ttu-id="e87f0-249">Se una dichiarazione di metodo di istanza include un modificatore override, il metodo esegue l'override di un metodo virtuale ereditato con la stessa firma.</span><span class="sxs-lookup"><span data-stu-id="e87f0-249">When an instance method declaration includes an override modifier, the method overrides an inherited virtual method with the same signature.</span></span> <span data-ttu-id="e87f0-250">Mentre una dichiarazione di metodo virtuale introduce un nuovo metodo, una dichiarazione di metodo di override specializza un metodo virtuale ereditato esistente specificando una nuova implementazione del metodo.</span><span class="sxs-lookup"><span data-stu-id="e87f0-250">Whereas a virtual method declaration introduces a new method, an override method declaration specializes an existing inherited virtual method by providing a new implementation of that method.</span></span>

<span data-ttu-id="e87f0-251">Un *metodo astratto* è un metodo virtuale senza implementazione.</span><span class="sxs-lookup"><span data-stu-id="e87f0-251">An *abstract method* is a virtual method with no implementation.</span></span> <span data-ttu-id="e87f0-252">Viene dichiarato con il modificatore abstract ed è consentito solo in una classe anch'essa dichiarata astratta.</span><span class="sxs-lookup"><span data-stu-id="e87f0-252">An abstract method is declared with the abstract modifier and is permitted only in a class that is also declared abstract.</span></span> <span data-ttu-id="e87f0-253">Un metodo astratto deve essere sottoposto a override in ogni classe derivata non astratta.</span><span class="sxs-lookup"><span data-stu-id="e87f0-253">An abstract method must be overridden in every non-abstract derived class.</span></span>

<span data-ttu-id="e87f0-254">Nell'esempio seguente viene dichiarata una classe astratta, `Expression`, che rappresenta un nodo dell'albero delle espressioni, e tre classi derivate, `Constant`, `VariableReference` e `Operation`, che implementano i nodi dell'albero delle espressioni relativi a costanti, riferimenti a variabili e operazioni aritmetiche.</span><span class="sxs-lookup"><span data-stu-id="e87f0-254">The following example declares an abstract class, `Expression`, which represents an expression tree node, and three derived classes, `Constant`, `VariableReference`, and `Operation`, which implement expression tree nodes for constants, variable references, and arithmetic operations.</span></span> <span data-ttu-id="e87f0-255">Questi elementi sono simili ai tipi dell'albero delle espressioni, con i quali, tuttavia, non devono essere confusi.</span><span class="sxs-lookup"><span data-stu-id="e87f0-255">(This is similar to, but not to be confused with the expression tree types).</span></span>

[!code-csharp[ExpressionClass](../../../samples/snippets/csharp/tour/classes-and-objects/Expressions.cs#L3-L61)]

<span data-ttu-id="e87f0-256">Le quattro classi precedenti possono essere usate per modellare espressioni aritmetiche.</span><span class="sxs-lookup"><span data-stu-id="e87f0-256">The previous four classes can be used to model arithmetic expressions.</span></span> <span data-ttu-id="e87f0-257">Usando istanze di queste classi, l'espressione `x + 3`, ad esempio, può essere rappresentata come illustrato di seguito.</span><span class="sxs-lookup"><span data-stu-id="e87f0-257">For example, using instances of these classes, the expression `x + 3` can be represented as follows.</span></span>

[!code-csharp[ExpressionExample](../../../samples/snippets/csharp/tour/classes-and-objects/Program.cs#L40-L43)]

<span data-ttu-id="e87f0-258">Il metodo `Evaluate` di un'istanza `Expression` viene richiamato per valutare l'espressione specificata e generare un valore `double`.</span><span class="sxs-lookup"><span data-stu-id="e87f0-258">The `Evaluate` method of an `Expression` instance is invoked to evaluate the given expression and produce a `double` value.</span></span> <span data-ttu-id="e87f0-259">Il metodo accetta un argomento `Dictionary` che contiene nomi di variabili (come chiavi delle voci) e valori (come valori delle voci).</span><span class="sxs-lookup"><span data-stu-id="e87f0-259">The method takes a `Dictionary` argument that contains variable names (as keys of the entries) and values (as values of the entries).</span></span> <span data-ttu-id="e87f0-260">Poiché `Evaluate` è un metodo astratto, le classi non astratte derivate da `Expression` devono eseguire l'override di `Evaluate`.</span><span class="sxs-lookup"><span data-stu-id="e87f0-260">Because `Evaluate` is an abstract method, non-abstract classes derived from `Expression` must override `Evaluate`.</span></span>

<span data-ttu-id="e87f0-261">L'implementazione di un valore `Constant` del metodo `Evaluate` restituisce semplicemente la costante memorizzata.</span><span class="sxs-lookup"><span data-stu-id="e87f0-261">A `Constant`'s implementation of `Evaluate` simply returns the stored constant.</span></span> <span data-ttu-id="e87f0-262">L'implementazione di un valore `VariableReference` cerca il nome della variabile nel dizionario e restituisce il valore ottenuto.</span><span class="sxs-lookup"><span data-stu-id="e87f0-262">A `VariableReference`'s implementation looks up the variable name in the dictionary and returns the resulting value.</span></span> <span data-ttu-id="e87f0-263">L'implementazione di un valore `Operation` valuta prima gli operandi sinistro e destro (richiamando in modo ricorsivo i metodi `Evaluate`) e quindi esegue l'operazione aritmetica specificata.</span><span class="sxs-lookup"><span data-stu-id="e87f0-263">An `Operation`'s implementation first evaluates the left and right operands (by recursively invoking their `Evaluate` methods) and then performs the given arithmetic operation.</span></span>

<span data-ttu-id="e87f0-264">Il programma seguente usa le classi `Expression` per valutare l'espressione `x * (y + 2)` per valori diversi di `x` e `y`.</span><span class="sxs-lookup"><span data-stu-id="e87f0-264">The following program uses the `Expression` classes to evaluate the expression `x * (y + 2)` for different values of `x` and `y`.</span></span>

[!code-csharp[ExpressionUsage](../../../samples/snippets/csharp/tour/classes-and-objects/Expressions.cs#L66-L89)]

### <a name="method-overloading"></a><span data-ttu-id="e87f0-265">Overload di un metodo</span><span class="sxs-lookup"><span data-stu-id="e87f0-265">Method overloading</span></span>

<span data-ttu-id="e87f0-266">L'*overload* di un metodo consente a più metodi della stessa classe di avere lo stesso nome, purché abbiano firme univoche.</span><span class="sxs-lookup"><span data-stu-id="e87f0-266">Method *overloading* permits multiple methods in the same class to have the same name as long as they have unique signatures.</span></span> <span data-ttu-id="e87f0-267">Quando si compila una chiamata di un metodo di overload, il compilatore usa la *risoluzione dell'overload* per determinare il metodo specifico da richiamare.</span><span class="sxs-lookup"><span data-stu-id="e87f0-267">When compiling an invocation of an overloaded method, the compiler uses *overload resolution* to determine the specific method to invoke.</span></span> <span data-ttu-id="e87f0-268">La risoluzione dell'overload trova il metodo che meglio corrisponde agli argomenti o segnala un errore se non riesce a trovare alcuna corrispondenza.</span><span class="sxs-lookup"><span data-stu-id="e87f0-268">Overload resolution finds the one method that best matches the arguments or reports an error if no single best match can be found.</span></span> <span data-ttu-id="e87f0-269">Nell'esempio seguente viene illustrato il funzionamento effettivo della risoluzione dell'overload.</span><span class="sxs-lookup"><span data-stu-id="e87f0-269">The following example shows overload resolution in effect.</span></span> <span data-ttu-id="e87f0-270">Il commento relativo a ogni chiamata del metodo `Main` mostra il metodo effettivamente richiamato.</span><span class="sxs-lookup"><span data-stu-id="e87f0-270">The comment for each invocation in the `Main` method shows which method is actually invoked.</span></span>

[!code-csharp[OverloadUsage](../../../samples/snippets/csharp/tour/classes-and-objects/Overloading.cs#L3-L41)]

<span data-ttu-id="e87f0-271">Come illustrato nell'esempio, è sempre possibile selezionare un metodo specifico eseguendo in modo esplicito il cast degli argomenti ai tipi di parametro corretti e/o specificando in modo esplicito gli argomenti di tipo.</span><span class="sxs-lookup"><span data-stu-id="e87f0-271">As shown by the example, a particular method can always be selected by explicitly casting the arguments to the exact parameter types and/or explicitly supplying type arguments.</span></span>

## <a name="other-function-members"></a><span data-ttu-id="e87f0-272">Altri membri di funzione</span><span class="sxs-lookup"><span data-stu-id="e87f0-272">Other function members</span></span>

<span data-ttu-id="e87f0-273">I membri che contengono codice eseguibile sono noti come *membri funzione* di una classe.</span><span class="sxs-lookup"><span data-stu-id="e87f0-273">Members that contain executable code are collectively known as the *function members* of a class.</span></span> <span data-ttu-id="e87f0-274">Nella sezione precedente sono stati descritti i metodi, che costituiscono i membri di funzione principali.</span><span class="sxs-lookup"><span data-stu-id="e87f0-274">The preceding section describes methods, which are the primary kind of function members.</span></span> <span data-ttu-id="e87f0-275">In questa sezione vengono descritti altri membri di funzione supportati da C#: costruttori, proprietà, indicizzatori, eventi, operatori e finalizzatori.</span><span class="sxs-lookup"><span data-stu-id="e87f0-275">This section describes the other kinds of function members supported by C#: constructors, properties, indexers, events, operators, and finalizers.</span></span>

<span data-ttu-id="e87f0-276">Di seguito è illustrata una classe generica denominata List<T>, che implementa un elenco espandibile di oggetti.</span><span class="sxs-lookup"><span data-stu-id="e87f0-276">The following shows a generic class called List<T>, which implements a growable list of objects.</span></span> <span data-ttu-id="e87f0-277">Nella classe sono contenuti alcuni esempi di membri di funzione più comuni.</span><span class="sxs-lookup"><span data-stu-id="e87f0-277">The class contains several examples of the most common kinds of function members.</span></span>

[!code-csharp[ListClass](../../../samples/snippets/csharp/tour/classes-and-objects/ListBasedExamples.cs#L4-L89)]

### <a name="constructors"></a><span data-ttu-id="e87f0-278">Costruttori</span><span class="sxs-lookup"><span data-stu-id="e87f0-278">Constructors</span></span>

<span data-ttu-id="e87f0-279">C# supporta sia costruttori di istanza sia costruttori statici.</span><span class="sxs-lookup"><span data-stu-id="e87f0-279">C# supports both instance and static constructors.</span></span> <span data-ttu-id="e87f0-280">Un *costruttore di istanza* è un membro che implementa le azioni necessarie per inizializzare un'istanza di una classe,</span><span class="sxs-lookup"><span data-stu-id="e87f0-280">An *instance constructor* is a member that implements the actions required to initialize an instance of a class.</span></span> <span data-ttu-id="e87f0-281">mentre un *costruttore statico* è un membro che implementa le azioni necessarie per inizializzare una classe nel momento in cui viene caricata per la prima volta.</span><span class="sxs-lookup"><span data-stu-id="e87f0-281">A *static constructor* is a member that implements the actions required to initialize a class itself when it is first loaded.</span></span>

<span data-ttu-id="e87f0-282">Un costruttore viene dichiarato come un metodo, senza tipo restituito e con lo stesso nome della classe in cui è contenuto.</span><span class="sxs-lookup"><span data-stu-id="e87f0-282">A constructor is declared like a method with no return type and the same name as the containing class.</span></span> <span data-ttu-id="e87f0-283">Se una dichiarazione di costruttore include un modificatore static, dichiara un costruttore statico.</span><span class="sxs-lookup"><span data-stu-id="e87f0-283">If a constructor declaration includes a static modifier, it declares a static constructor.</span></span> <span data-ttu-id="e87f0-284">In caso contrario, dichiara un costruttore di istanza.</span><span class="sxs-lookup"><span data-stu-id="e87f0-284">Otherwise, it declares an instance constructor.</span></span>

<span data-ttu-id="e87f0-285">I costruttori di istanza possono essere sottoposti a overload e possono avere parametri facoltativi.</span><span class="sxs-lookup"><span data-stu-id="e87f0-285">Instance constructors can be overloaded, and can have optional parameters.</span></span> <span data-ttu-id="e87f0-286">La classe `List<T>`, ad esempio, dichiara due costruttori di istanza, uno senza parametri e uno che accetta un parametro `int`.</span><span class="sxs-lookup"><span data-stu-id="e87f0-286">For example, the `List<T>` class declares two instance constructors, one with no parameters and one that takes an `int` parameter.</span></span> <span data-ttu-id="e87f0-287">I costruttori di istanza vengono richiamati con l'operatore `new`.</span><span class="sxs-lookup"><span data-stu-id="e87f0-287">Instance constructors are invoked using the `new` operator.</span></span> <span data-ttu-id="e87f0-288">Le istruzioni seguenti allocano due istanze `List<string>` usando il costruttore della classe `List` con e senza l'argomento facoltativo.</span><span class="sxs-lookup"><span data-stu-id="e87f0-288">The following statements allocate two `List<string>` instances using the constructor of the `List` class with and without the optional argument.</span></span>

[!code-csharp[ListExample1](../../../samples/snippets/csharp/tour/classes-and-objects/ListBasedExamples.cs#L95-L96)]

<span data-ttu-id="e87f0-289">A differenza di altri membri, i costruttori di istanza non vengono ereditati e una classe non può contenere costruttori di istanza diversi da quelli effettivamente dichiarati nella classe.</span><span class="sxs-lookup"><span data-stu-id="e87f0-289">Unlike other members, instance constructors are not inherited, and a class has no instance constructors other than those actually declared in the class.</span></span> <span data-ttu-id="e87f0-290">Se per una classe non è specificato alcun costruttore di istanza, ne viene automaticamente fornito uno vuoto senza parametri.</span><span class="sxs-lookup"><span data-stu-id="e87f0-290">If no instance constructor is supplied for a class, then an empty one with no parameters is automatically provided.</span></span>

### <a name="properties"></a><span data-ttu-id="e87f0-291">Proprietà</span><span class="sxs-lookup"><span data-stu-id="e87f0-291">Properties</span></span>

<span data-ttu-id="e87f0-292">Le *proprietà* sono una naturale estensione dei campi.</span><span class="sxs-lookup"><span data-stu-id="e87f0-292">*Properties* are a natural extension of fields.</span></span> <span data-ttu-id="e87f0-293">Entrambi sono membri denominati con tipi associati e la sintassi per accedere ai campi e alle proprietà è identica.</span><span class="sxs-lookup"><span data-stu-id="e87f0-293">Both are named members with associated types, and the syntax for accessing fields and properties is the same.</span></span> <span data-ttu-id="e87f0-294">A differenza dei campi, tuttavia, le proprietà non denotano posizioni di memoria,</span><span class="sxs-lookup"><span data-stu-id="e87f0-294">However, unlike fields, properties do not denote storage locations.</span></span> <span data-ttu-id="e87f0-295">ma hanno *funzioni di accesso* che specificano le istruzioni da eseguire nel momento in cui ne vengono letti o scritti i valori.</span><span class="sxs-lookup"><span data-stu-id="e87f0-295">Instead, properties have *accessors* that specify the statements to be executed when their values are read or written.</span></span>

<span data-ttu-id="e87f0-296">Una proprietà viene dichiarata come un campo, con la sola differenza che la dichiarazione termina con una funzione di accesso get e/o set scritta tra i delimitatori `{` e `}`, anziché con un punto e virgola.</span><span class="sxs-lookup"><span data-stu-id="e87f0-296">A property is declared like a field, except that the declaration ends with a get accessor and/or a set accessor written between the delimiters `{` and `}` instead of ending in a semicolon.</span></span> <span data-ttu-id="e87f0-297">Una proprietà che include entrambe le funzioni di accesso get e set è una *proprietà di lettura/scrittura*, una proprietà che include solo una funzione di accesso get è una *proprietà di sola lettura* e una proprietà che include solo una funzione di accesso set è una *proprietà di sola scrittura*.</span><span class="sxs-lookup"><span data-stu-id="e87f0-297">A property that has both a get accessor and a set accessor is a *read-write property*, a property that has only a get accessor is a *read-only property*, and a property that has only a set accessor is a *write-only property*.</span></span>

<span data-ttu-id="e87f0-298">Una funzione di accesso get corrisponde a un metodo senza parametri con un valore restituito del tipo di proprietà.</span><span class="sxs-lookup"><span data-stu-id="e87f0-298">A get accessor corresponds to a parameterless method with a return value of the property type.</span></span> <span data-ttu-id="e87f0-299">Quando in un'espressione si fa riferimento a una proprietà, ma non come destinazione di un'assegnazione, la funzione di accesso get della proprietà viene richiamata per calcolare il valore della proprietà.</span><span class="sxs-lookup"><span data-stu-id="e87f0-299">Except as the target of an assignment, when a property is referenced in an expression, the get accessor of the property is invoked to compute the value of the property.</span></span>

<span data-ttu-id="e87f0-300">Una funzione di accesso set corrisponde a un metodo con un singolo valore di parametro denominato e senza tipo restituito.</span><span class="sxs-lookup"><span data-stu-id="e87f0-300">A set accessor corresponds to a method with a single parameter named value and no return type.</span></span> <span data-ttu-id="e87f0-301">Quando si fa riferimento a una proprietà come destinazione di un'assegnazione o come operando di ++ o --, la funzione di accesso set viene richiamata con un argomento che fornisce il nuovo valore.</span><span class="sxs-lookup"><span data-stu-id="e87f0-301">When a property is referenced as the target of an assignment or as the operand of ++ or --, the set accessor is invoked with an argument that provides the new value.</span></span>

<span data-ttu-id="e87f0-302">La classe `List<T>` dichiara due proprietà, Count e Capacity, che sono rispettivamente di sola lettura e di lettura/scrittura.</span><span class="sxs-lookup"><span data-stu-id="e87f0-302">The `List<T>` class declares two properties, Count and Capacity, which are read-only and read-write, respectively.</span></span> <span data-ttu-id="e87f0-303">Di seguito è riportato un esempio d'uso di queste proprietà.</span><span class="sxs-lookup"><span data-stu-id="e87f0-303">The following is an example of use of these properties.</span></span>

[!code-csharp[ListExample2](../../../samples/snippets/csharp/tour/classes-and-objects/ListBasedExamples.cs#L101-L104)]

<span data-ttu-id="e87f0-304">Come per i campi e i metodi, C# supporta sia proprietà di istanza sia proprietà statiche.</span><span class="sxs-lookup"><span data-stu-id="e87f0-304">Similar to fields and methods, C# supports both instance properties and static properties.</span></span> <span data-ttu-id="e87f0-305">Le proprietà statiche vengono dichiarate con il modificatore static, mentre le proprietà di istanza vengono dichiarate senza tale modificatore.</span><span class="sxs-lookup"><span data-stu-id="e87f0-305">Static properties are declared with the static modifier, and instance properties are declared without it.</span></span>

<span data-ttu-id="e87f0-306">Le funzioni di accesso di una proprietà possono essere virtuali.</span><span class="sxs-lookup"><span data-stu-id="e87f0-306">The accessor(s) of a property can be virtual.</span></span> <span data-ttu-id="e87f0-307">Se una dichiarazione di proprietà contiene un modificatore `virtual`, `abstract` o `override`, questo viene applicato anche alle funzioni di accesso della proprietà.</span><span class="sxs-lookup"><span data-stu-id="e87f0-307">When a property declaration includes a `virtual`, `abstract`, or `override` modifier, it applies to the accessor(s) of the property.</span></span>

### <a name="indexers"></a><span data-ttu-id="e87f0-308">Indicizzatori</span><span class="sxs-lookup"><span data-stu-id="e87f0-308">Indexers</span></span>

<span data-ttu-id="e87f0-309">Un *indicizzatore* è un membro che consente di indicizzare gli oggetti esattamente come una matrice.</span><span class="sxs-lookup"><span data-stu-id="e87f0-309">An *indexer* is a member that enables objects to be indexed in the same way as an array.</span></span> <span data-ttu-id="e87f0-310">Un indicizzatore viene dichiarato come una proprietà, ma a differenza di questa il nome del membro è seguito da un elenco di parametri scritti tra i delimitatori `[` e `]`.</span><span class="sxs-lookup"><span data-stu-id="e87f0-310">An indexer is declared like a property except that the name of the member is this followed by a parameter list written between the delimiters `[` and `]`.</span></span> <span data-ttu-id="e87f0-311">I parametri sono disponibili nelle funzioni di accesso dell'indicizzatore.</span><span class="sxs-lookup"><span data-stu-id="e87f0-311">The parameters are available in the accessor(s) of the indexer.</span></span> <span data-ttu-id="e87f0-312">Analogamente alle proprietà, gli indicizzatori possono essere di lettura/scrittura, di sola lettura o di sola scrittura e le funzioni di accesso di un indicizzatore possono essere virtuali.</span><span class="sxs-lookup"><span data-stu-id="e87f0-312">Similar to properties, indexers can be read-write, read-only, and write-only, and the accessor(s) of an indexer can be virtual.</span></span>

<span data-ttu-id="e87f0-313">La classe `List` dichiara un indicizzatore di lettura/scrittura che accetta un parametro `int`</span><span class="sxs-lookup"><span data-stu-id="e87f0-313">The `List` class declares a single read-write indexer that takes an `int` parameter.</span></span> <span data-ttu-id="e87f0-314">e consente di indicizzare istanze `List` con valori `int`.</span><span class="sxs-lookup"><span data-stu-id="e87f0-314">The indexer makes it possible to index `List` instances with `int` values.</span></span> <span data-ttu-id="e87f0-315">Ad esempio:</span><span class="sxs-lookup"><span data-stu-id="e87f0-315">For example:</span></span>

[!code-csharp[ListExample3](../../../samples/snippets/csharp/tour/classes-and-objects/ListBasedExamples.cs#L109-L117)]

<span data-ttu-id="e87f0-316">Gli indicizzatori possono essere sottoposti a overload, ovvero una classe può dichiarare più indicizzatori purché includano un numero o tipi diversi di parametri.</span><span class="sxs-lookup"><span data-stu-id="e87f0-316">Indexers can be overloaded, meaning that a class can declare multiple indexers as long as the number or types of their parameters differ.</span></span>

### <a name="events"></a><span data-ttu-id="e87f0-317">Eventi</span><span class="sxs-lookup"><span data-stu-id="e87f0-317">Events</span></span>

<span data-ttu-id="e87f0-318">Un *evento* è un membro che consente a una classe o a un oggetto di inviare notifiche.</span><span class="sxs-lookup"><span data-stu-id="e87f0-318">An *event* is a member that enables a class or object to provide notifications.</span></span> <span data-ttu-id="e87f0-319">Un evento viene dichiarato come un campo, con la sola differenza che la dichiarazione deve includere una parola chiave evento e il tipo deve essere un tipo delegato.</span><span class="sxs-lookup"><span data-stu-id="e87f0-319">An event is declared like a field except that the declaration includes an event keyword and the type must be a delegate type.</span></span>

<span data-ttu-id="e87f0-320">In una classe che dichiara un membro di evento, l'evento si comporta esattamente come un campo di un tipo delegato, purché l'evento non sia astratto e non dichiari funzioni di accesso.</span><span class="sxs-lookup"><span data-stu-id="e87f0-320">Within a class that declares an event member, the event behaves just like a field of a delegate type (provided the event is not abstract and does not declare accessors).</span></span> <span data-ttu-id="e87f0-321">Il campo archivia un riferimento a un delegato che rappresenta i gestori eventi aggiunti all'evento.</span><span class="sxs-lookup"><span data-stu-id="e87f0-321">The field stores a reference to a delegate that represents the event handlers that have been added to the event.</span></span> <span data-ttu-id="e87f0-322">Se non è presente alcun gestore eventi, il campo è `null`.</span><span class="sxs-lookup"><span data-stu-id="e87f0-322">If no event handlers are present, the field is `null`.</span></span>

<span data-ttu-id="e87f0-323">La classe `List<T>` dichiara un singolo membro di evento denominato `Changed`, con cui si indica che un nuovo elemento è stato aggiunto all'elenco.</span><span class="sxs-lookup"><span data-stu-id="e87f0-323">The `List<T>` class declares a single event member called `Changed`, which indicates that a new item has been added to the list.</span></span> <span data-ttu-id="e87f0-324">L'evento Changed viene generato dal metodo virtuale `OnChanged`, che prima controlla se l'evento è `null`, ovvero se non è presente alcun gestore.</span><span class="sxs-lookup"><span data-stu-id="e87f0-324">The Changed event is raised by the `OnChanged` virtual method, which first checks whether the event is `null` (meaning that no handlers are present).</span></span> <span data-ttu-id="e87f0-325">Generare un evento equivale a richiamare il delegato rappresentato dall'evento. Non sono quindi necessari speciali costrutti di linguaggio per generare eventi.</span><span class="sxs-lookup"><span data-stu-id="e87f0-325">The notion of raising an event is precisely equivalent to invoking the delegate represented by the event—thus, there are no special language constructs for raising events.</span></span>

<span data-ttu-id="e87f0-326">I client rispondono agli eventi tramite *gestori eventi*,</span><span class="sxs-lookup"><span data-stu-id="e87f0-326">Clients react to events through *event handlers*.</span></span> <span data-ttu-id="e87f0-327">che possono essere aggiunti con l'operatore `+=` e rimossi con l'operatore `-=`.</span><span class="sxs-lookup"><span data-stu-id="e87f0-327">Event handlers are attached using the `+=` operator and removed using the `-=` operator.</span></span> <span data-ttu-id="e87f0-328">Nell'esempio seguente un gestore eventi viene aggiunto all'evento `Changed` di `List<string>`.</span><span class="sxs-lookup"><span data-stu-id="e87f0-328">The following example attaches an event handler to the `Changed` event of a `List<string>`.</span></span>

[!code-csharp[EventExample](../../../samples/snippets/csharp/tour/classes-and-objects/ListBasedExamples.cs#L132-L148)]

<span data-ttu-id="e87f0-329">Negli scenari avanzati in cui è auspicabile controllare l'archiviazione sottostante di un evento, una dichiarazione di evento può fornire in modo esplicito le funzioni di accesso `add` e `remove`, simili alla funzione di accesso `set` di una proprietà.</span><span class="sxs-lookup"><span data-stu-id="e87f0-329">For advanced scenarios where control of the underlying storage of an event is desired, an event declaration can explicitly provide `add` and `remove` accessors, which are somewhat similar to the `set` accessor of a property.</span></span>

### <a name="operators"></a><span data-ttu-id="e87f0-330">Operatori</span><span class="sxs-lookup"><span data-stu-id="e87f0-330">Operators</span></span>

<span data-ttu-id="e87f0-331">Un *operatore* è un membro che definisce il significato dell'applicazione di un particolare operatore di espressione alle istanze di una classe.</span><span class="sxs-lookup"><span data-stu-id="e87f0-331">An *operator* is a member that defines the meaning of applying a particular expression operator to instances of a class.</span></span> <span data-ttu-id="e87f0-332">È possibile definire tre tipi di operatori: unari, binari e di conversione.</span><span class="sxs-lookup"><span data-stu-id="e87f0-332">Three kinds of operators can be defined: unary operators, binary operators, and conversion operators.</span></span> <span data-ttu-id="e87f0-333">Tutti gli operatori devono essere dichiarati come `public` e `static`.</span><span class="sxs-lookup"><span data-stu-id="e87f0-333">All operators must be declared as `public` and `static`.</span></span>

<span data-ttu-id="e87f0-334">La classe `List<T>` dichiara due operatori, `operator ==` e `operator !=`, attribuendo così un nuovo significato alle espressioni che applicano questi operatori alle istanze di `List`.</span><span class="sxs-lookup"><span data-stu-id="e87f0-334">The `List<T>` class declares two operators, `operator ==` and `operator !=`, and thus gives new meaning to expressions that apply those operators to `List` instances.</span></span> <span data-ttu-id="e87f0-335">In particolare, gli operatori definiscono l'uguaglianza di due istanze di `List<T>`, confrontando ognuno degli oggetti contenuti con i rispettivi metodi Equals.</span><span class="sxs-lookup"><span data-stu-id="e87f0-335">Specifically, the operators define equality of two `List<T>` instances as comparing each of the contained objects using their Equals methods.</span></span> <span data-ttu-id="e87f0-336">Nell'esempio seguente viene usato l'operatore `==` per confrontare due istanze di `List<int>`.</span><span class="sxs-lookup"><span data-stu-id="e87f0-336">The following example uses the `==` operator to compare two `List<int>` instances.</span></span>

[!code-csharp[OperatorExample](../../../samples/snippets/csharp/tour/classes-and-objects/ListBasedExamples.cs#L121-L129)]

<span data-ttu-id="e87f0-337">Il primo `Console.WriteLine` restituisce `True` perché i due elenchi contengono lo stesso numero di oggetti con gli stessi valori e nello stesso ordine.</span><span class="sxs-lookup"><span data-stu-id="e87f0-337">The first `Console.WriteLine` outputs `True` because the two lists contain the same number of objects with the same values in the same order.</span></span> <span data-ttu-id="e87f0-338">Se in `List<T>` non fosse stato definito l'operatore `operator ==`, il primo `Console.WriteLine` avrebbe restituito `False` perché `a` e `b` fanno riferimento a istanze di `List<int>` diverse.</span><span class="sxs-lookup"><span data-stu-id="e87f0-338">Had `List<T>` not defined `operator ==`, the first `Console.WriteLine` would have output `False` because `a` and `b` reference different `List<int>` instances.</span></span>

### <a name="finalizers"></a><span data-ttu-id="e87f0-339">Finalizzatori</span><span class="sxs-lookup"><span data-stu-id="e87f0-339">Finalizers</span></span>

<span data-ttu-id="e87f0-340">Un *finalizzatore* è un membro che implementa le azioni necessarie per finalizzare un'istanza di una classe.</span><span class="sxs-lookup"><span data-stu-id="e87f0-340">A *finalizer* is a member that implements the actions required to finalize an instance of a class.</span></span> <span data-ttu-id="e87f0-341">I finalizzatori non possono contenere parametri o modificatori di accessibilità e non possono essere richiamati in modo esplicito.</span><span class="sxs-lookup"><span data-stu-id="e87f0-341">Finalizers cannot have parameters, they cannot have accessibility modifiers, and they cannot be invoked explicitly.</span></span> <span data-ttu-id="e87f0-342">Il finalizzatore di un'istanza viene richiamato automaticamente durante la procedura di Garbage Collection.</span><span class="sxs-lookup"><span data-stu-id="e87f0-342">The finalizer for an instance is invoked automatically during garbage collection.</span></span>

<span data-ttu-id="e87f0-343">Al Garbage Collector viene lasciata ampia scelta per decidere quando raccogliere oggetti ed eseguire finalizzatori.</span><span class="sxs-lookup"><span data-stu-id="e87f0-343">The garbage collector is allowed wide latitude in deciding when to collect objects and run finalizers.</span></span> <span data-ttu-id="e87f0-344">In particolare, l'intervallo con cui vengono richiamati i finalizzatori non è deterministico e i finalizzatori possono essere eseguiti su qualsiasi thread.</span><span class="sxs-lookup"><span data-stu-id="e87f0-344">Specifically, the timing of finalizer invocations is not deterministic, and finalizers may be executed on any thread.</span></span> <span data-ttu-id="e87f0-345">Per questi e altri motivi, le classi devono implementare finalizzatori solo se non è praticabile nessun'altra soluzione.</span><span class="sxs-lookup"><span data-stu-id="e87f0-345">For these and other reasons, classes should implement finalizers only when no other solutions are feasible.</span></span>

<span data-ttu-id="e87f0-346">L'istruzione `using` offre una soluzione più efficace per l'eliminazione di oggetti.</span><span class="sxs-lookup"><span data-stu-id="e87f0-346">The `using` statement provides a better approach to object destruction.</span></span>

>[!div class="step-by-step"]
<span data-ttu-id="e87f0-347">[Precedente](statements.md)
[Successivo](structs.md)</span><span class="sxs-lookup"><span data-stu-id="e87f0-347">[Previous](statements.md)
[Next](structs.md)</span></span>
