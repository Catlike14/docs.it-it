---
title: Funzioni locali ed espressioni lambda
description: Informazioni sui motivi per cui le funzioni locali possono essere una scelta migliore rispetto alle espressioni lambda.
keywords: "C#, .NET, .NET Core, funzionalità recenti, novità, funzioni locali, espressioni lambda"
author: BillWagner
ms.author: wiwagn
ms.date: 06/27/2016
ms.topic: article
ms.prod: .net
ms.technology: devlang-csharp
ms.devlang: csharp
ms.assetid: 368d1752-3659-489a-97b4-f15d87e49ae3
ms.openlocfilehash: 20312b58a24dc991791edad4bb92d3a8ca6d501a
ms.sourcegitcommit: 5fb6646b5ee3769ffb214e672041833ea4ceeb26
ms.translationtype: HT
ms.contentlocale: it-IT
ms.lasthandoff: 11/08/2017
---
# <a name="local-functions-compared-to-lambda-expressions"></a><span data-ttu-id="1357b-104">Funzioni locali rispetto alle espressioni lambda</span><span class="sxs-lookup"><span data-stu-id="1357b-104">Local functions compared to lambda expressions</span></span>

<span data-ttu-id="1357b-105">A prima vista, le [funzioni locali](programming-guide/classes-and-structs/local-functions.md) e le [espressioni lambda](lambda-expressions.md) sono molto simili.</span><span class="sxs-lookup"><span data-stu-id="1357b-105">At first glance, [local functions](programming-guide/classes-and-structs/local-functions.md) and [lambda expressions](lambda-expressions.md) are very similar.</span></span> <span data-ttu-id="1357b-106">In molti casi, la scelta tra l'utilizzo di funzioni locali ed espressioni lambda è una questione di stile e le preferenze personali.</span><span class="sxs-lookup"><span data-stu-id="1357b-106">In many cases, the choice between using lambda expressions and local functions is a matter of style and personal preference.</span></span> <span data-ttu-id="1357b-107">Tuttavia, esistono differenze reali in cui è possibile utilizzare uno o l'altro che è necessario essere consapevoli di.</span><span class="sxs-lookup"><span data-stu-id="1357b-107">However, there are real differences in where you can use one or the other that you should be aware of.</span></span>

<span data-ttu-id="1357b-108">Si esamineranno ora le differenze tra implementazioni di funzioni locali e implementazioni di espressioni lambda dell'algoritmo fattoriale.</span><span class="sxs-lookup"><span data-stu-id="1357b-108">Let's examine the differences between the local function and lambda expression implementations of the factorial algorithm.</span></span> <span data-ttu-id="1357b-109">Si analizzerà per prima la versione che usa una funzione locale:</span><span class="sxs-lookup"><span data-stu-id="1357b-109">First the version using a local function:</span></span>

[!code-csharp[LocalFunctionFactorial](../../samples/snippets/csharp/new-in-7/MathUtilities.cs#37_LocalFunctionFactorial "Recursive factorial using local function")]

<span data-ttu-id="1357b-110">Confrontare l'implementazione con una versione che usa le espressioni lambda:</span><span class="sxs-lookup"><span data-stu-id="1357b-110">Contrast that implementation with a version that uses lambda expressions:</span></span>

[!code-csharp[26_LambdaFactorial](../../samples/snippets/csharp/new-in-7/MathUtilities.cs#38_LambdaFactorial "Recursive factorial using lambda expressions")]

<span data-ttu-id="1357b-111">Le funzioni locali hanno nomi.</span><span class="sxs-lookup"><span data-stu-id="1357b-111">The local functions have names.</span></span> <span data-ttu-id="1357b-112">Le espressioni lambda sono metodi anonimi che vengono assegnati a variabili che sono `Func` o `Action` tipi.</span><span class="sxs-lookup"><span data-stu-id="1357b-112">The lambda expressions are anonymous methods that are assigned to variables that are `Func` or `Action` types.</span></span> <span data-ttu-id="1357b-113">Quando si dichiara una funzione locale, i tipi di argomento e un tipo restituito fanno parte della dichiarazione di funzione.</span><span class="sxs-lookup"><span data-stu-id="1357b-113">When you declare a local function, the argument types and return type are part of the function declaration.</span></span> <span data-ttu-id="1357b-114">Anziché far parte del corpo dell'espressione lambda espressione, i tipi di argomento e il tipo restituito fanno parte della dichiarazione di variabile di tipo dell'espressione lambda.</span><span class="sxs-lookup"><span data-stu-id="1357b-114">Instead of being part of the body of the lambda expression, the argument types and return type are part of the lambda expression's variable type declaration.</span></span> <span data-ttu-id="1357b-115">Queste due differenze possono generare codice più chiara.</span><span class="sxs-lookup"><span data-stu-id="1357b-115">Those two differences may result in clearer code.</span></span>

<span data-ttu-id="1357b-116">Le funzioni locali hanno regole diverse per l'assegnazione di espressioni lambda.</span><span class="sxs-lookup"><span data-stu-id="1357b-116">Local functions have different rules for definite assignment than lambda expressions.</span></span> <span data-ttu-id="1357b-117">Una dichiarazione di funzione locale può fare riferimento da qualsiasi posizione di codice in cui si trova nell'ambito.</span><span class="sxs-lookup"><span data-stu-id="1357b-117">A local function declaration can be referenced from any code location where it is in scope.</span></span> <span data-ttu-id="1357b-118">Un'espressione lambda deve essere assegnata a una variabile delegato prima che può essere accedere (o tramita il delegato che fa riferimento l'espressione lambda.) Si noti che la versione che usa l'espressione lambda deve dichiarare e inizializzare l'espressione lambda `nthFactorial` prima di definirla.</span><span class="sxs-lookup"><span data-stu-id="1357b-118">A lambda expression must be assigned to a delegate variable before it can be accessed (or called through the delgate referencing the lambda expression.) Notice that the version using the lambda expression must declare and initialize the lambda expression, `nthFactorial` before defining it.</span></span> <span data-ttu-id="1357b-119">In caso contrario, si verifica un errore di compilazione per fare riferimento a `nthFactorial` prima di assegnarla.</span><span class="sxs-lookup"><span data-stu-id="1357b-119">Not doing so results in a compile time error for referencing `nthFactorial` before assigning it.</span></span>
<span data-ttu-id="1357b-120">Queste differenze indicano che algoritmi ricorsivi sono più semplici da creare usando funzioni locali.</span><span class="sxs-lookup"><span data-stu-id="1357b-120">These differences mean that recursive algorithms are easier to create using local functions.</span></span> <span data-ttu-id="1357b-121">È possibile dichiarare e definire una funzione locale che chiama se stessa.</span><span class="sxs-lookup"><span data-stu-id="1357b-121">You can declare and define a local function that calls itself.</span></span> <span data-ttu-id="1357b-122">Espressioni lambda devono essere dichiarate e assegnate un valore predefinito prima di poter essere riassegnati a un corpo che fa riferimento la stessa espressione lambda.</span><span class="sxs-lookup"><span data-stu-id="1357b-122">Lambda expressions must be declared, and assigned a default value before they can be re-assigned to a body that references the same lambda expression.</span></span>

<span data-ttu-id="1357b-123">Le regole di assegnazione definita influenzano anche tutte le variabili acquisite per il epression lambda o di funzione locale.</span><span class="sxs-lookup"><span data-stu-id="1357b-123">Definite assignment rules also affect any variables that are captured by the local function or lamdba epression.</span></span> <span data-ttu-id="1357b-124">Le funzioni locali sia le regole delle espressioni lambda richiedono che tutte le variabili acquisite sono assegnate in corrispondenza del punto quando l'espressione lambda o di funzione locale viene convertito in un delegato.</span><span class="sxs-lookup"><span data-stu-id="1357b-124">Both local functions and lambda expression rules demand that any captured variables are definitely assigned at the point when the local function or lambda expression is converted to a delegate.</span></span> <span data-ttu-id="1357b-125">La differenza è che le espressioni lambda vengono convertite in delegati quando vengono dichiarati.</span><span class="sxs-lookup"><span data-stu-id="1357b-125">The difference is that lambda expressions are converted to delegates when they are declared.</span></span> <span data-ttu-id="1357b-126">Le funzioni locali vengono convertite in delegati solo se utilizzato come un delegato.</span><span class="sxs-lookup"><span data-stu-id="1357b-126">Local functions are converted to delegates only when used as a delegate.</span></span> <span data-ttu-id="1357b-127">Se si dichiara una funzione locale e fare riferimento solo quando viene chiamata come un metodo, non essere convertito in un delegato.</span><span class="sxs-lookup"><span data-stu-id="1357b-127">If you declare a local function and only reference it by calling it like a method, it will not be converted to a delegate.</span></span> <span data-ttu-id="1357b-128">Tale regola consente di dichiarare una funzione locale in qualsiasi posizione appropriata nel relativo ambito contenitore.</span><span class="sxs-lookup"><span data-stu-id="1357b-128">That rule enables you to declare a local function at any convenient location in its enclosing scope.</span></span> <span data-ttu-id="1357b-129">È comune per dichiarare le funzioni locali alla fine del metodo padre, dopo le istruzioni return.</span><span class="sxs-lookup"><span data-stu-id="1357b-129">It's common to declare local functions at the end of the parent method, after any return statements.</span></span>

<span data-ttu-id="1357b-130">In terzo luogo, il compilatore può eseguire l'analisi statica che consente di funzioni locali assegnare in modo definitivo variabili acquisite nell'ambito di inclusione.</span><span class="sxs-lookup"><span data-stu-id="1357b-130">Third, the compiler can perform static analysis that enables local functions to definitely assign captured variables in the enclosing scope.</span></span> <span data-ttu-id="1357b-131">Si consideri l'esempio seguente:</span><span class="sxs-lookup"><span data-stu-id="1357b-131">Consider this example:</span></span>

```csharp
bool M()
{
    int y;
    Local();
    return y;

    void Local() => y = 0;
}
```

<span data-ttu-id="1357b-132">Il compilatore può determinare che `Local` sicuramente assegna `y` quando viene chiamato.</span><span class="sxs-lookup"><span data-stu-id="1357b-132">The compiler can determine that `Local` definitely assigns `y` when called.</span></span> <span data-ttu-id="1357b-133">Poiché `Local` viene chiamato prima di `return` istruzione `y` definitiely assegnata nel `return` istruzione.</span><span class="sxs-lookup"><span data-stu-id="1357b-133">Because `Local` is called before the `return` statement, `y` is definitiely assigned at the `return` statement.</span></span>

<span data-ttu-id="1357b-134">L'analisi che consente di eseguire analisi che consente la quarta differenza.</span><span class="sxs-lookup"><span data-stu-id="1357b-134">The analysis that enables that analysis enables the fourth difference.</span></span>
<span data-ttu-id="1357b-135">A seconda del loro utilizzo, le funzioni locali possono evitare le allocazioni di heap sono sempre necessari per le espressioni lambda.</span><span class="sxs-lookup"><span data-stu-id="1357b-135">Depending on their use, local functions can avoid heap allocations that are always necessary for lambda expressions.</span></span> <span data-ttu-id="1357b-136">Se una funzione locale non viene mai convertita in un delegato e nessuna delle variabili acquisite dalla funzione locale vengono acquisita da altre espressioni lambda o funzioni locali che vengono convertite in delegati, il compilatore può evitare allocazioni di heap.</span><span class="sxs-lookup"><span data-stu-id="1357b-136">If a local function is never converted to a delegate, and none of the variables captured by the local function is captured by other lambdas or local functions that are converted to delegates, the compiler can avoid heap allocations.</span></span> 

<span data-ttu-id="1357b-137">Si consideri questo esempio asincrono:</span><span class="sxs-lookup"><span data-stu-id="1357b-137">Consider this async example:</span></span>

[!code-csharp[TaskLambdaExample](../../samples/snippets/csharp/new-in-7/AsyncWork.cs#36_TaskLambdaExample "Task returning method with lambda expression")]

<span data-ttu-id="1357b-138">La chiusura per questa espressione lambda contiene le variabili `address`, `index` e `name`.</span><span class="sxs-lookup"><span data-stu-id="1357b-138">The closure for this lambda expression contains the `address`, `index` and `name` variables.</span></span> <span data-ttu-id="1357b-139">Nel caso delle funzioni locali, l'oggetto che implementa la chiusura può essere di tipo `struct`</span><span class="sxs-lookup"><span data-stu-id="1357b-139">In the case of local functions, the object that implements the closure may be a `struct` type.</span></span> <span data-ttu-id="1357b-140">Che tipo di struct verrebbe passato per riferimento alla funzione locale.</span><span class="sxs-lookup"><span data-stu-id="1357b-140">That struct type would be passed by reference to the local function.</span></span> <span data-ttu-id="1357b-141">Questa differenza di implementazione verrà salvate in un'allocazione.</span><span class="sxs-lookup"><span data-stu-id="1357b-141">This difference in implementation would save on an allocation.</span></span>

<span data-ttu-id="1357b-142">La creazione di istanze necessarie per le espressioni lambda significa che le allocazioni di memoria aggiuntiva, che possono essere un fattore di prestazioni nei percorsi di codice critico.</span><span class="sxs-lookup"><span data-stu-id="1357b-142">The instantiation necessary for lambda expressions means extra memory allocations, which may be a performance factor in time-critical code paths.</span></span>
<span data-ttu-id="1357b-143">Questo sovraccarico non si verifica per le funzioni locali.</span><span class="sxs-lookup"><span data-stu-id="1357b-143">Local functions do not incur this overhead.</span></span> <span data-ttu-id="1357b-144">Nell'esempio precedente, la versione con funzioni locali presenta due allocazioni in meno rispetto alla versione con espressioni lambda.</span><span class="sxs-lookup"><span data-stu-id="1357b-144">In the example above, the local functions version has 2 fewer allocations than the lambda expression version.</span></span>

> [!NOTE]
> <span data-ttu-id="1357b-145">La funzione locale equivalente di questo metodo usa anche una classe per la chiusura.</span><span class="sxs-lookup"><span data-stu-id="1357b-145">The local function equivalent of this method also uses a class for the closure.</span></span> <span data-ttu-id="1357b-146">Se la chiusura di una funzione locale viene implementata come `class` o `struct` non ha molta importanza.</span><span class="sxs-lookup"><span data-stu-id="1357b-146">Whether the closure for a local function is implemented as a `class` or a `struct` is an implementation detail.</span></span> <span data-ttu-id="1357b-147">Una funzione locale può usare `struct` mentre un'espressione lambda userà sempre `class`.</span><span class="sxs-lookup"><span data-stu-id="1357b-147">A local function may use a `struct` whereas a lambda will always use a `class`.</span></span>

[!code-csharp[TaskLocalFunctionExample](../../samples/snippets/csharp/new-in-7/AsyncWork.cs#29_TaskExample "Task returning method with local function")]

<span data-ttu-id="1357b-148">Come ultimo vantaggio, non illustrato in questo esempio, le funzioni locali possono essere implementate come iteratori usando la sintassi `yield return` per produrre una sequenza di valori.</span><span class="sxs-lookup"><span data-stu-id="1357b-148">One final advantage not demonstrated in this sample is that local functions can be implemented as iterators, using the `yield return` syntax to produce a sequence of values.</span></span> <span data-ttu-id="1357b-149">Il `yield return` istruzione non è consentita nelle espressioni lambda.</span><span class="sxs-lookup"><span data-stu-id="1357b-149">The `yield return` statement is not allowed in lambda expressions.</span></span>

<span data-ttu-id="1357b-150">Sebbene le funzioni locali possano apparire ridondanti rispetto alle espressioni lambda, in realtà hanno finalità e usi diversi.</span><span class="sxs-lookup"><span data-stu-id="1357b-150">While local functions may seem redundant to lambda expressions, they actually serve different purposes and have different uses.</span></span>
<span data-ttu-id="1357b-151">Le funzioni locali sono più efficienti nel caso si voglia scrivere una funzione che viene chiamata solo dal contesto di un altro metodo.</span><span class="sxs-lookup"><span data-stu-id="1357b-151">Local functions are more efficient for the case when you want to write a function that is called only from the context of another method.</span></span>
