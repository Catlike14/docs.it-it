---
title: Tipi di base - Guida a C#
description: Informazioni sui tipi di base (dati numerici, stringhe e oggetto) in tutti i programmi C#
keywords: .NET, .NET Core, C#
author: BillWagner
ms.author: wiwagn
ms.date: 10/10/2016
ms.topic: article
ms.prod: .net
ms.technology: devlang-csharp
ms.devlang: csharp
ms.assetid: 95c686ba-ae4f-440e-8e94-0dbd6e04d11f
ms.openlocfilehash: 398a73f72a9a31c6b2a19a626f704f65564f4fbd
ms.sourcegitcommit: bbde43da655ae7bea1977f7af7345eb87bd7fd5f
ms.translationtype: HT
ms.contentlocale: it-IT
ms.lasthandoff: 10/21/2017
---
# <a name="types-variables-and-values"></a><span data-ttu-id="4b21a-104">Tipi, variabili e valori</span><span class="sxs-lookup"><span data-stu-id="4b21a-104">Types, variables, and values</span></span>  
<span data-ttu-id="4b21a-105">C# è un linguaggio fortemente tipizzato.</span><span class="sxs-lookup"><span data-stu-id="4b21a-105">C# is a strongly-typed language.</span></span> <span data-ttu-id="4b21a-106">Ogni variabile e costante ha un tipo, così come ogni espressione che restituisce un valore.</span><span class="sxs-lookup"><span data-stu-id="4b21a-106">Every variable and constant has a type, as does every expression that evaluates to a value.</span></span> <span data-ttu-id="4b21a-107">Ogni firma del metodo specifica un tipo per ogni parametro di input e per il valore restituito.</span><span class="sxs-lookup"><span data-stu-id="4b21a-107">Every method signature specifies a type for each input parameter and for the return value.</span></span> <span data-ttu-id="4b21a-108">La libreria di classi .NET Framework definisce un set di tipi numerici incorporati, oltre a tipi più complessi che rappresentano un'ampia gamma di costrutti logici, ad esempio il file system, le connessioni di rete, le raccolte e le matrici di oggetti e le date.</span><span class="sxs-lookup"><span data-stu-id="4b21a-108">The .NET Framework class library defines a set of built-in numeric types as well as more complex types that represent a wide variety of logical constructs, such as the file system, network connections, collections and arrays of objects, and dates.</span></span> <span data-ttu-id="4b21a-109">Un tipico programma C# usa tipi dalla libreria di classi e tipi definiti dall'utente che modellano i concetti specifici del dominio relativo al problema del programma.</span><span class="sxs-lookup"><span data-stu-id="4b21a-109">A typical C# program uses types from the class library as well as user-defined types that model the concepts that are specific to the program's problem domain.</span></span>  
  
<span data-ttu-id="4b21a-110">Le informazioni archiviate in un tipo possono includere quanto segue:</span><span class="sxs-lookup"><span data-stu-id="4b21a-110">The information stored in a type can include the following:</span></span>  
  
-   <span data-ttu-id="4b21a-111">Lo spazio di archiviazione richiesto da una variabile del tipo.</span><span class="sxs-lookup"><span data-stu-id="4b21a-111">The storage space that a variable of the type requires.</span></span>  
  
-   <span data-ttu-id="4b21a-112">I valori minimi e massimi che può rappresentare.</span><span class="sxs-lookup"><span data-stu-id="4b21a-112">The maximum and minimum values that it can represent.</span></span>  
  
-   <span data-ttu-id="4b21a-113">I membri (metodi, campi, eventi e così via) in esso contenuti.</span><span class="sxs-lookup"><span data-stu-id="4b21a-113">The members (methods, fields, events, and so on) that it contains.</span></span>  
  
-   <span data-ttu-id="4b21a-114">Il tipo di base da cui eredita.</span><span class="sxs-lookup"><span data-stu-id="4b21a-114">The base type it inherits from.</span></span>  
  
-   <span data-ttu-id="4b21a-115">Il percorso in cui viene allocata la memoria per le variabili in fase di esecuzione.</span><span class="sxs-lookup"><span data-stu-id="4b21a-115">The location where the memory for variables will be allocated at run time.</span></span>  
  
-   <span data-ttu-id="4b21a-116">I tipi di operazioni consentite.</span><span class="sxs-lookup"><span data-stu-id="4b21a-116">The kinds of operations that are permitted.</span></span>  
  
<span data-ttu-id="4b21a-117">Il compilatore usa le informazioni sul tipo per assicurarsi che tutte le operazioni eseguite nel codice siano *indipendenti dai tipi*.</span><span class="sxs-lookup"><span data-stu-id="4b21a-117">The compiler uses type information to make sure that all operations that are performed in your code are *type safe*.</span></span> <span data-ttu-id="4b21a-118">Se ad esempio si dichiara una variabile di tipo [int](language-reference/keywords/int.md), il compilatore consente di usare la variabile anche in operazioni di addizione e sottrazione.</span><span class="sxs-lookup"><span data-stu-id="4b21a-118">For example, if you declare a variable of type [int](language-reference/keywords/int.md), the compiler allows you to use the variable in addition and subtraction operations.</span></span> <span data-ttu-id="4b21a-119">Se si prova a eseguire le stesse operazioni su una variabile di tipo [bool](language-reference/keywords/bool.md), il compilatore genera un errore, come illustrato nell'esempio seguente:</span><span class="sxs-lookup"><span data-stu-id="4b21a-119">If you try to perform those same operations on a variable of type [bool](language-reference/keywords/bool.md), the compiler generates an error, as shown in the following example:</span></span>  
  
[!code-csharp[Type Safety](../../samples/snippets/csharp/concepts/basic-types/type-safety.cs)]  
  
> [!NOTE]  
>  <span data-ttu-id="4b21a-120">Gli sviluppatori C e C++ devono tenere presente che, in C#, [bool](language-reference/keywords/bool.md) non è convertibile in [int](language-reference/keywords/int.md).</span><span class="sxs-lookup"><span data-stu-id="4b21a-120">C and C++ developers, notice that in C#, [bool](language-reference/keywords/bool.md) is not convertible to [int](language-reference/keywords/int.md).</span></span>  
  
<span data-ttu-id="4b21a-121">Il compilatore incorpora le informazioni sul tipo nel file eseguibile come metadati.</span><span class="sxs-lookup"><span data-stu-id="4b21a-121">The compiler embeds the type information into the executable file as metadata.</span></span> <span data-ttu-id="4b21a-122">Common Language Runtime (CLR) usa i metadati in fase di esecuzione per garantire ulteriormente l'indipendenza dai tipi quando alloca e recupera la memoria.</span><span class="sxs-lookup"><span data-stu-id="4b21a-122">The common language runtime (CLR) uses that metadata at run time to further guarantee type safety when it allocates and reclaims memory.</span></span>  

## <a name="specifying-types-in-variable-declarations"></a><span data-ttu-id="4b21a-123">Specifica dei tipi nelle dichiarazioni di variabile</span><span class="sxs-lookup"><span data-stu-id="4b21a-123">Specifying types in variable declarations</span></span>  
<span data-ttu-id="4b21a-124">Quando si dichiara una variabile o costante in un programma, è necessario specificarne il tipo oppure usare la parola chiave [var](language-reference/keywords/var.md) per consentire al compilatore di dedurre il tipo.</span><span class="sxs-lookup"><span data-stu-id="4b21a-124">When you declare a variable or constant in a program, you must either specify its type or use the [var](language-reference/keywords/var.md) keyword to let the compiler infer the type.</span></span> <span data-ttu-id="4b21a-125">L'esempio seguente illustra alcune dichiarazioni di variabili che usano sia tipi numerici incorporati sia tipi complessi definiti dall'utente:</span><span class="sxs-lookup"><span data-stu-id="4b21a-125">The following example shows some variable declarations that use both built-in numeric types and complex user-defined types:</span></span>  
  
[!code-csharp[Variable Declaration](../../samples/snippets/csharp/concepts/basic-types/variable-declaration.cs)]  
  
<span data-ttu-id="4b21a-126">I tipi di parametri e valori restituiti del metodo sono specificati nella firma del metodo.</span><span class="sxs-lookup"><span data-stu-id="4b21a-126">The types of method parameters and return values are specified in the method signature.</span></span> <span data-ttu-id="4b21a-127">La firma seguente illustra un metodo che richiede un [int](language-reference/keywords/int.md) come argomento di input e restituisce una stringa:</span><span class="sxs-lookup"><span data-stu-id="4b21a-127">The following signature shows a method that requires an [int](language-reference/keywords/int.md) as an input argument and returns a string:</span></span>  
  
[!code-csharp[Method Signature](../../samples/snippets/csharp/concepts/basic-types/method-signature.cs)]  
  
<span data-ttu-id="4b21a-128">Una variabile dichiarata non può essere dichiarata una seconda volta con un tipo nuovo e non è possibile assegnare a tale variabile un valore non compatibile con il relativo tipo dichiarato.</span><span class="sxs-lookup"><span data-stu-id="4b21a-128">After a variable is declared, it cannot be re-declared with a new type, and it cannot be assigned a value that is not compatible with its declared type.</span></span> <span data-ttu-id="4b21a-129">Non è possibile, ad esempio, dichiarare una variabile [int](language-reference/keywords/int.md) e assegnare ad essa il valore booleano [true](language-reference/keywords/true.md).</span><span class="sxs-lookup"><span data-stu-id="4b21a-129">For example, you cannot declare an [int](language-reference/keywords/int.md) and then assign it a Boolean value of [true](language-reference/keywords/true.md).</span></span> <span data-ttu-id="4b21a-130">I valori possono tuttavia essere convertiti in altri tipi, ad esempio quando vengono assegnati a nuove variabili o passati come argomenti di metodo.</span><span class="sxs-lookup"><span data-stu-id="4b21a-130">However, values can be converted to other types, for example when they are assigned to new variables or passed as method arguments.</span></span> <span data-ttu-id="4b21a-131">Una *conversione del tipo* che non causa la perdita di dati viene eseguita automaticamente dal compilatore,</span><span class="sxs-lookup"><span data-stu-id="4b21a-131">A *type conversion* that does not cause data loss is performed automatically by the compiler.</span></span> <span data-ttu-id="4b21a-132">Una conversione che potrebbe causare la perdita di dati richiede un *cast* nel codice sorgente.</span><span class="sxs-lookup"><span data-stu-id="4b21a-132">A conversion that might cause data loss requires a *cast* in the source code.</span></span> 

<span data-ttu-id="4b21a-133">Per altre informazioni, vedere [Cast e conversioni di tipi](programming-guide/types/casting-and-type-conversions.md).</span><span class="sxs-lookup"><span data-stu-id="4b21a-133">For more information, see [Casting and type conversions](programming-guide/types/casting-and-type-conversions.md).</span></span>
 
## <a name="built-in-types"></a><span data-ttu-id="4b21a-134">Tipi incorporati</span><span class="sxs-lookup"><span data-stu-id="4b21a-134">Built-in types</span></span>
<span data-ttu-id="4b21a-135">Il linguaggio C# offre un set standard di tipi numerici predefiniti per rappresentare numeri interi, valori a virgola mobile, espressioni booleane, caratteri di testo, valori decimali e altri tipi di dati.</span><span class="sxs-lookup"><span data-stu-id="4b21a-135">C# provides a standard set of built-in numeric types to represent integers, floating point values, Boolean expressions, text characters, decimal values, and other types of data.</span></span> <span data-ttu-id="4b21a-136">Sono anche disponibili tipi **string** e **object** predefiniti.</span><span class="sxs-lookup"><span data-stu-id="4b21a-136">There are also built-in **string** and **object** types.</span></span> <span data-ttu-id="4b21a-137">Questi possono essere usati in qualsiasi programma C#.</span><span class="sxs-lookup"><span data-stu-id="4b21a-137">These are available for you to use in any C# program.</span></span> <span data-ttu-id="4b21a-138">Per altre informazioni sui tipi incorporati, vedere [Tabelle di riferimento per i tipi](language-reference/keywords/reference-tables-for-types.md).</span><span class="sxs-lookup"><span data-stu-id="4b21a-138">For a more information about the built-in types, see [Reference table for types](language-reference/keywords/reference-tables-for-types.md).</span></span>  
  
## <a name="custom-types"></a><span data-ttu-id="4b21a-139">Tipi personalizzati</span><span class="sxs-lookup"><span data-stu-id="4b21a-139">Custom types</span></span>  
<span data-ttu-id="4b21a-140">Usare i costrutti [struct](language-reference/keywords/class.md), [class](language-reference/keywords/class.md), [interface](language-reference/keywords/interface.md) e [enum](language-reference/keywords/enum.md) per creare tipi personalizzati.</span><span class="sxs-lookup"><span data-stu-id="4b21a-140">You use the [struct](language-reference/keywords/class.md), [class](language-reference/keywords/class.md), [interface](language-reference/keywords/interface.md), and [enum](language-reference/keywords/enum.md) constructs to create your own custom types.</span></span> <span data-ttu-id="4b21a-141">La libreria di classi .NET Framework è una raccolta di tipi personalizzati offerti da Microsoft che è possibile usare nelle nuove applicazioni.</span><span class="sxs-lookup"><span data-stu-id="4b21a-141">The .NET Framework class library itself is a collection of custom types provided by Microsoft that you can use in your own applications.</span></span> <span data-ttu-id="4b21a-142">Per impostazione predefinita, i tipi più comunemente usati nella libreria di classi sono disponibili in qualsiasi programma C#,</span><span class="sxs-lookup"><span data-stu-id="4b21a-142">By default, the most frequently used types in the class library are available in any C# program.</span></span> <span data-ttu-id="4b21a-143">mentre altri diventano disponibili solo quando si aggiunge in modo esplicito un riferimento di progetto all'assembly in cui sono definiti.</span><span class="sxs-lookup"><span data-stu-id="4b21a-143">Others become available only when you explicitly add a project reference to the assembly in which they are defined.</span></span> <span data-ttu-id="4b21a-144">Nel momento in cui il compilatore ha un riferimento all'assembly, è possibile dichiarare variabili (e costanti) dei tipi dichiarati nell'assembly in codice sorgente.</span><span class="sxs-lookup"><span data-stu-id="4b21a-144">After the compiler has a reference to the assembly, you can declare variables (and constants) of the types declared in that assembly in source code.</span></span> 
  
## <a name="generic-types"></a><span data-ttu-id="4b21a-145">Tipi generici</span><span class="sxs-lookup"><span data-stu-id="4b21a-145">Generic types</span></span>  
<span data-ttu-id="4b21a-146">Un tipo può essere dichiarato con uno o più *parametri di tipo* che fungono da segnaposto per il tipo effettivo (*tipo concreto*) che il codice client specifica quando si crea un'istanza del tipo.</span><span class="sxs-lookup"><span data-stu-id="4b21a-146">A type can be declared with one or more *type parameters* that serve as a placeholder for the actual type (the *concrete type*) that client code will provide when it creates an instance of the type.</span></span> <span data-ttu-id="4b21a-147">Questi tipi sono definiti *tipi generici*.</span><span class="sxs-lookup"><span data-stu-id="4b21a-147">Such types are called *generic types*.</span></span> <span data-ttu-id="4b21a-148">Ad esempio, il tipo <xref:System.Collections.Generic.List%601> di .NET Framework ha un solo parametro a cui, per convenzione, viene assegnato il nome *T*. Quando si crea un'istanza del tipo, si specifica il tipo degli oggetti che saranno contenuti nell'elenco, ad esempio, string:</span><span class="sxs-lookup"><span data-stu-id="4b21a-148">For example, the .NET Framework type <xref:System.Collections.Generic.List%601> has one type parameter that by convention is given the name *T*. When you create an instance of the type, you specify the type of the objects that the list will contain, for example, string:</span></span>  
  
[!code-csharp[Generic types](../../samples/snippets/csharp/concepts/basic-types/generic-type.cs)] 
  
<span data-ttu-id="4b21a-149">L'uso del parametro di tipo consente di riutilizzare la stessa classe per contenere qualsiasi tipo di elemento senza dover convertire ogni elemento in [object](language-reference/keywords/object.md).</span><span class="sxs-lookup"><span data-stu-id="4b21a-149">The use of the type parameter makes it possible to reuse the same class to hold any type of element, without having to convert each element to [object](language-reference/keywords/object.md).</span></span> <span data-ttu-id="4b21a-150">Le classi di raccolte generiche sono definite *raccolte fortemente tipizzate* perché il compilatore conosce il tipo specifico degli elementi della raccolta e può generare un errore in fase di compilazione se, ad esempio, si prova ad aggiungere un numero intero all'oggetto `strings` nell'esempio precedente.</span><span class="sxs-lookup"><span data-stu-id="4b21a-150">Generic collection classes are called *strongly-typed collections* because the compiler knows the specific type of the collection's elements and can raise an error at compile-time if, for example, you try to add an integer to the `strings` object in the previous example.</span></span> <span data-ttu-id="4b21a-151">Per altre informazioni, vedere [Generics](programming-guide/generics/index.md).</span><span class="sxs-lookup"><span data-stu-id="4b21a-151">For more information, see [Generics](programming-guide/generics/index.md).</span></span> 

## <a name="implicit-types-anonymous-types-and-tuple-types"></a><span data-ttu-id="4b21a-152">Tipi impliciti, tipi anonimi e tipi di tupla</span><span class="sxs-lookup"><span data-stu-id="4b21a-152">Implicit types, anonymous types, and tuple types</span></span>  
<span data-ttu-id="4b21a-153">Come indicato in precedenza, è possibile digitare una variabile locale in modo implicito usando la parola chiave [var](language-reference/keywords/var.md).</span><span class="sxs-lookup"><span data-stu-id="4b21a-153">As stated previously, you can implicitly type a local variable (but not class members) by using the [var](language-reference/keywords/var.md) keyword.</span></span> <span data-ttu-id="4b21a-154">A tale variabile viene comunque assegnato un tipo in fase di compilazione, ma il tipo viene specificato dal compilatore.</span><span class="sxs-lookup"><span data-stu-id="4b21a-154">The variable still receives a type at compile time, but the type is provided by the compiler.</span></span> <span data-ttu-id="4b21a-155">Per altre informazioni, vedere [Variabili locali tipizzate in modo implicito](programming-guide/classes-and-structs/implicitly-typed-local-variables.md).</span><span class="sxs-lookup"><span data-stu-id="4b21a-155">For more information, see [Implicitly typed local variables](programming-guide/classes-and-structs/implicitly-typed-local-variables.md).</span></span>  
  
<span data-ttu-id="4b21a-156">In alcuni casi non è consigliabile creare un tipo denominato per set semplici di valori correlati che non si intende archiviare o passare fuori dai limiti del metodo.</span><span class="sxs-lookup"><span data-stu-id="4b21a-156">In some cases, it is inconvenient to create a named type for simple sets of related values that you do not intend to store or pass outside method boundaries.</span></span> <span data-ttu-id="4b21a-157">A questo scopo è possibile creare *tipi anonimi*.</span><span class="sxs-lookup"><span data-stu-id="4b21a-157">You can create *anonymous types* for this purpose.</span></span> <span data-ttu-id="4b21a-158">Per altre informazioni, vedere [Tipi anonimi](programming-guide/classes-and-structs/anonymous-types.md).</span><span class="sxs-lookup"><span data-stu-id="4b21a-158">For more information, see [Anonymous types](programming-guide/classes-and-structs/anonymous-types.md).</span></span>

<span data-ttu-id="4b21a-159">È prassi comune voler restituire più valori da un metodo.</span><span class="sxs-lookup"><span data-stu-id="4b21a-159">It's common to want to return more than one value from a method.</span></span> <span data-ttu-id="4b21a-160">È possibile creare *tipi di tupla* che restituiscono più valori in una singola chiamata al metodo.</span><span class="sxs-lookup"><span data-stu-id="4b21a-160">You can create *tuple types* that return multiple values in a single method call.</span></span> <span data-ttu-id="4b21a-161">Per altre informazioni, vedere [Tuple](tuples.md)</span><span class="sxs-lookup"><span data-stu-id="4b21a-161">For more information, see [Tuples](tuples.md)</span></span>

## <a name="the-common-type-system"></a><span data-ttu-id="4b21a-162">Sistema dei tipi comuni</span><span class="sxs-lookup"><span data-stu-id="4b21a-162">The Common type system</span></span>  
<span data-ttu-id="4b21a-163">È importante capire due punti fondamentali sul sistema dei tipi in .NET Framework:</span><span class="sxs-lookup"><span data-stu-id="4b21a-163">It is important to understand two fundamental points about the type system in the .NET Framework:</span></span>  
  
-   <span data-ttu-id="4b21a-164">Il tipo supporta il principio di ereditarietà.</span><span class="sxs-lookup"><span data-stu-id="4b21a-164">It supports the principle of inheritance.</span></span> <span data-ttu-id="4b21a-165">I tipi possono derivare da altri tipi, denominati *tipi di base*.</span><span class="sxs-lookup"><span data-stu-id="4b21a-165">Types can derive from other types, called *base types*.</span></span> <span data-ttu-id="4b21a-166">Il tipo derivato eredita (con alcune limitazioni) metodi, proprietà e altri membri del tipo di base,</span><span class="sxs-lookup"><span data-stu-id="4b21a-166">The derived type inherits (with some restrictions) the methods, properties, and other members of the base type.</span></span> <span data-ttu-id="4b21a-167">Il tipo di base può a sua volta derivare da un altro tipo, nel quale caso il tipo derivato eredita i membri di entrambi i tipi di base nella gerarchia di ereditarietà.</span><span class="sxs-lookup"><span data-stu-id="4b21a-167">The base type can in turn derive from some other type, in which case the derived type inherits the members of both base types in its inheritance hierarchy.</span></span> <span data-ttu-id="4b21a-168">Tutti i tipi, inclusi i tipi numerici predefiniti, ad esempio <xref:System.Int32> (parola chiave C#: `int`), derivano in definitiva da un unico tipo di base, ovvero <xref:System.Object> (parola chiave C#: `object`).</span><span class="sxs-lookup"><span data-stu-id="4b21a-168">All types, including built-in numeric types such as <xref:System.Int32> (C# keyword: `int`), derive ultimately from a single base type, which is <xref:System.Object> (C# keyword: `object`).</span></span> <span data-ttu-id="4b21a-169">Questa gerarchia di tipi unificati viene chiamata [Common Type System](../standard/common-type-system.md) (CTS).</span><span class="sxs-lookup"><span data-stu-id="4b21a-169">This unified type hierarchy is called the [Common type system](../standard/common-type-system.md) (CTS).</span></span> <span data-ttu-id="4b21a-170">Per altre informazioni sull'ereditarietà in C#, vedere [Ereditarietà](programming-guide/classes-and-structs/inheritance.md).</span><span class="sxs-lookup"><span data-stu-id="4b21a-170">For more information about inheritance in C#, see [Inheritance](programming-guide/classes-and-structs/inheritance.md).</span></span>  
  
-   <span data-ttu-id="4b21a-171">Nel CTS ogni tipo è definito come *tipo valore* o *tipo riferimento*.</span><span class="sxs-lookup"><span data-stu-id="4b21a-171">Each type in the CTS is defined as either a *value type* or a *reference type*.</span></span> <span data-ttu-id="4b21a-172">Ciò include tutti i tipi personalizzati nella libreria di classi .NET Framework, nonché i tipi definiti dall'utente.</span><span class="sxs-lookup"><span data-stu-id="4b21a-172">This includes all custom types in the .NET Framework class library and also your own user-defined types.</span></span> <span data-ttu-id="4b21a-173">I tipi definiti tramite la parola chiave [struct](language-reference/keywords/struct.md) sono tipi di valore e tutti i tipi numerici predefiniti sono tipi **struct**.</span><span class="sxs-lookup"><span data-stu-id="4b21a-173">Types that you define by using the [struct](language-reference/keywords/struct.md) keyword are value types; all the built-in numeric types are **structs**.</span></span> <span data-ttu-id="4b21a-174">Per altre informazioni sui tipi di valori, vedere [Struct](structs.md).</span><span class="sxs-lookup"><span data-stu-id="4b21a-174">For more information about value types, see [Structs](structs.md).</span></span> <span data-ttu-id="4b21a-175">I tipi definiti tramite la parola chiave [class](language-reference/keywords/class.md) sono tipi di riferimento.</span><span class="sxs-lookup"><span data-stu-id="4b21a-175">Types that you define by using the [class](language-reference/keywords/class.md) keyword are reference types.</span></span> <span data-ttu-id="4b21a-176">Per altre informazioni sui tipi di riferimento, vedere [Classi](classes.md).</span><span class="sxs-lookup"><span data-stu-id="4b21a-176">For more information about reference types, see [Classes](classes.md).</span></span> <span data-ttu-id="4b21a-177">I tipi di riferimento e i tipi di valore hanno regole diverse e un comportamento diverso in fase di esecuzione.</span><span class="sxs-lookup"><span data-stu-id="4b21a-177">Reference types and value types have different compile-time rules, and different run-time behavior.</span></span>
 
  
## <a name="see-also"></a><span data-ttu-id="4b21a-178">Vedere anche</span><span class="sxs-lookup"><span data-stu-id="4b21a-178">See also</span></span>
<span data-ttu-id="4b21a-179">[Struct](structs.md)
[Classi](classes.md)</span><span class="sxs-lookup"><span data-stu-id="4b21a-179">[Structs](structs.md)
[Classes](classes.md)</span></span>
