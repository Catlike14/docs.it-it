---
title: 'Procedura: Scorrere un albero di directory (Guida per programmatori C#)'
ms.date: 07/20/2015
ms.prod: .net
ms.technology:
- devlang-csharp
ms.topic: article
helpviewer_keywords:
- iterating through folders [C#]
- file iteration [C#]
ms.assetid: c4be4a75-6b1b-46a7-9d38-bab353091ed7
caps.latest.revision: 
author: BillWagner
ms.author: wiwagn
ms.openlocfilehash: 7f45bdc4a08922842b079be3ef9d112693ca5d7a
ms.sourcegitcommit: 75a180acb5d8a2dbd4a52915ce8e980749fb1d05
ms.translationtype: HT
ms.contentlocale: it-IT
ms.lasthandoff: 02/24/2018
---
# <a name="how-to-iterate-through-a-directory-tree-c-programming-guide"></a><span data-ttu-id="477d6-102">Procedura: Scorrere un albero di directory (Guida per programmatori C#)</span><span class="sxs-lookup"><span data-stu-id="477d6-102">How to: Iterate Through a Directory Tree (C# Programming Guide)</span></span>
<span data-ttu-id="477d6-103">Eseguire l'iterazione in un albero di directory significa accedere a ogni file in ogni sottodirectory annidata in una cartella radice specificata, a qualsiasi livello.</span><span class="sxs-lookup"><span data-stu-id="477d6-103">The phrase "iterate a directory tree" means to access each file in each nested subdirectory under a specified root folder, to any depth.</span></span> <span data-ttu-id="477d6-104">Non è necessario aprire ogni file.</span><span class="sxs-lookup"><span data-stu-id="477d6-104">You do not necessarily have to open each file.</span></span> <span data-ttu-id="477d6-105">È possibile recuperare semplicemente il nome del file o della sottodirectory come `string` oppure è possibile recuperare informazioni aggiuntive sotto forma di oggetto <xref:System.IO.FileInfo?displayProperty=nameWithType> o <xref:System.IO.DirectoryInfo?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="477d6-105">You can just retrieve the name of the file or subdirectory as a `string`, or you can retrieve additional information in the form of a <xref:System.IO.FileInfo?displayProperty=nameWithType> or <xref:System.IO.DirectoryInfo?displayProperty=nameWithType> object.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="477d6-106">In Windows i termini "directory" e "cartella" vengono usati indifferentemente.</span><span class="sxs-lookup"><span data-stu-id="477d6-106">In Windows, the terms "directory" and "folder" are used interchangeably.</span></span> <span data-ttu-id="477d6-107">Nella maggior parte della documentazione e dell'interfaccia utente viene usato il termine "cartella", ma nella libreria di classi [!INCLUDE[dnprdnshort](~/includes/dnprdnshort-md.md)] viene usato il termine "directory".</span><span class="sxs-lookup"><span data-stu-id="477d6-107">Most documentation and user interface text uses the term "folder," but the [!INCLUDE[dnprdnshort](~/includes/dnprdnshort-md.md)] class library uses the term "directory."</span></span>  
  
 <span data-ttu-id="477d6-108">Nel caso più semplice in cui si è certi di avere autorizzazioni di accesso per tutte le directory di una radice specificata, è possibile usare il flag `System.IO.SearchOption.AllDirectories`.</span><span class="sxs-lookup"><span data-stu-id="477d6-108">In the simplest case, in which you know for certain that you have access permissions for all directories under a specified root, you can use the `System.IO.SearchOption.AllDirectories` flag.</span></span> <span data-ttu-id="477d6-109">Questo flag restituisce tutte le sottodirectory annidate che corrispondono al modello specificato.</span><span class="sxs-lookup"><span data-stu-id="477d6-109">This flag returns all the nested subdirectories that match the specified pattern.</span></span> <span data-ttu-id="477d6-110">L'esempio seguente illustra come usare questo flag.</span><span class="sxs-lookup"><span data-stu-id="477d6-110">The following example shows how to use this flag.</span></span>  
  
```csharp  
root.GetDirectories("*.*", System.IO.SearchOption.AllDirectories);  
```  
  
 <span data-ttu-id="477d6-111">Il problema di questo approccio è che se una delle sottodirectory della radice specificata genera un'eccezione <xref:System.IO.DirectoryNotFoundException> o <xref:System.UnauthorizedAccessException>, l'intero metodo ha esito negativo e non restituisce alcuna directory.</span><span class="sxs-lookup"><span data-stu-id="477d6-111">The weakness in this approach is that if any one of the subdirectories under the specified root causes a <xref:System.IO.DirectoryNotFoundException> or <xref:System.UnauthorizedAccessException>, the whole method fails and returns no directories.</span></span> <span data-ttu-id="477d6-112">Lo stesso vale quando si usa il metodo <xref:System.IO.DirectoryInfo.GetFiles%2A>.</span><span class="sxs-lookup"><span data-stu-id="477d6-112">The same is true when you use the <xref:System.IO.DirectoryInfo.GetFiles%2A> method.</span></span> <span data-ttu-id="477d6-113">Se è necessario gestire queste eccezioni in sottocartelle specifiche, procedere manualmente nell'albero di directory, come illustrato negli esempi seguenti.</span><span class="sxs-lookup"><span data-stu-id="477d6-113">If you have to handle these exceptions on specific subfolders, you must manually walk the directory tree, as shown in the following examples.</span></span>  
  
 <span data-ttu-id="477d6-114">Quando si procede manualmente in un albero di directory, è possibile gestire prima le sottodirectory (*attraversamento pre-ordine*), o prima i file (*attraversamento post-ordine*).</span><span class="sxs-lookup"><span data-stu-id="477d6-114">When you manually walk a directory tree, you can handle the subdirectories first (*pre-order traversal*), or the files first (*post-order traversal*).</span></span> <span data-ttu-id="477d6-115">Se si esegue un attraversamento pre-ordine, è necessario procedere lungo l'intero albero della cartella corrente prima di eseguire l'iterazione nei file direttamente in quella cartella.</span><span class="sxs-lookup"><span data-stu-id="477d6-115">If you perform a pre-order traversal, you walk the whole tree under the current folder before iterating through the files that are directly in that folder itself.</span></span> <span data-ttu-id="477d6-116">Gli esempi riportati più avanti nel documento eseguono l'attraversamento post-ordine ma è possibile modificarli per eseguire l'attraversamento pre-ordine.</span><span class="sxs-lookup"><span data-stu-id="477d6-116">The examples later in this document perform post-order traversal, but you can easily modify them to perform pre-order traversal.</span></span>  
  
 <span data-ttu-id="477d6-117">Un'altra opzione consiste nell'usare la ricorsione o l'attraversamento basato su stack.</span><span class="sxs-lookup"><span data-stu-id="477d6-117">Another option is whether to use recursion or a stack-based traversal.</span></span> <span data-ttu-id="477d6-118">Gli esempi più avanti in questo documento illustrano entrambi gli approcci.</span><span class="sxs-lookup"><span data-stu-id="477d6-118">The examples later in this document show both approaches.</span></span>  
  
 <span data-ttu-id="477d6-119">Se è necessario eseguire una serie di operazioni su file e cartelle, è possibile modularizzare questi esempi effettuando il refactoring dell'operazione in funzioni separate che è possibile richiamare tramite un delegato unico.</span><span class="sxs-lookup"><span data-stu-id="477d6-119">If you have to perform a variety of operations on files and folders, you can modularize these examples by refactoring the operation into separate functions that you can invoke by using a single delegate.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="477d6-120">I file system NTFS possono contenere *reparse point* sotto forma di *punti di giunzione*, *collegamenti simbolici* e *collegamenti reali*.</span><span class="sxs-lookup"><span data-stu-id="477d6-120">NTFS file systems can contain *reparse points* in the form of *junction points*, *symbolic links*, and *hard links*.</span></span> <span data-ttu-id="477d6-121">I metodi .NET Framework come <xref:System.IO.DirectoryInfo.GetFiles%2A> e <xref:System.IO.DirectoryInfo.GetDirectories%2A> non restituiranno alcuna sottodirectory in un reparse point.</span><span class="sxs-lookup"><span data-stu-id="477d6-121">The .NET Framework methods such as <xref:System.IO.DirectoryInfo.GetFiles%2A> and <xref:System.IO.DirectoryInfo.GetDirectories%2A> will not return any subdirectories under a reparse point.</span></span> <span data-ttu-id="477d6-122">Questo comportamento protegge dal rischio di entrare in un ciclo infinito quando due reparse point fanno riferimento uno all'altro.</span><span class="sxs-lookup"><span data-stu-id="477d6-122">This behavior guards against the risk of entering into an infinite loop when two reparse points refer to each other.</span></span> <span data-ttu-id="477d6-123">In generale, è necessario usare estrema cautela quando si usano i reparse point per evitare di modificare o eliminare file involontariamente.</span><span class="sxs-lookup"><span data-stu-id="477d6-123">In general, you should use extreme caution when you deal with reparse points to ensure that you do not unintentionally modify or delete files.</span></span> <span data-ttu-id="477d6-124">Se è necessario un controllo preciso dei reparse point, usare platform invoke o codice nativo per chiamare direttamente i metodi del file system Win32 appropriato.</span><span class="sxs-lookup"><span data-stu-id="477d6-124">If you require precise control over reparse points, use platform invoke or native code to call the appropriate Win32 file system methods directly.</span></span>  
  
## <a name="example"></a><span data-ttu-id="477d6-125">Esempio</span><span class="sxs-lookup"><span data-stu-id="477d6-125">Example</span></span>  
 <span data-ttu-id="477d6-126">L'esempio seguente illustra come procedere in un albero di directory usando la ricursione.</span><span class="sxs-lookup"><span data-stu-id="477d6-126">The following example shows how to walk a directory tree by using recursion.</span></span> <span data-ttu-id="477d6-127">L'approccio ricorsivo è elegante ma può provocare un'eccezione di overflow dello stack se l'albero di directory è grande ed eccessivamente annidato.</span><span class="sxs-lookup"><span data-stu-id="477d6-127">The recursive approach is elegant but has the potential to cause a stack overflow exception if the directory tree is large and deeply nested.</span></span>  
  
 <span data-ttu-id="477d6-128">Le eccezioni specifiche che vengono gestite e le azioni specifiche eseguite su ogni file o cartella vengono illustrate solo a titolo esemplificativo.</span><span class="sxs-lookup"><span data-stu-id="477d6-128">The particular exceptions that are handled, and the particular actions that are performed on each file or folder, are provided as examples only.</span></span> <span data-ttu-id="477d6-129">Per soddisfare esigenze specifiche, è necessario modificare il codice.</span><span class="sxs-lookup"><span data-stu-id="477d6-129">You should modify this code to meet your specific requirements.</span></span> <span data-ttu-id="477d6-130">Per altre informazioni, vedere i commenti nel codice.</span><span class="sxs-lookup"><span data-stu-id="477d6-130">See the comments in the code for more information.</span></span>  
  
 [!code-csharp[csFilesandFolders#1](../../../csharp/programming-guide/file-system/codesnippet/CSharp/how-to-iterate-through-a-directory-tree_1.cs)]  
  
## <a name="example"></a><span data-ttu-id="477d6-131">Esempio</span><span class="sxs-lookup"><span data-stu-id="477d6-131">Example</span></span>  
 <span data-ttu-id="477d6-132">Nell'esempio seguente viene illustrato come eseguire l'iterazione nei file e nelle cartelle in un albero di directory senza usare la ricorsione.</span><span class="sxs-lookup"><span data-stu-id="477d6-132">The following example shows how to iterate through files and folders in a directory tree without using recursion.</span></span> <span data-ttu-id="477d6-133">Questa tecnica usa il tipo di raccolta generico <xref:System.Collections.Generic.Stack%601>, che è uno stack LIFO (Last In First Out).</span><span class="sxs-lookup"><span data-stu-id="477d6-133">This technique uses the generic <xref:System.Collections.Generic.Stack%601> collection type, which is a last in first out (LIFO) stack.</span></span>  
  
 <span data-ttu-id="477d6-134">Le eccezioni specifiche che vengono gestite e le azioni specifiche eseguite su ogni file o cartella vengono illustrate solo a titolo esemplificativo.</span><span class="sxs-lookup"><span data-stu-id="477d6-134">The particular exceptions that are handled, and the particular actions that are performed on each file or folder, are provided as examples only.</span></span> <span data-ttu-id="477d6-135">Per soddisfare esigenze specifiche, è necessario modificare il codice.</span><span class="sxs-lookup"><span data-stu-id="477d6-135">You should modify this code to meet your specific requirements.</span></span> <span data-ttu-id="477d6-136">Per altre informazioni, vedere i commenti nel codice.</span><span class="sxs-lookup"><span data-stu-id="477d6-136">See the comments in the code for more information.</span></span>  
  
 [!code-csharp[csFilesandFolders#2](../../../csharp/programming-guide/file-system/codesnippet/CSharp/how-to-iterate-through-a-directory-tree_2.cs)]  
  
 <span data-ttu-id="477d6-137">In genere testare ogni cartella per determinare se l'applicazione ha l'autorizzazione per aprirla richiede troppo tempo.</span><span class="sxs-lookup"><span data-stu-id="477d6-137">It is generally too time-consuming to test every folder to determine whether your application has permission to open it.</span></span> <span data-ttu-id="477d6-138">Pertanto, l'esempio di codice racchiude quella parte dell'operazione in un blocco `try/catch`.</span><span class="sxs-lookup"><span data-stu-id="477d6-138">Therefore, the code example just encloses that part of the operation in a `try/catch` block.</span></span> <span data-ttu-id="477d6-139">È possibile modificare il blocco `catch` in modo che quando l'accesso a una cartella viene negato, si tenti di innalzare il livello delle autorizzazioni e quindi di accedere nuovamente.</span><span class="sxs-lookup"><span data-stu-id="477d6-139">You can modify the `catch` block so that when you are denied access to a folder, you try to elevate your permissions and then access it again.</span></span> <span data-ttu-id="477d6-140">Come regola, rilevare solo le eccezioni che è possibile gestire senza lasciare l'applicazione in uno stato sconosciuto.</span><span class="sxs-lookup"><span data-stu-id="477d6-140">As a rule, only catch those exceptions that you can handle without leaving your application in an unknown state.</span></span>  
  
 <span data-ttu-id="477d6-141">Se è necessario archiviare il contenuto di un albero di directory, in memoria o su disco, l'opzione migliore consiste nell'archiviare solo la proprietà <xref:System.IO.FileSystemInfo.FullName%2A> (di tipo `string`) per ogni file.</span><span class="sxs-lookup"><span data-stu-id="477d6-141">If you must store the contents of a directory tree, either in memory or on disk, the best option is to store only the <xref:System.IO.FileSystemInfo.FullName%2A> property (of type `string`) for each file.</span></span> <span data-ttu-id="477d6-142">È quindi possibile usare questa stringa per creare un nuovo oggetto <xref:System.IO.FileInfo> o <xref:System.IO.DirectoryInfo> in base alle esigenze o aprire i file che richiedono un'elaborazione ulteriore.</span><span class="sxs-lookup"><span data-stu-id="477d6-142">You can then use this string to create a new <xref:System.IO.FileInfo> or <xref:System.IO.DirectoryInfo> object as necessary, or open any file that requires additional processing.</span></span>  
  
## <a name="robust-programming"></a><span data-ttu-id="477d6-143">Programmazione efficiente</span><span class="sxs-lookup"><span data-stu-id="477d6-143">Robust Programming</span></span>  
 <span data-ttu-id="477d6-144">Un codice di iterazione file efficiente deve prendere in considerazione diversi aspetti complessi del file system.</span><span class="sxs-lookup"><span data-stu-id="477d6-144">Robust file iteration code must take into account many complexities of the file system.</span></span> <span data-ttu-id="477d6-145">Per altre informazioni sul file system di Windows, vedere [NTFS Technical Reference](https://technet.microsoft.com/library/81cc8a8a-bd32-4786-a849-03245d68d8e4) (Riferimenti tecnici di NTFS).</span><span class="sxs-lookup"><span data-stu-id="477d6-145">For more information on the Windows file system, see [NTFS Technical Reference](https://technet.microsoft.com/library/81cc8a8a-bd32-4786-a849-03245d68d8e4).</span></span>  
  
## <a name="see-also"></a><span data-ttu-id="477d6-146">Vedere anche</span><span class="sxs-lookup"><span data-stu-id="477d6-146">See Also</span></span>  
 <xref:System.IO>  
 [<span data-ttu-id="477d6-147">Directory di file e LINQ</span><span class="sxs-lookup"><span data-stu-id="477d6-147">LINQ and File Directories</span></span>](../../../csharp/programming-guide/concepts/linq/linq-and-file-directories.md)  
 [<span data-ttu-id="477d6-148">File system e Registro di sistema (Guida per programmatori C#)</span><span class="sxs-lookup"><span data-stu-id="477d6-148">File System and the Registry (C# Programming Guide)</span></span>](../../../csharp/programming-guide/file-system/index.md)
