---
title: Vincoli sui parametri di tipo (Guida per programmatori C#)
ms.date: 07/20/2015
ms.prod: .net
ms.technology: devlang-csharp
ms.topic: article
helpviewer_keywords:
- generics [C#], type constraints
- type constraints [C#]
- type parameters [C#], constraints
- unbound type parameter [C#]
ms.assetid: 141b003e-1ddb-4e1c-bcb2-e1c3870e6a51
caps.latest.revision: "41"
author: BillWagner
ms.author: wiwagn
ms.openlocfilehash: f5382b0050b81ed3bb1a075a042bdc4034a3975d
ms.sourcegitcommit: 4f3fef493080a43e70e951223894768d36ce430a
ms.translationtype: HT
ms.contentlocale: it-IT
ms.lasthandoff: 11/21/2017
---
# <a name="constraints-on-type-parameters-c-programming-guide"></a><span data-ttu-id="f4304-102">Vincoli sui parametri di tipo (Guida per programmatori C#)</span><span class="sxs-lookup"><span data-stu-id="f4304-102">Constraints on Type Parameters (C# Programming Guide)</span></span>
<span data-ttu-id="f4304-103">Quando si definisce una classe generica è possibile applicare restrizioni ai tipi che il codice client può usare per gli argomenti di tipo quando crea un'istanza della classe.</span><span class="sxs-lookup"><span data-stu-id="f4304-103">When you define a generic class, you can apply restrictions to the kinds of types that client code can use for type arguments when it instantiates your class.</span></span> <span data-ttu-id="f4304-104">Se il codice client tenta di creare un'istanza della classe con un tipo non consentito da un vincolo, viene restituito un errore in fase di compilazione.</span><span class="sxs-lookup"><span data-stu-id="f4304-104">If client code tries to instantiate your class by using a type that is not allowed by a constraint, the result is a compile-time error.</span></span> <span data-ttu-id="f4304-105">Queste restrizioni sono definite vincoli.</span><span class="sxs-lookup"><span data-stu-id="f4304-105">These restrictions are called constraints.</span></span> <span data-ttu-id="f4304-106">I vincoli vengono specificati usando la parola chiave contestuale `where`.</span><span class="sxs-lookup"><span data-stu-id="f4304-106">Constraints are specified by using the `where` contextual keyword.</span></span> <span data-ttu-id="f4304-107">La tabella seguente elenca i sei tipi di vincoli:</span><span class="sxs-lookup"><span data-stu-id="f4304-107">The following table lists the six types of constraints:</span></span>  
  
|<span data-ttu-id="f4304-108">Vincolo</span><span class="sxs-lookup"><span data-stu-id="f4304-108">Constraint</span></span>|<span data-ttu-id="f4304-109">Descrizione</span><span class="sxs-lookup"><span data-stu-id="f4304-109">Description</span></span>|  
|----------------|-----------------|  
|<span data-ttu-id="f4304-110">where T: struct</span><span class="sxs-lookup"><span data-stu-id="f4304-110">where T: struct</span></span>|<span data-ttu-id="f4304-111">L'argomento tipo deve essere un tipo valore.</span><span class="sxs-lookup"><span data-stu-id="f4304-111">The type argument must be a value type.</span></span> <span data-ttu-id="f4304-112">È possibile specificare qualsiasi tipo valore tranne <xref:System.Nullable>.</span><span class="sxs-lookup"><span data-stu-id="f4304-112">Any value type except <xref:System.Nullable> can be specified.</span></span> <span data-ttu-id="f4304-113">Per altre informazioni, vedere [Utilizzo dei tipi nullable](../../../csharp/programming-guide/nullable-types/using-nullable-types.md).</span><span class="sxs-lookup"><span data-stu-id="f4304-113">See [Using Nullable Types](../../../csharp/programming-guide/nullable-types/using-nullable-types.md) for more information.</span></span>|  
|<span data-ttu-id="f4304-114">where T : class</span><span class="sxs-lookup"><span data-stu-id="f4304-114">where T : class</span></span>|<span data-ttu-id="f4304-115">L'argomento tipo deve essere un tipo riferimento, incluso qualsiasi tipo di classe, interfaccia, delegato o matrice.</span><span class="sxs-lookup"><span data-stu-id="f4304-115">The type argument must be a reference type; this applies also to any class, interface, delegate, or array type.</span></span>|  
|<span data-ttu-id="f4304-116">where T : new()</span><span class="sxs-lookup"><span data-stu-id="f4304-116">where T : new()</span></span>|<span data-ttu-id="f4304-117">L'argomento tipo deve avere un costruttore pubblico senza parametri.</span><span class="sxs-lookup"><span data-stu-id="f4304-117">The type argument must have a public parameterless constructor.</span></span> <span data-ttu-id="f4304-118">Quando il vincolo `new()` viene usato con altri vincoli, deve essere specificato per ultimo.</span><span class="sxs-lookup"><span data-stu-id="f4304-118">When used together with other constraints, the `new()` constraint must be specified last.</span></span>|  
|<span data-ttu-id="f4304-119">where T : \<nome della classe di base></span><span class="sxs-lookup"><span data-stu-id="f4304-119">where T : \<base class name></span></span>|<span data-ttu-id="f4304-120">L'argomento tipo deve corrispondere alla classe di base specificata o derivare da essa.</span><span class="sxs-lookup"><span data-stu-id="f4304-120">The type argument must be or derive from the specified base class.</span></span>|  
|<span data-ttu-id="f4304-121">where T : \<nome interfaccia></span><span class="sxs-lookup"><span data-stu-id="f4304-121">where T : \<interface name></span></span>|<span data-ttu-id="f4304-122">L'argomento tipo deve corrispondere all'interfaccia specificata o implementare tale interfaccia.</span><span class="sxs-lookup"><span data-stu-id="f4304-122">The type argument must be or implement the specified interface.</span></span> <span data-ttu-id="f4304-123">È possibile specificare più vincoli di interfaccia.</span><span class="sxs-lookup"><span data-stu-id="f4304-123">Multiple interface constraints can be specified.</span></span> <span data-ttu-id="f4304-124">L'interfaccia vincolante può anche essere generica.</span><span class="sxs-lookup"><span data-stu-id="f4304-124">The constraining interface can also be generic.</span></span>|  
|<span data-ttu-id="f4304-125">where T : U</span><span class="sxs-lookup"><span data-stu-id="f4304-125">where T : U</span></span>|<span data-ttu-id="f4304-126">L'argomento tipo fornito per T deve corrispondere all'argomento fornito per U o derivare da esso.</span><span class="sxs-lookup"><span data-stu-id="f4304-126">The type argument supplied for T must be or derive from the argument supplied for U.</span></span>|  
  
## <a name="why-use-constraints"></a><span data-ttu-id="f4304-127">Motivi per cui usare i vincoli</span><span class="sxs-lookup"><span data-stu-id="f4304-127">Why Use Constraints</span></span>  
 <span data-ttu-id="f4304-128">Se si vuole esaminare un elemento di un elenco generico per stabilire se è valido oppure per confrontarlo con un altro elemento, è necessario garantire al compilatore che l'operatore o il metodo da chiamare sarà supportato da qualsiasi argomento tipo che può venire specificato dal codice client.</span><span class="sxs-lookup"><span data-stu-id="f4304-128">If you want to examine an item in a generic list to determine whether it is valid or to compare it to some other item, the compiler must have some guarantee that the operator or method it has to call will be supported by any type argument that might be specified by client code.</span></span> <span data-ttu-id="f4304-129">A tale scopo è possibile applicare uno o più vincoli alla definizione di classe generica.</span><span class="sxs-lookup"><span data-stu-id="f4304-129">This guarantee is obtained by applying one or more constraints to your generic class definition.</span></span> <span data-ttu-id="f4304-130">Specificando il vincolo della classe di base, ad esempio, si indica al compilatore che verranno usati come argomenti tipo solo gli oggetti del tipo specificato o derivati da esso.</span><span class="sxs-lookup"><span data-stu-id="f4304-130">For example, the base class constraint tells the compiler that only objects of this type or derived from this type will be used as type arguments.</span></span> <span data-ttu-id="f4304-131">In presenza di questa garanzia, il compilatore può consentire le chiamate ai metodi del tipo all'interno della classe generica.</span><span class="sxs-lookup"><span data-stu-id="f4304-131">Once the compiler has this guarantee, it can allow methods of that type to be called in the generic class.</span></span> <span data-ttu-id="f4304-132">I vincoli vengono applicati usando la parola chiave contestuale `where`.</span><span class="sxs-lookup"><span data-stu-id="f4304-132">Constraints are applied by using the contextual keyword `where`.</span></span> <span data-ttu-id="f4304-133">L'esempio di codice seguente illustra la funzionalità che è possibile aggiungere alla classe `GenericList<T>` (in [Introduzione ai generics](../../../csharp/programming-guide/generics/introduction-to-generics.md)) applicando un vincolo della classe di base.</span><span class="sxs-lookup"><span data-stu-id="f4304-133">The following code example demonstrates the functionality we can add to the `GenericList<T>` class (in [Introduction to Generics](../../../csharp/programming-guide/generics/introduction-to-generics.md)) by applying a base class constraint.</span></span>  
  
 [!code-csharp[csProgGuideGenerics#11](../../../csharp/programming-guide/generics/codesnippet/CSharp/constraints-on-type-parameters_1.cs)]  
  
 <span data-ttu-id="f4304-134">Il vincolo consente alla classe generica di usare la proprietà `Employee.Name` perché garantisce che tutti gli elementi di tipo T siano oggetti `Employee` oppure oggetti che ereditano da `Employee`.</span><span class="sxs-lookup"><span data-stu-id="f4304-134">The constraint enables the generic class to use the `Employee.Name` property because all items of type T are guaranteed to be either an `Employee` object or an object that inherits from `Employee`.</span></span>  
  
 <span data-ttu-id="f4304-135">È possibile applicare più vincoli allo stesso parametro di tipo. I vincoli stessi possono essere tipi generici, come illustrato di seguito:</span><span class="sxs-lookup"><span data-stu-id="f4304-135">Multiple constraints can be applied to the same type parameter, and the constraints themselves can be generic types, as follows:</span></span>  
  
 [!code-csharp[csProgGuideGenerics#12](../../../csharp/programming-guide/generics/codesnippet/CSharp/constraints-on-type-parameters_2.cs)]  
  
 <span data-ttu-id="f4304-136">Vincolando il parametro di tipo, il numero di operazioni e di chiamate ai metodi consentite viene ampliato includendo quelle supportate dal tipo vincolante e da tutti i tipi nella relativa gerarchia di ereditarietà.</span><span class="sxs-lookup"><span data-stu-id="f4304-136">By constraining the type parameter, you increase the number of allowable operations and method calls to those supported by the constraining type and all types in its inheritance hierarchy.</span></span> <span data-ttu-id="f4304-137">Di conseguenza, se durante la progettazione di classi o metodi generici si eseguono operazioni su membri generici diverse dalla semplice assegnazione o dalla chiamata a metodi non supportati da `System.Object`, sarà necessario applicare vincoli al parametro di tipo.</span><span class="sxs-lookup"><span data-stu-id="f4304-137">Therefore, when you design generic classes or methods, if you will be performing any operation on the generic members beyond simple assignment or calling any methods not supported by `System.Object`, you will have to apply constraints to the type parameter.</span></span>  
  
 <span data-ttu-id="f4304-138">Quando si applica il vincolo `where T : class`, evitare gli operatori `==` e `!=` nel parametro di tipo perché questi operatori verificano solo l'identità del riferimento e non l'uguaglianza dei valori.</span><span class="sxs-lookup"><span data-stu-id="f4304-138">When applying the `where T : class` constraint, avoid the `==` and `!=` operators on the type parameter because these operators will test for reference identity only, not for value equality.</span></span> <span data-ttu-id="f4304-139">Ciò avviene anche se si esegue l'overload degli operatori in un tipo usato come argomento.</span><span class="sxs-lookup"><span data-stu-id="f4304-139">This is the case even if these operators are overloaded in a type that is used as an argument.</span></span> <span data-ttu-id="f4304-140">Il codice seguente illustra questo aspetto. L'output è false anche se la classe <xref:System.String> esegue l'overload dell'operatore `==`.</span><span class="sxs-lookup"><span data-stu-id="f4304-140">The following code illustrates this point; the output is false even though the <xref:System.String> class overloads the `==` operator.</span></span>  
  
 [!code-csharp[csProgGuideGenerics#13](../../../csharp/programming-guide/generics/codesnippet/CSharp/constraints-on-type-parameters_3.cs)]  
  
 <span data-ttu-id="f4304-141">Questo comportamento è dovuto al fatto che, in fase di compilazione, il compilatore sa solo che T è un tipo riferimento e quindi deve usare gli operatori predefiniti validi per tutti i tipi riferimento.</span><span class="sxs-lookup"><span data-stu-id="f4304-141">The reason for this behavior is that, at compile time, the compiler only knows that T is a reference type, and therefore must use the default operators that are valid for all reference types.</span></span> <span data-ttu-id="f4304-142">Per verificare l'uguaglianza dei valori, è consigliabile applicare anche il vincolo `where T : IComparable<T>` e implementare tale interfaccia nelle classi che verranno usate per costruire la classe generica.</span><span class="sxs-lookup"><span data-stu-id="f4304-142">If you must test for value equality, the recommended way is to also apply the `where T : IComparable<T>` constraint and implement that interface in any class that will be used to construct the generic class.</span></span>  
  
## <a name="constraining-multiple-parameters"></a><span data-ttu-id="f4304-143">Vincolo di più parametri</span><span class="sxs-lookup"><span data-stu-id="f4304-143">Constraining Multiple Parameters</span></span>  
 <span data-ttu-id="f4304-144">È possibile applicare vincoli a più parametri e più vincoli a un singolo parametro, come illustrato nell'esempio seguente:</span><span class="sxs-lookup"><span data-stu-id="f4304-144">You can apply constraints to multiple parameters, and multiple constraints to a single parameter, as shown in the following example:</span></span>  
  
 [!code-csharp[csProgGuideGenerics#64](../../../csharp/programming-guide/generics/codesnippet/CSharp/constraints-on-type-parameters_4.cs)]  
  
## <a name="unbounded-type-parameters"></a><span data-ttu-id="f4304-145">Parametri di tipo senza vincoli</span><span class="sxs-lookup"><span data-stu-id="f4304-145">Unbounded Type Parameters</span></span>  
 <span data-ttu-id="f4304-146">I parametri di tipo che non hanno vincoli, ad esempio T nella classe pubblica `SampleClass<T>{}`, sono detti parametri di tipo senza vincoli.</span><span class="sxs-lookup"><span data-stu-id="f4304-146">Type parameters that have no constraints, such as T in public class `SampleClass<T>{}`, are called unbounded type parameters.</span></span> <span data-ttu-id="f4304-147">I parametri di tipo senza vincoli prevedono le regole seguenti:</span><span class="sxs-lookup"><span data-stu-id="f4304-147">Unbounded type parameters have the following rules:</span></span>  
  
-   <span data-ttu-id="f4304-148">Gli operatori `!=` e `==` non possono essere usati perché non si ha la garanzia che siano supportati dall'argomento di tipo concreto.</span><span class="sxs-lookup"><span data-stu-id="f4304-148">The `!=` and `==` operators cannot be used because there is no guarantee that the concrete type argument will support these operators.</span></span>  
  
-   <span data-ttu-id="f4304-149">Possono essere convertiti in e da `System.Object` oppure convertiti in modo esplicito in qualsiasi tipo di interfaccia.</span><span class="sxs-lookup"><span data-stu-id="f4304-149">They can be converted to and from `System.Object` or explicitly converted to any interface type.</span></span>  
  
-   <span data-ttu-id="f4304-150">È possibile eseguire il confronto con [Null](../../../csharp/language-reference/keywords/null.md).</span><span class="sxs-lookup"><span data-stu-id="f4304-150">You can compare to [null](../../../csharp/language-reference/keywords/null.md).</span></span> <span data-ttu-id="f4304-151">Se si confronta un parametro senza vincoli con `null` e l'argomento tipo è un tipo valore, verrà sempre restituito false.</span><span class="sxs-lookup"><span data-stu-id="f4304-151">If an unbounded parameter is compared to `null`, the comparison will always return false if the type argument is a value type.</span></span>  
  
## <a name="type-parameters-as-constraints"></a><span data-ttu-id="f4304-152">Parametri di tipo come vincoli</span><span class="sxs-lookup"><span data-stu-id="f4304-152">Type Parameters as Constraints</span></span>  
 <span data-ttu-id="f4304-153">L'uso di un parametro di tipo generico come vincolo è utile quando una funzione membro con il proprio parametro di tipo deve vincolare tale parametro a quello del tipo che lo contiene, come illustrato nell'esempio seguente:</span><span class="sxs-lookup"><span data-stu-id="f4304-153">The use of a generic type parameter as a constraint is useful when a member function with its own type parameter has to constrain that parameter to the type parameter of the containing type, as shown in the following example:</span></span>  
  
 [!code-csharp[csProgGuideGenerics#14](../../../csharp/programming-guide/generics/codesnippet/CSharp/constraints-on-type-parameters_5.cs)]  
  
 <span data-ttu-id="f4304-154">Nell'esempio precedente `T` è un vincolo di tipo nel contesto del metodo `Add` e un parametro di tipo senza vincoli nel contesto della classe `List`.</span><span class="sxs-lookup"><span data-stu-id="f4304-154">In the previous example, `T` is a type constraint in the context of the `Add` method, and an unbounded type parameter in the context of the `List` class.</span></span>  
  
 <span data-ttu-id="f4304-155">I parametri di tipo possono anche essere usati come vincoli nelle definizioni di classi generiche.</span><span class="sxs-lookup"><span data-stu-id="f4304-155">Type parameters can also be used as constraints in generic class definitions.</span></span> <span data-ttu-id="f4304-156">Si noti che è necessario dichiarare il parametro di tipo tra parentesi acute, insieme a eventuali altri parametri di tipo:</span><span class="sxs-lookup"><span data-stu-id="f4304-156">Note that the type parameter must be declared within the angle brackets together with any other type parameters:</span></span>  
  
 [!code-csharp[csProgGuideGenerics#15](../../../csharp/programming-guide/generics/codesnippet/CSharp/constraints-on-type-parameters_6.cs)]  
  
 <span data-ttu-id="f4304-157">L'utilità dei parametri di tipo usati come vincoli in classi generiche è molto limitata poiché il compilatore non può presupporre niente sul parametro di tipo, tranne il fatto che deriva da `System.Object`.</span><span class="sxs-lookup"><span data-stu-id="f4304-157">The usefulness of type parameters as constraints with generic classes is very limited because the compiler can assume nothing about the type parameter except that it derives from `System.Object`.</span></span> <span data-ttu-id="f4304-158">Usare i parametri di tipo come vincoli nelle classi generiche in scenari in cui si vuole applicare una relazione di ereditarietà tra due parametri di tipo.</span><span class="sxs-lookup"><span data-stu-id="f4304-158">Use type parameters as constraints on generic classes in scenarios in which you want to enforce an inheritance relationship between two type parameters.</span></span>  
  
## <a name="see-also"></a><span data-ttu-id="f4304-159">Vedere anche</span><span class="sxs-lookup"><span data-stu-id="f4304-159">See Also</span></span>  
 <xref:System.Collections.Generic>  
 [<span data-ttu-id="f4304-160">Guida per programmatori C#</span><span class="sxs-lookup"><span data-stu-id="f4304-160">C# Programming Guide</span></span>](../../../csharp/programming-guide/index.md)  
 [<span data-ttu-id="f4304-161">Introduzione ai generics</span><span class="sxs-lookup"><span data-stu-id="f4304-161">Introduction to Generics</span></span>](../../../csharp/programming-guide/generics/introduction-to-generics.md)  
 [<span data-ttu-id="f4304-162">Classi generiche</span><span class="sxs-lookup"><span data-stu-id="f4304-162">Generic Classes</span></span>](../../../csharp/programming-guide/generics/generic-classes.md)  
 [<span data-ttu-id="f4304-163">Vincolo new</span><span class="sxs-lookup"><span data-stu-id="f4304-163">new Constraint</span></span>](../../../csharp/language-reference/keywords/new-constraint.md)
