---
title: Semantica di riferimento con i tipi valore
description: Informazioni sulle funzionalità del linguaggio che riducono al minimo la copia delle strutture in modo sicuro
author: billwagner
ms.author: wiwagn
ms.date: 11/10/2017
ms.topic: article
ms.prod: .net
ms.technology: devlang-csharp
ms.devlang: csharp
ms.custom: mvc
ms.openlocfilehash: 778897dc92f8a94178ebbbed7704c0dfe2397729
ms.sourcegitcommit: 935d5267c44f9bce801468ef95f44572f1417e8c
ms.translationtype: HT
ms.contentlocale: it-IT
ms.lasthandoff: 03/28/2018
---
# <a name="reference-semantics-with-value-types"></a><span data-ttu-id="9a90c-103">Semantica di riferimento con i tipi valore</span><span class="sxs-lookup"><span data-stu-id="9a90c-103">Reference semantics with value types</span></span>

<span data-ttu-id="9a90c-104">Un vantaggio dell'uso dei tipi valore è che spesso evitano le allocazioni heap.</span><span class="sxs-lookup"><span data-stu-id="9a90c-104">An advantage to using value types is that they often avoid heap allocations.</span></span>
<span data-ttu-id="9a90c-105">Lo svantaggio è invece che vengono copiati in base al valore.</span><span class="sxs-lookup"><span data-stu-id="9a90c-105">The disadvantage is that they are copied by value.</span></span> <span data-ttu-id="9a90c-106">Risulta quindi più difficile ottimizzare gli algoritmi che operano su grandi quantità di dati.</span><span class="sxs-lookup"><span data-stu-id="9a90c-106">This tradeoff makes it harder to optimize algorithms that operate on large amounts of data.</span></span> <span data-ttu-id="9a90c-107">Le nuove funzionalità del linguaggio C# 7.2 forniscono meccanismi che abilitano la semantica pass-by-reference con i tipi valore.</span><span class="sxs-lookup"><span data-stu-id="9a90c-107">New language features in C# 7.2 provide mechanisms that enable pass-by-reference semantics with value types.</span></span> <span data-ttu-id="9a90c-108">Usare queste funzionalità con criterio, per ridurre al minimo sia le allocazioni che le operazioni di copia.</span><span class="sxs-lookup"><span data-stu-id="9a90c-108">Use these features wisely to minimize both allocations and copy operations.</span></span> <span data-ttu-id="9a90c-109">Questo articolo esamina le nuove funzionalità.</span><span class="sxs-lookup"><span data-stu-id="9a90c-109">This article explores those new features.</span></span>

<span data-ttu-id="9a90c-110">Gran parte del codice di esempio in questo articolo illustra le funzionalità aggiunte in C# 7.2.</span><span class="sxs-lookup"><span data-stu-id="9a90c-110">Much of the sample code in this article demonstrates features added in C# 7.2.</span></span> <span data-ttu-id="9a90c-111">Per usare tali funzionalità, è necessario configurare il progetto per l'uso di C# 7.2 o versione successiva.</span><span class="sxs-lookup"><span data-stu-id="9a90c-111">In order to use those features, you must configure your project to use C# 7.2 or later.</span></span> <span data-ttu-id="9a90c-112">È possibile usare Visual Studio per selezionarlo.</span><span class="sxs-lookup"><span data-stu-id="9a90c-112">You can use Visual Studio to select it.</span></span> <span data-ttu-id="9a90c-113">Per ogni progetto, scegliere **Progetto** dal menu, quindi **Proprietà**.</span><span class="sxs-lookup"><span data-stu-id="9a90c-113">For each project, select **Project** from the menu, then **Properties**.</span></span> <span data-ttu-id="9a90c-114">Nella scheda **Compilazione** scegliere **Avanzate**.</span><span class="sxs-lookup"><span data-stu-id="9a90c-114">Select the **Build** tab and click **Advanced**.</span></span> <span data-ttu-id="9a90c-115">Da qui, configurare la versione del linguaggio.</span><span class="sxs-lookup"><span data-stu-id="9a90c-115">From there, configure the language version.</span></span> <span data-ttu-id="9a90c-116">Scegliere "7.2" o "più recente".</span><span class="sxs-lookup"><span data-stu-id="9a90c-116">Choose either "7.2", or "latest".</span></span>  <span data-ttu-id="9a90c-117">Oppure è possibile modificare il file con estensione *csproj* e aggiungere il nodo seguente:</span><span class="sxs-lookup"><span data-stu-id="9a90c-117">Or you can edit the *csproj* file and add the following node:</span></span>

```XML
  <PropertyGroup>
    <LangVersion>7.2</LangVersion>
  </PropertyGroup>
```

<span data-ttu-id="9a90c-118">È possibile usare "7.2" o "latest" come valore.</span><span class="sxs-lookup"><span data-stu-id="9a90c-118">You can use either "7.2" or "latest" for the value.</span></span>

## <a name="passing-arguments-by-readonly-reference"></a><span data-ttu-id="9a90c-119">Passaggio di argomenti per riferimento di sola lettura</span><span class="sxs-lookup"><span data-stu-id="9a90c-119">Passing arguments by readonly reference</span></span>

<span data-ttu-id="9a90c-120">In C# 7.2 è stata aggiunta la parola chiave `in` a complemento delle parole chiave `ref` e `out` esistenti per passare gli argomenti per riferimento.</span><span class="sxs-lookup"><span data-stu-id="9a90c-120">C# 7.2 adds the `in` keyword to complement the existing `ref` and `out` keywords to pass arguments by reference.</span></span> <span data-ttu-id="9a90c-121">La parola chiave `in` specifica il passaggio dell'argomento per riferimento, ma il metodo chiamato non modifica il valore.</span><span class="sxs-lookup"><span data-stu-id="9a90c-121">The `in` keyword specifies passing the argument by reference, but the called method does not modify the value.</span></span> 

<span data-ttu-id="9a90c-122">Questa aggiunta fornisce un vocabolario completo per esprimere le finalità di progettazione.</span><span class="sxs-lookup"><span data-stu-id="9a90c-122">This addition provides a full vocabulary to express your design intent.</span></span> <span data-ttu-id="9a90c-123">I tipi valore vengono copiati quando vengono passati a un metodo chiamato se nella firma del metodo non si specifica alcuno dei modificatori seguenti.</span><span class="sxs-lookup"><span data-stu-id="9a90c-123">Value types are copied when passed to a called method when you don't specify any of the following modifiers in the method signature.</span></span> <span data-ttu-id="9a90c-124">Ognuno di questi modificatori specifica che un tipo valore viene passato per riferimento, evitando la copia.</span><span class="sxs-lookup"><span data-stu-id="9a90c-124">Each of these modifiers specifies that a value type is passed by reference, avoiding the copy.</span></span> <span data-ttu-id="9a90c-125">Ogni modificatore esprime una finalità diversa:</span><span class="sxs-lookup"><span data-stu-id="9a90c-125">Each modifier expresses a different intent:</span></span>

- <span data-ttu-id="9a90c-126">`out`: questo metodo imposta il valore dell'argomento usato come parametro.</span><span class="sxs-lookup"><span data-stu-id="9a90c-126">`out`: This method sets the value of the argument used as this parameter.</span></span>
- <span data-ttu-id="9a90c-127">`ref`: questo metodo può impostare il valore dell'argomento usato come parametro.</span><span class="sxs-lookup"><span data-stu-id="9a90c-127">`ref`: This method may set the value of the argument used as this parameter.</span></span>
- <span data-ttu-id="9a90c-128">`in`: questo metodo non modifica il valore dell'argomento usato come parametro.</span><span class="sxs-lookup"><span data-stu-id="9a90c-128">`in`: This method does not modify the value of the argument used as this parameter.</span></span>

<span data-ttu-id="9a90c-129">Aggiungere il modificatore `in` per passare un argomento per riferimento e dichiarare che la finalità di passare argomenti per riferimento, per evitare operazioni di copia non necessarie,</span><span class="sxs-lookup"><span data-stu-id="9a90c-129">Add the `in` modifier to pass an argument by reference and declare your design intent to pass arguments by reference to avoid unnecessary copying.</span></span> <span data-ttu-id="9a90c-130">non quella di modificare l'oggetto usato come argomento.</span><span class="sxs-lookup"><span data-stu-id="9a90c-130">You do not intend to modify the object used as that argument.</span></span> <span data-ttu-id="9a90c-131">Il codice seguente illustra un esempio di metodo che calcola la distanza tra due punti nello spazio 3D.</span><span class="sxs-lookup"><span data-stu-id="9a90c-131">The following code shows an example of a method that calculates the distance between two points in 3D space.</span></span> 

[!code-csharp[InArgument](../../samples/csharp/reference-semantics/Program.cs#InArgument "Specifying an In argument")]

<span data-ttu-id="9a90c-132">Gli argomenti sono due strutture, contenenti ognuna tre valori double.</span><span class="sxs-lookup"><span data-stu-id="9a90c-132">The arguments are two structures that each contain three doubles.</span></span> <span data-ttu-id="9a90c-133">Un valore double è pari a 8 byte, quindi ogni argomento è pari a 24 byte.</span><span class="sxs-lookup"><span data-stu-id="9a90c-133">A double is 8 bytes, so each argument is 24 bytes.</span></span> <span data-ttu-id="9a90c-134">Specificando il modificatore `in`, si passa un riferimento a 4 byte o 8 byte a tali argomenti, a seconda dell'architettura del computer.</span><span class="sxs-lookup"><span data-stu-id="9a90c-134">By specifying the `in` modifier, you pass a 4-byte or 8-byte reference to those arguments, depending on the architecture of the machine.</span></span> <span data-ttu-id="9a90c-135">La differenza a livello di dimensioni è piccola, ma può aumentare rapidamente quando l'applicazione chiama questo metodo in un ciclo ridotto usando più valori diversi.</span><span class="sxs-lookup"><span data-stu-id="9a90c-135">The difference in size is small, but it can quickly add up when your application calls this method in a tight loop using many different values.</span></span>
 
<span data-ttu-id="9a90c-136">Il modificatore `in` integra `out` e `ref` anche in altri modi.</span><span class="sxs-lookup"><span data-stu-id="9a90c-136">The `in` modifier complements `out` and `ref` in other ways as well.</span></span> <span data-ttu-id="9a90c-137">Non è possibile creare overload di un metodo che si distinguono solo per la presenza di `in`, `out` o `ref`.</span><span class="sxs-lookup"><span data-stu-id="9a90c-137">You cannot create overloads of a method that differ only in the presence of `in`, `out`, or `ref`.</span></span> <span data-ttu-id="9a90c-138">Queste nuove regole estendono lo stesso comportamento da sempre definito per i parametri `out` e `ref`.</span><span class="sxs-lookup"><span data-stu-id="9a90c-138">These new rules extend the same behavior that had always been defined for `out` and `ref` parameters.</span></span>

<span data-ttu-id="9a90c-139">Il modificatore `in` può essere applicato a tutti i membri che accettano parametri: metodi, delegati, espressioni lambda, funzioni locali, indicizzatori, operatori.</span><span class="sxs-lookup"><span data-stu-id="9a90c-139">The `in` modifier may be applied to any member that takes parameters: methods, delegates, lambdas, local functions, indexers, operators.</span></span>

<span data-ttu-id="9a90c-140">Diversamente dagli argomenti `ref` e `out`, è possibile usare valori letterali o costanti per l'argomento in un parametro `in`.</span><span class="sxs-lookup"><span data-stu-id="9a90c-140">Unlike `ref` and `out` arguments, you may use literal values or constants for the argument to an `in` parameter.</span></span> <span data-ttu-id="9a90c-141">Inoltre, diversamente da un parametro `ref` o `out`, non è necessario applicare il modificatore `in` nel sito di chiamata.</span><span class="sxs-lookup"><span data-stu-id="9a90c-141">Also, unlike a `ref` or `out` parameter, you don't need to apply the `in` modifier at the call site.</span></span> <span data-ttu-id="9a90c-142">Il codice seguente illustra due esempi di chiamata al metodo `CalculateDistance`.</span><span class="sxs-lookup"><span data-stu-id="9a90c-142">The following code shows you two examples of calling the `CalculateDistance` method.</span></span> <span data-ttu-id="9a90c-143">Il primo usa due variabili locali passate per riferimento.</span><span class="sxs-lookup"><span data-stu-id="9a90c-143">The first uses two local variables passed by reference.</span></span> <span data-ttu-id="9a90c-144">Il secondo include una variabile temporanea creata durante la chiamata al metodo.</span><span class="sxs-lookup"><span data-stu-id="9a90c-144">The second includes a temporary variable created as part of the method call.</span></span> 

[!code-csharp[UseInArgument](../../samples/csharp/reference-semantics/Program.cs#UseInArgument "Specifying an In argument")]

<span data-ttu-id="9a90c-145">Il compilatore assicura che venga applicata la natura di sola lettura di un argomento `in` in diversi modi.</span><span class="sxs-lookup"><span data-stu-id="9a90c-145">There are several ways in which the compiler ensures that the read-only nature of an `in` argument is enforced.</span></span>  <span data-ttu-id="9a90c-146">Prima di tutto il metodo chiamato non può essere direttamente assegnato a un parametro `in`.</span><span class="sxs-lookup"><span data-stu-id="9a90c-146">First of all, the called method can't directly assign to an `in` parameter.</span></span> <span data-ttu-id="9a90c-147">Non può essere direttamente assegnato ai campi di un parametro `in` se quel valore è un tipo `struct`.</span><span class="sxs-lookup"><span data-stu-id="9a90c-147">It can't directly assign to any field of an `in` parameter when that value is a `struct` type.</span></span> <span data-ttu-id="9a90c-148">Non è neppure possibile passare un parametro `in` a metodi che usano il modificatore `ref` o `out`.</span><span class="sxs-lookup"><span data-stu-id="9a90c-148">In addition, you cannot pass an `in` parameter to any method using the `ref` or `out` modifier.</span></span>
<span data-ttu-id="9a90c-149">Queste regole sono valide per qualsiasi campo di un parametro `in`, a condizione che il campo sia di tipo `struct` e che anche il parametro sia di tipo `struct`.</span><span class="sxs-lookup"><span data-stu-id="9a90c-149">These rules apply to any field of an `in` parameter, provided the field is a `struct` type and the parameter is also a `struct` type.</span></span> <span data-ttu-id="9a90c-150">Queste regole, in effetti, vengono applicate per più livelli di accesso ai membri, a condizione che a tutti i livelli di accesso ai membri i tipi siano `structs`.</span><span class="sxs-lookup"><span data-stu-id="9a90c-150">In fact, these rules apply for multiple layers of member access provided the types at all levels of member access are `structs`.</span></span> <span data-ttu-id="9a90c-151">Il compilatore impone che i tipi `struct` passati come argomenti `in` e i relativi membri `struct` siano variabili di sola lettura, se usati come argomenti per altri metodi.</span><span class="sxs-lookup"><span data-stu-id="9a90c-151">The compiler enforces that `struct` types passed as  `in` arguments and their `struct` members are read-only variables when used as arguments to other methods.</span></span>

<span data-ttu-id="9a90c-152">L'uso di parametri `in` consente di evitare i costi potenziali sulle prestazioni per l'esecuzione di copie,</span><span class="sxs-lookup"><span data-stu-id="9a90c-152">The use of `in` parameters avoids the potential performance costs of making copies.</span></span> <span data-ttu-id="9a90c-153">ma non modifica la semantica delle chiamate a metodi.</span><span class="sxs-lookup"><span data-stu-id="9a90c-153">It does not change the semantics of any method call.</span></span> <span data-ttu-id="9a90c-154">Non è quindi necessario specificare il modificatore `in` presso il sito di chiamata.</span><span class="sxs-lookup"><span data-stu-id="9a90c-154">Therefore, you do not need to specify the `in` modifier at the call site.</span></span> <span data-ttu-id="9a90c-155">Omettendo il modificatore `in` presso il sito di chiamata, tuttavia, si informa il compilatore che può effettuare una copia dell'argomento per i motivi seguenti:</span><span class="sxs-lookup"><span data-stu-id="9a90c-155">However, omitting the `in` modifier at the call site informs the compiler that it is allowed to make a copy of the argument for the following reasons:</span></span>

- <span data-ttu-id="9a90c-156">È presente una conversione implicita ma non una conversione di identità dal tipo di argomento al tipo di parametro.</span><span class="sxs-lookup"><span data-stu-id="9a90c-156">There is an implicit conversion but not an identity conversion from the argument type to the parameter type.</span></span>
- <span data-ttu-id="9a90c-157">L'argomento è un'espressione, ma non ha una variabile di archiviazione nota.</span><span class="sxs-lookup"><span data-stu-id="9a90c-157">The argument is an expression but does not have a known storage variable.</span></span>
- <span data-ttu-id="9a90c-158">È presente un overload diverso per la presenza o l'assenza di `in`.</span><span class="sxs-lookup"><span data-stu-id="9a90c-158">An overload exists that differs by the presence or absence of `in`.</span></span> <span data-ttu-id="9a90c-159">In tal caso, l'overload in base al valore è una corrispondenza migliore.</span><span class="sxs-lookup"><span data-stu-id="9a90c-159">In that case, the by value overload is a better match.</span></span>

<span data-ttu-id="9a90c-160">Queste regole sono utili quando si aggiorna codice esistente per usare argomenti di riferimento di sola lettura.</span><span class="sxs-lookup"><span data-stu-id="9a90c-160">These rules are useful as you update existing code to use read-only reference arguments.</span></span> <span data-ttu-id="9a90c-161">All'interno del metodo chiamato è possibile chiamare qualsiasi metodo di istanza che usa parametri in base al valore.</span><span class="sxs-lookup"><span data-stu-id="9a90c-161">Inside the called method, you can call any instance method that uses by value parameters.</span></span> <span data-ttu-id="9a90c-162">In tali istanze viene creata una copia del parametro `in`.</span><span class="sxs-lookup"><span data-stu-id="9a90c-162">In those instances, a copy of the `in` parameter is created.</span></span> <span data-ttu-id="9a90c-163">Poiché il compilatore può creare una variabile temporanea per qualsiasi parametro `in`, è anche possibile specificare i valori predefiniti per qualsiasi parametro `in`.</span><span class="sxs-lookup"><span data-stu-id="9a90c-163">Because the compiler can create a temporary variable for any `in` parameter, you can also specify default values for any `in` parameter.</span></span> <span data-ttu-id="9a90c-164">Il codice seguente specifica l'origine (punto 0,0) come valore predefinito per il secondo punto:</span><span class="sxs-lookup"><span data-stu-id="9a90c-164">The following code specifies the origin (point 0,0) as the default value for the second point:</span></span>

[!code-csharp[InArgumentDefault](../../samples/csharp/reference-semantics/Program.cs#InArgumentDefault "Specifying defaults for an in parameter")]

<span data-ttu-id="9a90c-165">Per imporre al compilatore di passare argomenti di sola lettura per riferimento, specificare il modificatore `in` per gli argomenti presso il sito di chiamata, come illustrato nel codice seguente:</span><span class="sxs-lookup"><span data-stu-id="9a90c-165">To force the compiler to pass read only arguments by reference, specify the `in` modifer on the arguments at the call site, as shown in the following code:</span></span>

[!code-csharp[UseInArgument](../../samples/csharp/reference-semantics/Program.cs#ExplicitInArgument "Specifying an In argument")]

<span data-ttu-id="9a90c-166">Questo comportamento semplifica nel tempo l'adozione di parametri `in` in codebase di grandi dimensioni in cui è possibile ottenere miglioramenti delle prestazioni.</span><span class="sxs-lookup"><span data-stu-id="9a90c-166">This behavior makes it easier to adopt `in` parameters over time in large codebases where performance gains are possible.</span></span> <span data-ttu-id="9a90c-167">È prima necessario aggiungere il modificatore `in` alle firme dei metodi.</span><span class="sxs-lookup"><span data-stu-id="9a90c-167">You add the `in` modifier to method signatures first.</span></span> <span data-ttu-id="9a90c-168">È quindi possibile aggiungere il modificatore `in` presso i siti di chiamata e creare tipi `readonly struct` per consentire al compilatore di evitare di creare copie difensive di parametri `in` in altre posizioni.</span><span class="sxs-lookup"><span data-stu-id="9a90c-168">Then, you can add the `in` modifier at callsites and create `readonly struct` types to enable the compiler to avoid creating defensive copies of `in` parameters in more locations.</span></span>

<span data-ttu-id="9a90c-169">La designazione del parametro `in` può anche essere usata con tipi riferimento o valori numerici.</span><span class="sxs-lookup"><span data-stu-id="9a90c-169">The `in` parameter designation can also be used with reference types or numeric values.</span></span> <span data-ttu-id="9a90c-170">Gli eventuali vantaggi in entrambi i casi sono tuttavia minimi.</span><span class="sxs-lookup"><span data-stu-id="9a90c-170">However, the benefits in both cases are minimal, if any.</span></span>

## <a name="ref-readonly-returns"></a><span data-ttu-id="9a90c-171">Valori restituiti `ref readonly`</span><span class="sxs-lookup"><span data-stu-id="9a90c-171">`ref readonly` returns</span></span>

<span data-ttu-id="9a90c-172">È anche possibile restituire un tipo valore per riferimento, ma non consentire al chiamante di modificare tale valore.</span><span class="sxs-lookup"><span data-stu-id="9a90c-172">You may also want to return a value type by reference, but disallow the caller from modifying that value.</span></span> <span data-ttu-id="9a90c-173">Usare il modificatore `ref readonly` per esprimere tale finalità di progettazione.</span><span class="sxs-lookup"><span data-stu-id="9a90c-173">Use the `ref readonly` modifier to express that design intent.</span></span> <span data-ttu-id="9a90c-174">Notifica ai lettori che si restituirà un riferimento ai dati esistenti, ma non si consentirà la modifica.</span><span class="sxs-lookup"><span data-stu-id="9a90c-174">It notifies readers that you are returning a reference to existing data, but not allowing modification.</span></span> 

<span data-ttu-id="9a90c-175">Il compilatore fa in modo che il chiamante non possa modificare il riferimento.</span><span class="sxs-lookup"><span data-stu-id="9a90c-175">The compiler enforces that the caller cannot modify the reference.</span></span> <span data-ttu-id="9a90c-176">I tentativi di assegnazione diretta del valore generano un errore in fase di compilazione.</span><span class="sxs-lookup"><span data-stu-id="9a90c-176">Attempts to assign the value directly generate a compile-time error.</span></span> <span data-ttu-id="9a90c-177">Il compilatore non può tuttavia sapere se un metodo del membro modifica lo stato dello struct.</span><span class="sxs-lookup"><span data-stu-id="9a90c-177">However, the compiler cannot know if any member method modifies the state of the struct.</span></span>
<span data-ttu-id="9a90c-178">Per assicurarsi che l'oggetto non venga modificato, il compilatore crea una copia e chiama i riferimenti al membro usando tale copia.</span><span class="sxs-lookup"><span data-stu-id="9a90c-178">To ensure that the object is not modified, the compiler creates a copy and calls member references using that copy.</span></span> <span data-ttu-id="9a90c-179">Tutte le modifiche vengono apportate a tale copia difensiva.</span><span class="sxs-lookup"><span data-stu-id="9a90c-179">Any modifications are to that defensive copy.</span></span> 

<span data-ttu-id="9a90c-180">È probabile che la libreria che usa `Point3D` usi spesso l'origine in tutto il codice.</span><span class="sxs-lookup"><span data-stu-id="9a90c-180">It's likely that the library using `Point3D` would often use the origin throughout the code.</span></span> <span data-ttu-id="9a90c-181">Ogni istanza crea un nuovo oggetto nello stack.</span><span class="sxs-lookup"><span data-stu-id="9a90c-181">Every instance creates a new object on the stack.</span></span> <span data-ttu-id="9a90c-182">Può essere vantaggioso creare una costante e usarla per riferimento,</span><span class="sxs-lookup"><span data-stu-id="9a90c-182">It may be advantageous to create a constant and return it by reference.</span></span> <span data-ttu-id="9a90c-183">ma, se si restituisce un riferimento alla risorsa di archiviazione interna, è possibile fare in modo che il chiamante non possa modificare la risorsa di archiviazione di riferimento.</span><span class="sxs-lookup"><span data-stu-id="9a90c-183">But, if you return a reference to internal storage, you may want to enforce that the caller cannot modify the referenced storage.</span></span> <span data-ttu-id="9a90c-184">Il codice seguente definisce una proprietà di sola lettura che restituisce `readonly ref` a un oggetto `Point3D` che specifica l'origine.</span><span class="sxs-lookup"><span data-stu-id="9a90c-184">The following code defines a read-only property that returns a `readonly ref` to a `Point3D` that specifies the origin.</span></span>

[!code-csharp[OriginReference](../../samples/csharp/reference-semantics/Point3D.cs#OriginReference "Creating a readonly Origin reference")]

<span data-ttu-id="9a90c-185">Per creare una copia di un valore restituito ref readonly, è sufficiente assegnarlo a una variabile non dichiarata con il modificatore `ref readonly`.</span><span class="sxs-lookup"><span data-stu-id="9a90c-185">Creating a copy of a ref readonly return is easy: Just assign it to a variable not declared with the `ref readonly` modifier.</span></span> <span data-ttu-id="9a90c-186">Il compilatore genera il codice per copiare l'oggetto durante l'assegnazione.</span><span class="sxs-lookup"><span data-stu-id="9a90c-186">The compiler generates code to copy the object as part of the assignment.</span></span> 

<span data-ttu-id="9a90c-187">Quando si assegna una variabile a `ref readonly return`, è possibile specificare una variabile `ref readonly` o una copia per valore del riferimento di sola lettura:</span><span class="sxs-lookup"><span data-stu-id="9a90c-187">When you assign a variable to a `ref readonly return`, you can specify either a `ref readonly` variable, or a by-value copy of the read-only reference:</span></span>

[!code-csharp[AssignRefReadonly](../../samples/csharp/reference-semantics/Program.cs#AssignRefReadonly "Assigning a ref readonly")]

<span data-ttu-id="9a90c-188">La prima assegnazione del codice precedente crea una copia della costante `Origin` e assegna tale copia.</span><span class="sxs-lookup"><span data-stu-id="9a90c-188">The first assignment in the preceding code makes a copy of the `Origin` constant and assigns that copy.</span></span> <span data-ttu-id="9a90c-189">La seconda assegna un riferimento.</span><span class="sxs-lookup"><span data-stu-id="9a90c-189">The second assigns a reference.</span></span> <span data-ttu-id="9a90c-190">Si noti che il modificatore `readonly` deve fare parte della dichiarazione della variabile.</span><span class="sxs-lookup"><span data-stu-id="9a90c-190">Notice that the `readonly` modifier must be part of the declaration of the variable.</span></span> <span data-ttu-id="9a90c-191">Il riferimento a cui viene fatto riferimento non può essere modificato.</span><span class="sxs-lookup"><span data-stu-id="9a90c-191">The reference to which it refers can't be modified.</span></span> <span data-ttu-id="9a90c-192">I tentativi di eseguire questa operazione generano un errore in fase di compilazione.</span><span class="sxs-lookup"><span data-stu-id="9a90c-192">Attempts to do so result in a compile-time error.</span></span>

## <a name="readonly-struct-type"></a><span data-ttu-id="9a90c-193">Tipo `readonly struct`</span><span class="sxs-lookup"><span data-stu-id="9a90c-193">`readonly struct` type</span></span>

<span data-ttu-id="9a90c-194">Applicare `ref readonly` agli usi a traffico elevato di uno struct può essere sufficiente.</span><span class="sxs-lookup"><span data-stu-id="9a90c-194">Applying `ref readonly` to high-traffic uses of a struct may be sufficient.</span></span>
<span data-ttu-id="9a90c-195">In altri casi, è possibile creare uno struct non modificabile.</span><span class="sxs-lookup"><span data-stu-id="9a90c-195">Other times, you may want to create an immutable struct.</span></span> <span data-ttu-id="9a90c-196">È quindi sempre possibile eseguire il passaggio per riferimento di sola lettura.</span><span class="sxs-lookup"><span data-stu-id="9a90c-196">Then you can always pass by read-only reference.</span></span> <span data-ttu-id="9a90c-197">Tale procedura rimuove le copie difensive che vengono eseguite quando si accede ai metodi di uno struct usato come parametro `in`.</span><span class="sxs-lookup"><span data-stu-id="9a90c-197">That practice removes the defensive copies that take place when you access methods of a struct used as an `in` parameter.</span></span>

<span data-ttu-id="9a90c-198">A tale scopo, è possibile creare un tipo `readonly struct`.</span><span class="sxs-lookup"><span data-stu-id="9a90c-198">You can do that by creating a `readonly struct` type.</span></span> <span data-ttu-id="9a90c-199">È possibile aggiungere il modificatore `readonly` a una dichiarazione di struct.</span><span class="sxs-lookup"><span data-stu-id="9a90c-199">You can add the `readonly` modifier to a struct declaration.</span></span> <span data-ttu-id="9a90c-200">Il compilatore fa in modo che tutti i membri di istanza dello struct siano `readonly`. `struct` deve essere non modificabile.</span><span class="sxs-lookup"><span data-stu-id="9a90c-200">The compiler enforces that all instance members of the struct are `readonly`; the `struct` must be immutable.</span></span>

<span data-ttu-id="9a90c-201">Esistono altre ottimizzazioni per `readonly struct`.</span><span class="sxs-lookup"><span data-stu-id="9a90c-201">There are other optimizations for a `readonly struct`.</span></span> <span data-ttu-id="9a90c-202">È possibile usare il modificatore `in` in ogni posizione in cui `readonly struct` è un argomento.</span><span class="sxs-lookup"><span data-stu-id="9a90c-202">You can use the `in` modifier at every location where a `readonly struct` is an argument.</span></span> <span data-ttu-id="9a90c-203">È anche possibile restituire `readonly struct` come `ref return` quando si restituisce un oggetto la cui durata si estende oltre l'ambito del metodo che restituisce l'oggetto.</span><span class="sxs-lookup"><span data-stu-id="9a90c-203">In addition, you can return a `readonly struct` as a `ref return` when you are returning an object whose lifetime extends beyond the scope of the method returning the object.</span></span>

<span data-ttu-id="9a90c-204">Il compilatore genera infine un codice più efficiente quando si chiamano i membri di `readonly struct`: il riferimento `this`, invece di una copia del ricevitore, è sempre un parametro `in` passato per riferimento al metodo dei membri.</span><span class="sxs-lookup"><span data-stu-id="9a90c-204">Finally, the compiler generates more efficient code when you call members of a `readonly struct`: The `this` reference, instead of a copy of the receiver, is always an `in` parameter passed by reference to the member method.</span></span> <span data-ttu-id="9a90c-205">Questa ottimizzazione consente un risparmio a livello di copie quando si usa `readonly struct`.</span><span class="sxs-lookup"><span data-stu-id="9a90c-205">This optimization saves more copying when you use a `readonly struct`.</span></span> <span data-ttu-id="9a90c-206">`Point3D` è un candidato ideale per questa modifica.</span><span class="sxs-lookup"><span data-stu-id="9a90c-206">The `Point3D` is a great candidate for this change.</span></span> <span data-ttu-id="9a90c-207">Nel codice seguente viene illustrata una struttura `ReadonlyPoint3D` aggiornata:</span><span class="sxs-lookup"><span data-stu-id="9a90c-207">The following code shows an updated `ReadonlyPoint3D` structure:</span></span>

[!code-csharp[ReadonlyOnlyPoint3D](../../samples/csharp/reference-semantics/Point3D.cs#ReadonlyOnlyPoint3D "Defining an immutable structure")]

## <a name="ref-struct-type"></a><span data-ttu-id="9a90c-208">Tipo `ref struct`</span><span class="sxs-lookup"><span data-stu-id="9a90c-208">`ref struct` type</span></span>

<span data-ttu-id="9a90c-209">Un'altra funzionalità del linguaggio correlata è la possibilità di dichiarare un tipo valore che deve essere allocato nello stack.</span><span class="sxs-lookup"><span data-stu-id="9a90c-209">Another related language feature is the ability to declare a value type that must be stack allocated.</span></span> <span data-ttu-id="9a90c-210">In altre parole, questi tipi non possono mai essere creati nell'heap come membro di un'altra classe.</span><span class="sxs-lookup"><span data-stu-id="9a90c-210">In other words, these types can never be created on the heap as a member of another class.</span></span> <span data-ttu-id="9a90c-211">La principale motivazione di questa funzionalità sono stati <xref:System.Span%601> e le strutture correlate.</span><span class="sxs-lookup"><span data-stu-id="9a90c-211">The primary motivation for this feature was <xref:System.Span%601> and related structures.</span></span> <span data-ttu-id="9a90c-212"><xref:System.Span%601> può contenere un puntatore gestito come uno dei membri, mentre l'altro è la lunghezza dell'intervallo.</span><span class="sxs-lookup"><span data-stu-id="9a90c-212"><xref:System.Span%601> may contain a managed pointer as one of its members, the other being the length of the span.</span></span> <span data-ttu-id="9a90c-213">L'implementazione è leggermente diversa perché C# non supporta i puntatori alla memoria gestita al di fuori di un contesto non sicuro.</span><span class="sxs-lookup"><span data-stu-id="9a90c-213">It's implemented a bit differently because C# doesn't support pointers to managed memory outside of an unsafe context.</span></span> <span data-ttu-id="9a90c-214">Le operazioni di scrittura che modificano il puntatore e la lunghezza non sono atomiche.</span><span class="sxs-lookup"><span data-stu-id="9a90c-214">Any write that changes the pointer and the length is not atomic.</span></span> <span data-ttu-id="9a90c-215">Per questo <xref:System.Span%601> sarà soggetto a errori non compresi nell'intervallo o ad altre violazioni dell'indipendenza dai tipi se non è vincolato a un singolo stack frame.</span><span class="sxs-lookup"><span data-stu-id="9a90c-215">That means a <xref:System.Span%601> would be subject to out of range errors or other type safety violations were it not constrained to a single stack frame.</span></span> <span data-ttu-id="9a90c-216">Inoltre l'inserimento di un puntatore gestito nell'heap GC provoca in genere un arresto anomalo del sistema in fase JIT.</span><span class="sxs-lookup"><span data-stu-id="9a90c-216">In addition, putting a managed pointer on the GC heap typically crashes at JIT time.</span></span>

<span data-ttu-id="9a90c-217">Possono esistere requisiti simili quando si usa la memoria creata con [`stackalloc`](language-reference/keywords/stackalloc.md) o quando si usa la memoria delle API di interoperabilità.</span><span class="sxs-lookup"><span data-stu-id="9a90c-217">You may have similar requirements working with memory created using [`stackalloc`](language-reference/keywords/stackalloc.md) or when using memory from interop APIs.</span></span> <span data-ttu-id="9a90c-218">È possibile definire i tipi `ref struct` in base a tali esigenze.</span><span class="sxs-lookup"><span data-stu-id="9a90c-218">You can define your own `ref struct` types for those needs.</span></span> <span data-ttu-id="9a90c-219">In questo articolo vengono illustrati esempi che usano `Span<T>` per semplicità.</span><span class="sxs-lookup"><span data-stu-id="9a90c-219">In this article, you see examples using `Span<T>` for simplicity.</span></span>

<span data-ttu-id="9a90c-220">La dichiarazione `ref struct` afferma che nello stack deve essere presente uno struct di questo tipo.</span><span class="sxs-lookup"><span data-stu-id="9a90c-220">The `ref struct` declaration declares a struct of this type must be on the stack.</span></span> <span data-ttu-id="9a90c-221">Le regole del linguaggio garantiscono l'uso sicuro di questi tipi.</span><span class="sxs-lookup"><span data-stu-id="9a90c-221">The language rules ensure the safe use of these types.</span></span> <span data-ttu-id="9a90c-222">Gli altri tipi dichiarati come `ref struct` includono <xref:System.ReadOnlySpan%601>.</span><span class="sxs-lookup"><span data-stu-id="9a90c-222">Other types declared as `ref struct` include <xref:System.ReadOnlySpan%601>.</span></span> 

<span data-ttu-id="9a90c-223">L'obiettivo di mantenere un tipo `ref struct` come variabile allocata nello stack comporta diverse regole che il compilatore applica per tutti i tipi `ref struct`.</span><span class="sxs-lookup"><span data-stu-id="9a90c-223">The goal of keeping a `ref struct` type as a stack-allocated variable introduces several rules that the compiler enforces for all `ref struct` types.</span></span>

- <span data-ttu-id="9a90c-224">Non è possibile eseguire il boxing di `ref struct`.</span><span class="sxs-lookup"><span data-stu-id="9a90c-224">You can't box a `ref struct`.</span></span> <span data-ttu-id="9a90c-225">Non è possibile assegnare un tipo `ref struct` a una variabile di tipo `object`, `dynamic` o qualsiasi tipo di interfaccia.</span><span class="sxs-lookup"><span data-stu-id="9a90c-225">You cannot assign a `ref struct` type to a variable of type `object`, `dynamic`, or any interface type.</span></span>
- <span data-ttu-id="9a90c-226">Non è possibile dichiarare `ref struct` come membro di una classe o di un normale struct.</span><span class="sxs-lookup"><span data-stu-id="9a90c-226">You can't declare a `ref struct` as a member of a class or a normal struct.</span></span>
- <span data-ttu-id="9a90c-227">Non è possibile dichiarare variabili locali che sono tipi `ref struct` nei metodi asincroni.</span><span class="sxs-lookup"><span data-stu-id="9a90c-227">You cannot declare local variables that are `ref struct` types in async methods.</span></span> <span data-ttu-id="9a90c-228">È possibile dichiararle nei metodi sincroni che restituiscono tipi `Task`, `Task<T>` o simili a Task.</span><span class="sxs-lookup"><span data-stu-id="9a90c-228">You can declare them in synchronous methods that return `Task`, `Task<T>` or Task-like types.</span></span>
- <span data-ttu-id="9a90c-229">Non è possibile dichiarare variabili locali `ref struct` negli iteratori.</span><span class="sxs-lookup"><span data-stu-id="9a90c-229">You cannot declare `ref struct` local variables in iterators.</span></span>
- <span data-ttu-id="9a90c-230">Non è possibile acquisire variabili `ref struct` in espressioni lambda o funzioni locali.</span><span class="sxs-lookup"><span data-stu-id="9a90c-230">You cannot capture `ref struct` variables in lambda expressions or local functions.</span></span>

<span data-ttu-id="9a90c-231">Queste restrizioni garantiscono che non si possa usare accidentalmente `ref struct` in modo tale che possa essere alzato di livello nell'heap gestito.</span><span class="sxs-lookup"><span data-stu-id="9a90c-231">These restrictions ensure you do not accidentally use a `ref struct` in a manner that could promote it to the managed heap.</span></span>

## <a name="readonly-ref-struct-type"></a><span data-ttu-id="9a90c-232">Tipo `readonly ref struct`</span><span class="sxs-lookup"><span data-stu-id="9a90c-232">`readonly ref struct` type</span></span>

<span data-ttu-id="9a90c-233">Dichiarando uno struct come `readonly ref` si combinano i vantaggi e le restrizioni delle dichiarazioni `ref struct` e `readonly struct`.</span><span class="sxs-lookup"><span data-stu-id="9a90c-233">Declaring a struct as `readonly ref` combines the benefits and restrictions of `ref struct` and `readonly struct` delcarations.</span></span> 

<span data-ttu-id="9a90c-234">L'esempio seguente illustra la dichiarazione di `readonly ref struct`.</span><span class="sxs-lookup"><span data-stu-id="9a90c-234">The following example demonstrates the declaration of `readonly ref struct`.</span></span>

```csharp
readonly ref struct ReadOnlyRefPoint2D
{
    public int X { get; }
    public int Y { get; }
    
    public ReadOnlyRefPoint2D(int x, int y) => (X, Y) = (x, y);
}
```

## <a name="conclusions"></a><span data-ttu-id="9a90c-235">Conclusioni</span><span class="sxs-lookup"><span data-stu-id="9a90c-235">Conclusions</span></span>

<span data-ttu-id="9a90c-236">Questi miglioramenti del linguaggio C# sono progettati per gli algoritmi con prestazioni critiche in cui le allocazioni della memoria possono essere strategiche per raggiungere le prestazioni necessarie.</span><span class="sxs-lookup"><span data-stu-id="9a90c-236">These enhancements to the C# language are designed for performance critical algorithms where memory allocations can be critical to achieving the necessary performance.</span></span> <span data-ttu-id="9a90c-237">È possibile che non si usino spesso queste funzionalità nella scrittura del codice.</span><span class="sxs-lookup"><span data-stu-id="9a90c-237">You may find that you don't often use these features in the code you write.</span></span> <span data-ttu-id="9a90c-238">Questi miglioramenti sono stati tuttavia adottati in diverse posizioni di .NET Framework.</span><span class="sxs-lookup"><span data-stu-id="9a90c-238">However, these enhancements have been adopted in many locations in the .NET Framework.</span></span> <span data-ttu-id="9a90c-239">Il sempre maggior numero di API che useranno queste funzionalità renderà evidente il miglioramento delle prestazioni delle applicazioni.</span><span class="sxs-lookup"><span data-stu-id="9a90c-239">As more and more APIs make use of these features, you'll see the performance of your own applications improve.</span></span>
