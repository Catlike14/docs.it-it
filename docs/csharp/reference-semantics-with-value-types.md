---
title: Semantica di riferimento con tipi di valore
description: "Comprendere le funzionalità del linguaggio che riducono al minimo la copia di strutture in modo sicuro"
author: billwagner
ms.author: wiwagn
ms.date: 11/10/2017
ms.topic: article
ms.prod: .net
ms.technology: devlang-csharp
ms.devlang: csharp
ms.custom: mvc
ms.openlocfilehash: 9eeaf201c1f5a58044db62e356199b609c4c035a
ms.sourcegitcommit: 7e99f66ef09d2903e22c789c67ff5a10aa953b2f
ms.translationtype: HT
ms.contentlocale: it-IT
ms.lasthandoff: 11/18/2017
---
# <a name="reference-semantics-with-value-types"></a><span data-ttu-id="07156-103">Semantica di riferimento con tipi di valore</span><span class="sxs-lookup"><span data-stu-id="07156-103">Reference semantics with value types</span></span>

<span data-ttu-id="07156-104">Un vantaggio dell'utilizzo di tipi di valore è spesso evitare allocazioni di heap.</span><span class="sxs-lookup"><span data-stu-id="07156-104">An advantage to using value types is that they often avoid heap allocations.</span></span>
<span data-ttu-id="07156-105">Lo svantaggio corrispondente è che vengono copiati dal valore.</span><span class="sxs-lookup"><span data-stu-id="07156-105">The corresponding disadvantage is that they are copied by value.</span></span> <span data-ttu-id="07156-106">Questo compromesso rende più difficile ottimizzare gli algoritmi che operano su grandi quantità di dati.</span><span class="sxs-lookup"><span data-stu-id="07156-106">This tradeoff makes it harder to optimize algorithms that operate on large amounts of data.</span></span> <span data-ttu-id="07156-107">Nuove funzionalità del linguaggio c# 7.2 fornire meccanismi che consentano la semantica di passaggio per riferimento con tipi di valore.</span><span class="sxs-lookup"><span data-stu-id="07156-107">New language features in C# 7.2 provide mechanisms that enable pass-by-reference semantics with value types.</span></span> <span data-ttu-id="07156-108">Se si utilizzano queste funzionalità in modo appropriato, è possibile ridurre al minimo entrambe le allocazioni e operazioni di copia.</span><span class="sxs-lookup"><span data-stu-id="07156-108">If you use these features wisely you can minimize both allocations and copy operations.</span></span> <span data-ttu-id="07156-109">Questo articolo esamina le nuove funzionalità.</span><span class="sxs-lookup"><span data-stu-id="07156-109">This article explores those new features.</span></span>

<span data-ttu-id="07156-110">Gran parte del codice di esempio in questo articolo illustra le funzionalità aggiunte in c# 7.2.</span><span class="sxs-lookup"><span data-stu-id="07156-110">Much of the sample code in this article demonstrates features added in C# 7.2.</span></span> <span data-ttu-id="07156-111">Per utilizzare queste funzionalità, è necessario configurare il progetto per l'utilizzo di c# 7.2 o versione successiva nel progetto.</span><span class="sxs-lookup"><span data-stu-id="07156-111">In order to use those features, you have to configure your project to use C# 7.2 or later in your project.</span></span> <span data-ttu-id="07156-112">È possibile utilizzare Visual Studio per selezionarlo.</span><span class="sxs-lookup"><span data-stu-id="07156-112">You can use Visual Studio to select it.</span></span> <span data-ttu-id="07156-113">Per ogni progetto, selezionare **progetto** dal menu, quindi **proprietà**.</span><span class="sxs-lookup"><span data-stu-id="07156-113">For each project, select **Project** from the menu, then **Properties**.</span></span> <span data-ttu-id="07156-114">Selezionare il **compilare** scheda e fare clic su **avanzate**.</span><span class="sxs-lookup"><span data-stu-id="07156-114">Select the **Build** tab and click **Advanced**.</span></span> <span data-ttu-id="07156-115">Da qui, è possibile configurare la versione in lingua.</span><span class="sxs-lookup"><span data-stu-id="07156-115">From there, you can configure the language version.</span></span> <span data-ttu-id="07156-116">Selezionare "7.2" o "più recente".</span><span class="sxs-lookup"><span data-stu-id="07156-116">Choose either "7.2", or "latest".</span></span>  <span data-ttu-id="07156-117">È possibile modificare il *csproj* file e aggiungere il nodo seguente:</span><span class="sxs-lookup"><span data-stu-id="07156-117">Or you can edit the *csproj* file and add the following node:</span></span>

```XML
  <PropertyGroup>
    <LangVersion>7.2</LangVersion>
  </PropertyGroup>
```

<span data-ttu-id="07156-118">È possibile utilizzare "7,2" o "più recente" per il valore.</span><span class="sxs-lookup"><span data-stu-id="07156-118">You can use either "7.2" or "latest" for the value.</span></span>

## <a name="specifying-in-parameters"></a><span data-ttu-id="07156-119">Specifica di `in` parametri</span><span class="sxs-lookup"><span data-stu-id="07156-119">Specifying `in` parameters</span></span>

<span data-ttu-id="07156-120">7.2 c# aggiunge il `in` (parola chiave) per integrare esistente `ref` e `out` parole chiave quando si scrive un metodo che passa gli argomenti per riferimento.</span><span class="sxs-lookup"><span data-stu-id="07156-120">C# 7.2 adds the `in` keyword to complement the existing `ref` and `out` keywords when you write a method that passes arguments by reference.</span></span> <span data-ttu-id="07156-121">Il `in` (parola chiave) specifica che si passa il parametro per riferimento e il metodo chiamato non modifica il valore passato.</span><span class="sxs-lookup"><span data-stu-id="07156-121">The `in` keyword specifies that you are passing the parameter by reference and the called method does not modify the value passed to it.</span></span> 

<span data-ttu-id="07156-122">In questo modo fornisce un vocabolario completo per esprimere la finalità di progettazione.</span><span class="sxs-lookup"><span data-stu-id="07156-122">This addition provides a full vocabulary to express your design intent.</span></span> <span data-ttu-id="07156-123">Tipi di valore vengono copiati quando viene passato a un metodo chiamato quando non si specifica uno dei seguenti modificatori.</span><span class="sxs-lookup"><span data-stu-id="07156-123">Value types are copied when passed to a called method when you do not specify any of the following modifiers.</span></span> <span data-ttu-id="07156-124">Ognuno di questi modificatori di specificare un tipo di valore viene passato per riferimento, di copia.</span><span class="sxs-lookup"><span data-stu-id="07156-124">Each of these modifiers specify that a value type is passed by reference, avoiding the copy.</span></span> <span data-ttu-id="07156-125">Ogni modificatore esprime diversi:</span><span class="sxs-lookup"><span data-stu-id="07156-125">Each modifier expresses a different intent:</span></span>

- <span data-ttu-id="07156-126">`out`: Questo metodo imposta il valore dell'argomento utilizzato come questo parametro.</span><span class="sxs-lookup"><span data-stu-id="07156-126">`out`: This method sets the value of the argument used as this parameter.</span></span>
- <span data-ttu-id="07156-127">`ref`: Questo metodo consente di impostare il valore dell'argomento utilizzato come questo parametro.</span><span class="sxs-lookup"><span data-stu-id="07156-127">`ref`: This method may set the value of the argument used as this parameter.</span></span>
- <span data-ttu-id="07156-128">`in`: Questo metodo non modifica il valore dell'argomento utilizzato come questo parametro.</span><span class="sxs-lookup"><span data-stu-id="07156-128">`in`: This method does not modify the value of the argument used as this parameter.</span></span>

<span data-ttu-id="07156-129">Quando si aggiunge il `in` modificatore per passare un argomento per riferimento, si dichiara la finalità di progettazione consiste nel passare argomenti per riferimento per evitare la copia non necessarie.</span><span class="sxs-lookup"><span data-stu-id="07156-129">When you add the `in` modifier to pass an argument by reference, you declare your design intent is to pass arguments by reference to avoid unnecessary copying.</span></span> <span data-ttu-id="07156-130">Non si intende modificare l'oggetto utilizzato come argomento.</span><span class="sxs-lookup"><span data-stu-id="07156-130">You do not intend to modify the object used as that argument.</span></span> <span data-ttu-id="07156-131">Il codice seguente viene illustrato un esempio di un metodo che calcola la distanza tra due punti nello spazio 3D.</span><span class="sxs-lookup"><span data-stu-id="07156-131">The following code shows an example of a method that calculates the distance between two points in 3D space.</span></span> 

[!code-csharp[InArgument](../../samples/csharp/reference-semantics/Program.cs#InArgument "Specifying an In argument")]

<span data-ttu-id="07156-132">Gli argomenti sono due strutture di ciascuno dei quali contiene tre valori Double.</span><span class="sxs-lookup"><span data-stu-id="07156-132">The arguments are two structures that each contain three doubles.</span></span> <span data-ttu-id="07156-133">Un valore double è di 8 byte, pertanto ogni argomento è di 24 byte.</span><span class="sxs-lookup"><span data-stu-id="07156-133">A double is 8 bytes, so each argument is 24 bytes.</span></span> <span data-ttu-id="07156-134">Specificando il `in` modificatore, passare 4 o 8 byte riferimento a tali argomenti, a seconda dell'architettura del computer.</span><span class="sxs-lookup"><span data-stu-id="07156-134">By specifying the `in` modifier, you pass 4-byte or 8-byte reference to those arguments, depending on the architecture of the machine.</span></span> <span data-ttu-id="07156-135">Differenza nella dimensione è ridotto, ma è possibile aggiungere rapidamente quando l'applicazione chiama questo metodo in un ciclo rigido utilizzando molti valori diversi.</span><span class="sxs-lookup"><span data-stu-id="07156-135">The difference in size is small, but it can quickly add up when your application calls this method in a tight loop using many different values.</span></span>
 
<span data-ttu-id="07156-136">Il `in` modificatore integra `out` e `ref` in anche altri modi.</span><span class="sxs-lookup"><span data-stu-id="07156-136">The `in` modifier complements `out` and `ref` in other ways as well.</span></span> <span data-ttu-id="07156-137">Non è possibile creare gli overload di un metodo che differiscono solo in presenza di `in`, `out` o `ref`.</span><span class="sxs-lookup"><span data-stu-id="07156-137">You cannot create overloads of a method that differ only in the presence of `in`, `out` or `ref`.</span></span> <span data-ttu-id="07156-138">Queste nuove regole di estendono lo stesso comportamento che sempre fosse stato definito per `out` e `ref` parametri.</span><span class="sxs-lookup"><span data-stu-id="07156-138">These new rules extend the same behavior that had always been defined for `out` and `ref` parameters.</span></span>

<span data-ttu-id="07156-139">Il `in` modificatore può essere applicato a qualsiasi membro che accetta parametri: metodi, delegati, le espressioni lambda, le funzioni locali, gli indicizzatori, gli operatori.</span><span class="sxs-lookup"><span data-stu-id="07156-139">The `in` modifier may be applied to any member that takes parameters: methods, delegates, lambdas, local functions, indexers, operators.</span></span>

<span data-ttu-id="07156-140">A differenza di `ref` e `out` argomenti, è possibile utilizzare valori letterali o le costanti per l'argomento di un `in` parametro.</span><span class="sxs-lookup"><span data-stu-id="07156-140">Unlike `ref` and `out` arguments, you may use literal values or constants for the argument to an `in` parameter.</span></span> <span data-ttu-id="07156-141">Inoltre, a differenza di un `ref` o `out` parametro, non è necessario applicare il `in` modificatore nel sito di chiamata.</span><span class="sxs-lookup"><span data-stu-id="07156-141">Also, unlike a `ref` or `out` parameter, you don't need to apply the `in` modifier at the call site.</span></span> <span data-ttu-id="07156-142">Il codice seguente mostra due esempi di chiamata di `CalculateDistance` metodo.</span><span class="sxs-lookup"><span data-stu-id="07156-142">The following code shows you two examples of calling the `CalculateDistance` method.</span></span> <span data-ttu-id="07156-143">Il primo usa due variabili locali, passate per riferimento.</span><span class="sxs-lookup"><span data-stu-id="07156-143">The first uses two local variables passed by reference.</span></span> <span data-ttu-id="07156-144">Il secondo include una variabile temporanea creata come parte della chiamata al metodo.</span><span class="sxs-lookup"><span data-stu-id="07156-144">The second includes a temporary variable created as part of the method call.</span></span> 

[!code-csharp[UseInArgument](../../samples/csharp/reference-semantics/Program.cs#UseInArgument "Specifying an In argument")]

<span data-ttu-id="07156-145">Esistono diversi modi in cui il compilatore garantisce che la natura di sola lettura di un `in` viene applicato l'argomento.</span><span class="sxs-lookup"><span data-stu-id="07156-145">There are several ways in which the compiler ensures that the read-only nature of an `in` argument is enforced.</span></span>  <span data-ttu-id="07156-146">Prima di tutto, il metodo chiamato non è possibile assegnare direttamente un `in` parametro.</span><span class="sxs-lookup"><span data-stu-id="07156-146">First of all, the called method can't directly assign to an `in` parameter.</span></span> <span data-ttu-id="07156-147">È possibile assegnare direttamente a qualsiasi campo di un `in` parametro.</span><span class="sxs-lookup"><span data-stu-id="07156-147">It can't directly assign to any field of an `in` parameter.</span></span> <span data-ttu-id="07156-148">Inoltre, non è possibile passare un `in` parametro alle eventuali rigorose del metodo di `ref` o `out` modificatore.</span><span class="sxs-lookup"><span data-stu-id="07156-148">In addition, you cannot pass an `in` parameter to any method demanding the `ref` or `out` modifier.</span></span>
<span data-ttu-id="07156-149">Il compilatore impone che il `in` argomento è una variabile di sola lettura.</span><span class="sxs-lookup"><span data-stu-id="07156-149">The compiler enforces that the `in` argument is a readonly variable.</span></span> <span data-ttu-id="07156-150">È possibile chiamare qualsiasi metodo di istanza che utilizza la semantica pass-by-value.</span><span class="sxs-lookup"><span data-stu-id="07156-150">You can call any instance method that uses pass-by-value semantics.</span></span> <span data-ttu-id="07156-151">In tali casi, una copia del `in` parametro viene creato.</span><span class="sxs-lookup"><span data-stu-id="07156-151">In those instances, a copy of the `in` parameter is created.</span></span> <span data-ttu-id="07156-152">Poiché il compilatore può creare una variabile temporanea per qualsiasi `in` parametro, è anche possibile specificare i valori predefiniti per qualsiasi `in` parametro.</span><span class="sxs-lookup"><span data-stu-id="07156-152">Because the compiler can create a temporary variable for any `in` parameter, you can also specify default values for any `in` parameter.</span></span> <span data-ttu-id="07156-153">Nel codice seguente che usa per specificare l'origine (punto 0,0) come valore predefinito per il secondo punto:</span><span class="sxs-lookup"><span data-stu-id="07156-153">The follow code uses that to specify the origin (point 0,0) as the default value for the second point:</span></span>

[!code-csharp[InArgumentDefault](../../samples/csharp/reference-semantics/Program.cs#InArgumentDefault "Specifying defaults for an in parameter")]

<span data-ttu-id="07156-154">Il `in` designazione di parametro può essere utilizzata con tipi di riferimento o compilazione nei valori numerici.</span><span class="sxs-lookup"><span data-stu-id="07156-154">The `in` parameter designation can also be used with reference types or built in numeric values.</span></span> <span data-ttu-id="07156-155">Tuttavia, i vantaggi in entrambi i casi sono minimi, se presente.</span><span class="sxs-lookup"><span data-stu-id="07156-155">However, the benefits in both cases are minimal, if any.</span></span>

## <a name="ref-readonly-returns"></a><span data-ttu-id="07156-156">`ref readonly`Restituisce</span><span class="sxs-lookup"><span data-stu-id="07156-156">`ref readonly` returns</span></span>

<span data-ttu-id="07156-157">È anche possibile restituire un tipo di valore per riferimento, ma non consentire al chiamante di modificare tale valore.</span><span class="sxs-lookup"><span data-stu-id="07156-157">You may also want to return a value type by reference, but disallow the caller from modifying that value.</span></span> <span data-ttu-id="07156-158">Utilizzare il `ref readonly` modificatore per esprimere la finalità di progettazione.</span><span class="sxs-lookup"><span data-stu-id="07156-158">Use the `ref readonly` modifier to express that design intent.</span></span> <span data-ttu-id="07156-159">Invia una notifica a lettori che restituisce un riferimento ai dati esistenti, ma non consente la modifica.</span><span class="sxs-lookup"><span data-stu-id="07156-159">It notifies readers that you are returning a reference to existing data, but not allowing modification.</span></span> 

<span data-ttu-id="07156-160">Il compilatore impone che il chiamante non è possibile modificare il riferimento.</span><span class="sxs-lookup"><span data-stu-id="07156-160">The compiler enforces that the caller cannot modify the reference.</span></span> <span data-ttu-id="07156-161">Tenta di assegnare direttamente il valore generato un errore in fase di compilazione.</span><span class="sxs-lookup"><span data-stu-id="07156-161">Attempts to assign to the value directly generate a compile-time error.</span></span> <span data-ttu-id="07156-162">Tuttavia, il compilatore non sa se qualsiasi metodo di membro viene modificato lo stato dello struct.</span><span class="sxs-lookup"><span data-stu-id="07156-162">However, the compiler cannot know if any member method modifies the state of the struct.</span></span>
<span data-ttu-id="07156-163">Per garantire che l'oggetto non viene modificato, il compilatore crea una copia e chiama membro riferimenti utilizzando tale copia.</span><span class="sxs-lookup"><span data-stu-id="07156-163">To ensure that the object is not modified, the compiler creates a copy and calls member references using that copy.</span></span> <span data-ttu-id="07156-164">Tutte le modifiche sono a tale copia difensivo.</span><span class="sxs-lookup"><span data-stu-id="07156-164">Any modifications are to that defensive copy.</span></span> 

<span data-ttu-id="07156-165">È probabile che la libreria utilizzando `Point3D` spesso utilizzerebbe l'origine in tutto il codice.</span><span class="sxs-lookup"><span data-stu-id="07156-165">It's likely that the library using `Point3D` would often use the origin throughout the code.</span></span> <span data-ttu-id="07156-166">Ogni istanza crea un nuovo oggetto nello stack.</span><span class="sxs-lookup"><span data-stu-id="07156-166">Every instance creates a new object on the stack.</span></span> <span data-ttu-id="07156-167">Può risultare utile per creare una costante e viene restituito per riferimento.</span><span class="sxs-lookup"><span data-stu-id="07156-167">It may be advantageous to create a constant and return it by reference.</span></span> <span data-ttu-id="07156-168">Tuttavia, se si restituisce un riferimento all'archiviazione interna, si desidera imporre che il chiamante non è possibile modificare lo spazio di archiviazione a cui fa riferimento.</span><span class="sxs-lookup"><span data-stu-id="07156-168">But, if you return a reference to internal storage, you may want to enforce that the caller cannot modify the referenced storage.</span></span> <span data-ttu-id="07156-169">Il codice seguente definisce una proprietà di sola lettura che restituisce un `readonly ref` per un `Point3D` che specifica l'origine.</span><span class="sxs-lookup"><span data-stu-id="07156-169">The following code defines a read-only property that returns a `readonly ref` to a `Point3D` that specifies the origin.</span></span>

[!code-csharp[OriginReference](../../samples/csharp/reference-semantics/Point3D.cs#OriginReference "Creating a readonly Origin reference")]

<span data-ttu-id="07156-170">Creazione di una copia di un riferimento di sola lettura restituito è semplice: assegna semplicemente a una variabile non è dichiarata con la `ref readonly` modificatore.</span><span class="sxs-lookup"><span data-stu-id="07156-170">Creating a copy of a ref readonly return is easy: Just assign it to a variable not declared with the `ref readonly` modifier.</span></span> <span data-ttu-id="07156-171">Il compilatore genera codice per copiare l'oggetto come parte dell'assegnazione.</span><span class="sxs-lookup"><span data-stu-id="07156-171">The compiler generates code to copy the object as part of the assignment.</span></span> 

<span data-ttu-id="07156-172">Quando si assegna una variabile per un `ref readonly return`, è possibile specificare un `ref readonly` variabile o una copia in base al valore del riferimento di sola lettura:</span><span class="sxs-lookup"><span data-stu-id="07156-172">When you assign a variable to a `ref readonly return`, you can specify either a `ref readonly` variable, or a by-value copy of the readonly reference:</span></span>

[!code-csharp[AssignRefReadonly](../../samples/csharp/reference-semantics/Program.cs#AssignRefReadonly "Assigning a ref readonly")]

<span data-ttu-id="07156-173">Copia la prima assegnazione nel codice precedente il `Origin` costante e assegna tale copia.</span><span class="sxs-lookup"><span data-stu-id="07156-173">The first assignment in the preceding code makes a copy of the `Origin` constant and assigns that copy.</span></span> <span data-ttu-id="07156-174">Il secondo consente di assegnare un riferimento.</span><span class="sxs-lookup"><span data-stu-id="07156-174">The second assigns a reference.</span></span> <span data-ttu-id="07156-175">Si noti che il `readonly` modificatore deve essere parte della dichiarazione della variabile.</span><span class="sxs-lookup"><span data-stu-id="07156-175">Notice that the `readonly` modifier must be part of the declaration of the variable.</span></span> <span data-ttu-id="07156-176">Il riferimento a cui viene fatto riferimento non può essere modificato.</span><span class="sxs-lookup"><span data-stu-id="07156-176">The reference to which it refers cannot be modified.</span></span> <span data-ttu-id="07156-177">I tentativi di eseguire questa operazione generano un errore in fase di compilazione.</span><span class="sxs-lookup"><span data-stu-id="07156-177">Attempts to do so result in a compile-time error.</span></span>

## <a name="readonly-struct-type"></a><span data-ttu-id="07156-178">Tipo `readonly struct`</span><span class="sxs-lookup"><span data-stu-id="07156-178">`readonly struct` type</span></span>

<span data-ttu-id="07156-179">L'applicazione `ref readonly` a traffico elevato utilizzi di uno struct, potrebbe essere sufficiente.</span><span class="sxs-lookup"><span data-stu-id="07156-179">Applying `ref readonly` to high-traffic uses of a struct may be sufficient.</span></span>
<span data-ttu-id="07156-180">In altri casi, è consigliabile creare un struct non modificabile.</span><span class="sxs-lookup"><span data-stu-id="07156-180">Other times, you may want to create an immutable struct.</span></span> <span data-ttu-id="07156-181">È sempre possibile passare per riferimento di sola lettura.</span><span class="sxs-lookup"><span data-stu-id="07156-181">Then you can always pass by readonly reference.</span></span> <span data-ttu-id="07156-182">Di norma rimuove difensiva copia che si verificano quando si accede ai metodi di una struttura utilizzata come un `in` parametro.</span><span class="sxs-lookup"><span data-stu-id="07156-182">That practice removes the defensive copies that take place when you access methods of a struct used as an `in` parameter.</span></span>

<span data-ttu-id="07156-183">È possibile farlo creando un `readonly struct` tipo.</span><span class="sxs-lookup"><span data-stu-id="07156-183">You can do that by creating a `readonly struct` type.</span></span> <span data-ttu-id="07156-184">È possibile aggiungere il `readonly` modificatore in una dichiarazione di struttura.</span><span class="sxs-lookup"><span data-stu-id="07156-184">You can add the `readonly` modifier to a struct declaration.</span></span> <span data-ttu-id="07156-185">Il compilatore impone che tutti i membri dello struct sono `readonly`; `struct` deve essere non modificabile.</span><span class="sxs-lookup"><span data-stu-id="07156-185">The compiler enforces that all members of the struct are `readonly`; the `struct` must be immutable.</span></span>

<span data-ttu-id="07156-186">Sono disponibili altre ottimizzazioni per un `readonly struct`.</span><span class="sxs-lookup"><span data-stu-id="07156-186">There are other optimizations for a `readonly struct`.</span></span> <span data-ttu-id="07156-187">È possibile utilizzare il `in` modificatore in qualunque posizione in cui un `readonly struct` è un argomento.</span><span class="sxs-lookup"><span data-stu-id="07156-187">You can use the `in` modifier at every location where a `readonly struct` is an argument.</span></span> <span data-ttu-id="07156-188">Inoltre, è possibile restituire un `readonly struct` come un `ref return` quando viene restituito un oggetto la cui durata si estende oltre l'ambito del metodo restituisce l'oggetto.</span><span class="sxs-lookup"><span data-stu-id="07156-188">In addition, you can return a `readonly struct` as a `ref return` when you are returning an object whose lifetime extends beyond the scope of the method returning the object.</span></span>

<span data-ttu-id="07156-189">Infine, il compilatore genera codice più efficiente quando si chiamano i membri di un `readonly struct`: il `this` riferimento, anziché una copia del ricevitore, è sempre un `in` parametro passato per riferimento al metodo del membro.</span><span class="sxs-lookup"><span data-stu-id="07156-189">Finally, the compiler generates more efficient code when you call members of a `readonly struct`: The `this` reference, instead of a copy of the receiver, is always an `in` parameter passed by reference to the member method.</span></span> <span data-ttu-id="07156-190">Questa ottimizzazione consente di salvare la copia più quando si utilizza un `readonly struct`.</span><span class="sxs-lookup"><span data-stu-id="07156-190">This optimization saves more copying when you use a `readonly struct`.</span></span> <span data-ttu-id="07156-191">Il `Point3D` è un ottimo candidato per la modifica.</span><span class="sxs-lookup"><span data-stu-id="07156-191">The `Point3D` is a great candidate for this change.</span></span> <span data-ttu-id="07156-192">Nel codice seguente viene aggiornata `ReadonlyPoint3D` struttura:</span><span class="sxs-lookup"><span data-stu-id="07156-192">The following code shows an updated `ReadonlyPoint3D` structure:</span></span>

[!code-csharp[ReadonlyOnlyPoint3D](../../samples/csharp/reference-semantics/Point3D.cs#ReadonlyOnlyPoint3D "Defining an immutable structure")]

## <a name="ref-struct-type"></a><span data-ttu-id="07156-193">Tipo `ref struct`</span><span class="sxs-lookup"><span data-stu-id="07156-193">`ref struct` type</span></span>

<span data-ttu-id="07156-194">Un'altra funzionalità del linguaggio correlato è la possibilità di dichiarare un tipo di valore che deve essere allocato nello stack.</span><span class="sxs-lookup"><span data-stu-id="07156-194">Another related language feature is the ability to declare a value type that must be stack allocated.</span></span> <span data-ttu-id="07156-195">In altre parole, questi tipi non possono mai essere creati nell'heap come membro di un'altra classe.</span><span class="sxs-lookup"><span data-stu-id="07156-195">In other words, these types can never be created on the heap as a member of another class.</span></span> <span data-ttu-id="07156-196">La principale motivazione per questa funzionalità è stata <xref:System.Span%601> e strutture correlate.</span><span class="sxs-lookup"><span data-stu-id="07156-196">The primary motivation for this feature was <xref:System.Span%601> and related structures.</span></span> <span data-ttu-id="07156-197"><xref:System.Span%601>contenga un puntatore gestito come uno dei relativi membri, mentre l'altro è la lunghezza dell'intervallo.</span><span class="sxs-lookup"><span data-stu-id="07156-197"><xref:System.Span%601> may contain a managed pointer as one of its members, the other being the length of the span.</span></span> <span data-ttu-id="07156-198">È effettivamente implementata in modo leggermente diverso perché c# non supporta i puntatori alla memoria gestita di fuori di un contesto unsafe.</span><span class="sxs-lookup"><span data-stu-id="07156-198">It's actually implemented a bit differently because C# doesn't support pointers to managed memory outside of an unsafe context.</span></span> <span data-ttu-id="07156-199">Qualsiasi scrittura che modifica il puntatore del mouse e la lunghezza non è atomico.</span><span class="sxs-lookup"><span data-stu-id="07156-199">Any write that changes the pointer and the length is not atomic.</span></span> <span data-ttu-id="07156-200">Ciò significa che un <xref:System.Span%601> sarà soggetto a errori di intervallo insufficiente o altre violazioni di sicurezza di tipo sono stati non è vincolato da un unico stack frame.</span><span class="sxs-lookup"><span data-stu-id="07156-200">That means a <xref:System.Span%601> would be subject to out of range errors or other type safety violations were it not constrained to a single stack frame.</span></span> <span data-ttu-id="07156-201">Inoltre, l'inserimento di un puntatore gestito nell'heap GC in genere si blocca in fase di JIT.</span><span class="sxs-lookup"><span data-stu-id="07156-201">In addition, putting a managed pointer on the GC heap typically crashes at JIT time.</span></span>

<span data-ttu-id="07156-202">È possibile requisiti simili operazioni con la memoria creata utilizzando [ `stackalloc` ](language-reference/keywords/stackalloc.md) o quando si utilizza memoria dalle API di interoperabilità.</span><span class="sxs-lookup"><span data-stu-id="07156-202">You may have similar requirements working with memory created using [`stackalloc`](language-reference/keywords/stackalloc.md) or when using memory from interop APIs.</span></span> <span data-ttu-id="07156-203">È possibile definire `ref struct` tipi per tali requisiti.</span><span class="sxs-lookup"><span data-stu-id="07156-203">You can define your own `ref struct` types for those needs.</span></span> <span data-ttu-id="07156-204">In questo articolo si vedere esempi di utilizzo `Span<T>` per semplicità.</span><span class="sxs-lookup"><span data-stu-id="07156-204">In this article, you see examples using `Span<T>` for simplicity.</span></span>

<span data-ttu-id="07156-205">Il `ref struct` dichiarazione dichiara che una struttura di questo tipo deve essere nello stack.</span><span class="sxs-lookup"><span data-stu-id="07156-205">The `ref struct` declaration declares that a struct of this type must be on the stack.</span></span> <span data-ttu-id="07156-206">Le regole del linguaggio verificare l'utilizzo sicuro di questi tipi.</span><span class="sxs-lookup"><span data-stu-id="07156-206">The language rules ensure the safe use of these types.</span></span> <span data-ttu-id="07156-207">Altri tipi dichiarati come `ref struct` includono <xref:System.ReadOnlySpan%601>.</span><span class="sxs-lookup"><span data-stu-id="07156-207">Other types declared as `ref struct` include <xref:System.ReadOnlySpan%601>.</span></span> 

<span data-ttu-id="07156-208">L'obiettivo di mantenere un `ref struct` digitare come una variabile allocato dallo stack introduce diverse regole che il compilatore impone per tutti i `ref struct` tipi.</span><span class="sxs-lookup"><span data-stu-id="07156-208">The goal of keeping a `ref struct` type as a stack-allocated variable introduces several rules that the compiler enforces for all `ref struct` types.</span></span>

- <span data-ttu-id="07156-209">Non supporta il boxing è una `ref struct`.</span><span class="sxs-lookup"><span data-stu-id="07156-209">You can't box a `ref struct`.</span></span> <span data-ttu-id="07156-210">Non è possibile assegnare un `ref struct` tipo a una variabile di tipo `object`, `dynamic`, o qualsiasi tipo di interfaccia.</span><span class="sxs-lookup"><span data-stu-id="07156-210">You cannot assign a `ref struct` type to a variable of type `object`, `dynamic`, or any interface type.</span></span>
- <span data-ttu-id="07156-211">Non è possibile dichiarare un `ref struct` come membro di una classe o uno struct normale.</span><span class="sxs-lookup"><span data-stu-id="07156-211">You can't declare a `ref struct` as a member of a class or a normal struct.</span></span>
- <span data-ttu-id="07156-212">Non è possibile dichiarare le variabili locali con `ref struct` tipi di metodi asincroni.</span><span class="sxs-lookup"><span data-stu-id="07156-212">You cannot declare local variables that are `ref struct` types in async methods.</span></span> <span data-ttu-id="07156-213">È possibile dichiararli in metodi sincroni che restituiscono `Task`, `Task<T>` o tipi di attività.</span><span class="sxs-lookup"><span data-stu-id="07156-213">You can declare them in synchronous methods that return `Task`, `Task<T>` or Task-like types.</span></span>
- <span data-ttu-id="07156-214">Non è possibile dichiarare `ref struct` variabili locali, gli iteratori.</span><span class="sxs-lookup"><span data-stu-id="07156-214">You cannot declare `ref struct` local variables in iterators.</span></span>
- <span data-ttu-id="07156-215">Non è possibile acquisire `ref struct` variabili nelle espressioni lambda o di funzioni locali.</span><span class="sxs-lookup"><span data-stu-id="07156-215">You cannot capture `ref struct` variables in lambda expressions or local functions.</span></span>

<span data-ttu-id="07156-216">In questo modo che non si accidentalmente utilizza un `ref struct` in modo che è stato possibile alzare di livello per l'heap gestito.</span><span class="sxs-lookup"><span data-stu-id="07156-216">These restrictions ensure that you do not accidentally use a `ref struct` in a manner that could promote it to the managed heap.</span></span>

## <a name="conclusions"></a><span data-ttu-id="07156-217">Conclusioni</span><span class="sxs-lookup"><span data-stu-id="07156-217">Conclusions</span></span>

<span data-ttu-id="07156-218">Questi miglioramenti del linguaggio c# sono progettati per gli algoritmi di prestazioni critiche in cui le allocazioni di memoria possono essere fondamentale per ottenere le prestazioni necessarie.</span><span class="sxs-lookup"><span data-stu-id="07156-218">These enhancements to the C# language are designed for performance critical algorithms where memory allocations can be critical to achieving the necessary performance.</span></span> <span data-ttu-id="07156-219">È possibile che non vengano utilizzati spesso queste funzionalità nel codice che scritto.</span><span class="sxs-lookup"><span data-stu-id="07156-219">You may find that you don't often use these features in the code you write.</span></span> <span data-ttu-id="07156-220">Tuttavia, questi miglioramenti sono stati adottati in numerose posizioni in .NET Framework.</span><span class="sxs-lookup"><span data-stu-id="07156-220">However, these enhancements have been adopted in many locations in the .NET Framework.</span></span> <span data-ttu-id="07156-221">Come rendere più API utilizzare queste funzionalità, si noterà un' migliorare le prestazioni delle applicazioni.</span><span class="sxs-lookup"><span data-stu-id="07156-221">As more and more APIs make use of these features, you'll see the performance of your own applications improve.</span></span>
