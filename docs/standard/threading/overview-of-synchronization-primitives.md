---
title: Cenni preliminari sulle primitive di sincronizzazione
ms.custom: 
ms.date: 03/30/2017
ms.prod: .net
ms.reviewer: 
ms.suite: 
ms.technology: dotnet-standard
ms.tgt_pltfrm: 
ms.topic: article
helpviewer_keywords:
- synchronization, threads
- threading [.NET Framework],synchronizing threads
- managed threading
ms.assetid: b782bcb8-da6a-4c6a-805f-2eb46d504309
caps.latest.revision: "17"
author: rpetrusha
ms.author: ronpet
manager: wpickett
ms.openlocfilehash: 58fb520365d0a80a8f8bc46e3fdbd23483fdf07f
ms.sourcegitcommit: 4f3fef493080a43e70e951223894768d36ce430a
ms.translationtype: HT
ms.contentlocale: it-IT
ms.lasthandoff: 11/21/2017
---
# <a name="overview-of-synchronization-primitives"></a><span data-ttu-id="255b1-102">Cenni preliminari sulle primitive di sincronizzazione</span><span class="sxs-lookup"><span data-stu-id="255b1-102">Overview of Synchronization Primitives</span></span>
<a name="top"></a><span data-ttu-id="255b1-103">.NET Framework fornisce diverse primitive di sincronizzazione per controllare le interazioni dei thread ed evitare race condition.</span><span class="sxs-lookup"><span data-stu-id="255b1-103">The .NET Framework provides a range of synchronization primitives for controlling the interactions of threads and avoiding race conditions.</span></span> <span data-ttu-id="255b1-104">Queste possono essere divise approssimativamente in tre categorie: blocco, segnalazione e operazioni interlocked.</span><span class="sxs-lookup"><span data-stu-id="255b1-104">These can be roughly divided into three categories: locking, signaling, and interlocked operations.</span></span>  
  
 <span data-ttu-id="255b1-105">Le categorie non sono definite in modo chiaro e preciso. Alcuni meccanismi di sincronizzazione possono avere caratteristiche comuni a più categorie: gli eventi che rilasciano un solo thread alla volta sono simili ai blocchi a livello funzionale, il rilascio dei blocchi può essere assimilato a un segnale e le operazioni interlocked possono essere usate per costruire i blocchi.</span><span class="sxs-lookup"><span data-stu-id="255b1-105">The categories are not tidy nor clearly defined: Some synchronization mechanisms have characteristics of multiple categories; events that release a single thread at a time are functionally like locks; the release of any lock can be thought of as a signal; and interlocked operations can be used to construct locks.</span></span> <span data-ttu-id="255b1-106">Questa suddivisione in categorie è comunque utile.</span><span class="sxs-lookup"><span data-stu-id="255b1-106">However, the categories are still useful.</span></span>  
  
 <span data-ttu-id="255b1-107">È importante ricordare che la sincronizzazione dei thread è cooperativa.</span><span class="sxs-lookup"><span data-stu-id="255b1-107">It is important to remember that thread synchronization is cooperative.</span></span> <span data-ttu-id="255b1-108">Se anche un solo thread ignora un meccanismo di sincronizzazione e accede direttamente alla risorsa protetta, meccanismo di sincronizzazione non può essere efficace.</span><span class="sxs-lookup"><span data-stu-id="255b1-108">If even one thread bypasses a synchronization mechanism and accesses the protected resource directly, that synchronization mechanism cannot be effective.</span></span>  
  
 <span data-ttu-id="255b1-109">In questa panoramica sono incluse le sezioni seguenti:</span><span class="sxs-lookup"><span data-stu-id="255b1-109">This overview contains the following sections:</span></span>  
  
-   [<span data-ttu-id="255b1-110">Blocco</span><span class="sxs-lookup"><span data-stu-id="255b1-110">Locking</span></span>](#locking)  
  
-   [<span data-ttu-id="255b1-111">Segnalazione</span><span class="sxs-lookup"><span data-stu-id="255b1-111">Signaling</span></span>](#signaling)  
  
-   [<span data-ttu-id="255b1-112">Tipi di sincronizzazione leggere</span><span class="sxs-lookup"><span data-stu-id="255b1-112">Lightweight Synchronization Types</span></span>](#lightweight_synchronization_types)  
  
-   [<span data-ttu-id="255b1-113">SpinWait</span><span class="sxs-lookup"><span data-stu-id="255b1-113">SpinWait</span></span>](#spinwait)  
  
-   [<span data-ttu-id="255b1-114">Operazioni interlocked</span><span class="sxs-lookup"><span data-stu-id="255b1-114">Interlocked Operations</span></span>](#interlocked_operations)  
  
<a name="locking"></a>   
## <a name="locking"></a><span data-ttu-id="255b1-115">Blocco</span><span class="sxs-lookup"><span data-stu-id="255b1-115">Locking</span></span>  
 <span data-ttu-id="255b1-116">I blocchi consentono il controllo di una risorsa usando un thread alla volta o un numero di thread specificato.</span><span class="sxs-lookup"><span data-stu-id="255b1-116">Locks give control of a resource to one thread at a time, or to a specified number of threads.</span></span> <span data-ttu-id="255b1-117">Un thread che richiede un blocco esclusivo quando il blocco è in uso si blocca finché il blocco non diventa disponibile.</span><span class="sxs-lookup"><span data-stu-id="255b1-117">A thread that requests an exclusive lock when the lock is in use blocks until the lock becomes available.</span></span>  
  
### <a name="exclusive-locks"></a><span data-ttu-id="255b1-118">Blocchi esclusivi</span><span class="sxs-lookup"><span data-stu-id="255b1-118">Exclusive Locks</span></span>  
 <span data-ttu-id="255b1-119">La forma di blocco più semplice è l'istruzione `lock` di C# e l'istruzione `SyncLock` in Visual Basic, che controlla l'accesso a un blocco di codice.</span><span class="sxs-lookup"><span data-stu-id="255b1-119">The simplest form of locking is the `lock` statement in C# and the `SyncLock` statement in Visual Basic, which controls access to a block of code.</span></span> <span data-ttu-id="255b1-120">Questo blocco viene spesso denominato sezione critica.</span><span class="sxs-lookup"><span data-stu-id="255b1-120">Such a block is frequently referred to as a critical section.</span></span> <span data-ttu-id="255b1-121">Il `lock` istruzione viene implementata usando il <xref:System.Threading.Monitor.Enter%2A?displayProperty=nameWithType> e <xref:System.Threading.Monitor.Exit%2A?displayProperty=nameWithType> metodi e utilizza `try…catch…finally` blocco per garantire che il blocco viene rilasciato.</span><span class="sxs-lookup"><span data-stu-id="255b1-121">The `lock` statement is implemented by using the <xref:System.Threading.Monitor.Enter%2A?displayProperty=nameWithType> and <xref:System.Threading.Monitor.Exit%2A?displayProperty=nameWithType> methods, and it uses `try…catch…finally` block to ensure that the lock is released.</span></span>  
  
 <span data-ttu-id="255b1-122">In generale, l'utilizzo di `lock` o `SyncLock` istruzione per proteggere piccoli blocchi di codice, non comprendono più di un singolo metodo, è il modo migliore per utilizzare il <xref:System.Threading.Monitor> classe.</span><span class="sxs-lookup"><span data-stu-id="255b1-122">In general, using the `lock` or `SyncLock` statement to protect small blocks of code, never spanning more than a single method, is the best way to use the <xref:System.Threading.Monitor> class.</span></span> <span data-ttu-id="255b1-123">Sebbene sia potete, la classe <xref:System.Threading.Monitor> è soggetta a blocchi orfani e deadlock.</span><span class="sxs-lookup"><span data-stu-id="255b1-123">Although powerful, the <xref:System.Threading.Monitor> class is prone to orphan locks and deadlocks.</span></span>  
  
#### <a name="monitor-class"></a><span data-ttu-id="255b1-124">Classe Monitor</span><span class="sxs-lookup"><span data-stu-id="255b1-124">Monitor Class</span></span>  
 <span data-ttu-id="255b1-125">La classe <xref:System.Threading.Monitor> fornisce funzionalità aggiuntive che possono essere usate insieme all'istruzione `lock`:</span><span class="sxs-lookup"><span data-stu-id="255b1-125">The <xref:System.Threading.Monitor> class provides additional functionality, which can be used in conjunction with the `lock` statement:</span></span>  
  
-   <span data-ttu-id="255b1-126">Il metodo <xref:System.Threading.Monitor.TryEnter%2A> consente a thread bloccato in attesa della risorsa di annullare l'operazione dopo un intervallo specificato.</span><span class="sxs-lookup"><span data-stu-id="255b1-126">The <xref:System.Threading.Monitor.TryEnter%2A> method allows a thread that is blocked waiting for the resource to give up after a specified interval.</span></span> <span data-ttu-id="255b1-127">Restituisce un valore booleano che indica l'esito dell'operazione, che può essere usato per rilevare ed evitare potenziali deadlock.</span><span class="sxs-lookup"><span data-stu-id="255b1-127">It returns a Boolean value indicating success or failure, which can be used to detect and avoid potential deadlocks.</span></span>  
  
-   <span data-ttu-id="255b1-128">Il metodo <xref:System.Threading.Monitor.Wait%2A> viene chiamato da un thread in una sezione critica.</span><span class="sxs-lookup"><span data-stu-id="255b1-128">The <xref:System.Threading.Monitor.Wait%2A> method is called by a thread in a critical section.</span></span> <span data-ttu-id="255b1-129">Annulla il controllo della risorsa e si blocca finché la risorsa non torna disponibile.</span><span class="sxs-lookup"><span data-stu-id="255b1-129">It gives up control of the resource and blocks until the resource is available again.</span></span>  
  
-   <span data-ttu-id="255b1-130">I metodi <xref:System.Threading.Monitor.Pulse%2A> e <xref:System.Threading.Monitor.PulseAll%2A> consentono a un thread che sta per rilasciare un blocco o per chiamare <xref:System.Threading.Monitor.Wait%2A> di inserire uno o più thread nella coda degli elementi pronti, in modo che possano acquisire il blocco.</span><span class="sxs-lookup"><span data-stu-id="255b1-130">The <xref:System.Threading.Monitor.Pulse%2A> and <xref:System.Threading.Monitor.PulseAll%2A> methods allow a thread that is about to release the lock or to call <xref:System.Threading.Monitor.Wait%2A> to put one or more threads into the ready queue, so that they can acquire the lock.</span></span>  
  
 <span data-ttu-id="255b1-131">I timeout negli overload del metodo <xref:System.Threading.Monitor.Wait%2A> consentono ai thread in attesa di eseguire l'escape nella coda degli elementi pronti.</span><span class="sxs-lookup"><span data-stu-id="255b1-131">Timeouts on <xref:System.Threading.Monitor.Wait%2A> method overloads allow waiting threads to escape to the ready queue.</span></span>  
  
 <span data-ttu-id="255b1-132">La classe <xref:System.Threading.Monitor> può fornire il blocco in più domini applicazioni se l'oggetto usato per il blocco deriva da <xref:System.MarshalByRefObject>.</span><span class="sxs-lookup"><span data-stu-id="255b1-132">The <xref:System.Threading.Monitor> class can provide locking in multiple application domains if the object used for the lock derives from <xref:System.MarshalByRefObject>.</span></span>  
  
 <span data-ttu-id="255b1-133"><xref:System.Threading.Monitor> presenta affinità di thread.</span><span class="sxs-lookup"><span data-stu-id="255b1-133"><xref:System.Threading.Monitor> has thread affinity.</span></span> <span data-ttu-id="255b1-134">In altre parole, un thread che accede al monitor deve uscire chiamando <xref:System.Threading.Monitor.Exit%2A> o <xref:System.Threading.Monitor.Wait%2A>.</span><span class="sxs-lookup"><span data-stu-id="255b1-134">That is, a thread that entered the monitor must exit by calling <xref:System.Threading.Monitor.Exit%2A> or <xref:System.Threading.Monitor.Wait%2A>.</span></span>  
  
 <span data-ttu-id="255b1-135">Non è possibile creare istanze della classe <xref:System.Threading.Monitor>.</span><span class="sxs-lookup"><span data-stu-id="255b1-135">The <xref:System.Threading.Monitor> class is not instantiable.</span></span> <span data-ttu-id="255b1-136">I metodi sono statici (`Shared` in Visual Basic) e vengono eseguiti in un oggetto di blocco istanziabile.</span><span class="sxs-lookup"><span data-stu-id="255b1-136">Its methods are static (`Shared` in Visual Basic), and act on an instantiable lock object.</span></span>  
  
 <span data-ttu-id="255b1-137">Per una panoramica concettuale, vedere [Monitor](http://msdn.microsoft.com/library/33fe4aef-b44b-42fd-9e72-c908e39e75db).</span><span class="sxs-lookup"><span data-stu-id="255b1-137">For a conceptual overview, see [Monitors](http://msdn.microsoft.com/library/33fe4aef-b44b-42fd-9e72-c908e39e75db).</span></span>  
  
#### <a name="mutex-class"></a><span data-ttu-id="255b1-138">Classe Mutex</span><span class="sxs-lookup"><span data-stu-id="255b1-138">Mutex Class</span></span>  
 <span data-ttu-id="255b1-139">I thread richiedono un <xref:System.Threading.Mutex> chiamando un overload del metodo <xref:System.Threading.WaitHandle.WaitOne%2A>.</span><span class="sxs-lookup"><span data-stu-id="255b1-139">Threads request a <xref:System.Threading.Mutex> by calling an overload of its <xref:System.Threading.WaitHandle.WaitOne%2A> method.</span></span> <span data-ttu-id="255b1-140">Gli overload con timeout vengono forniti per consentire ai thread di annullare l'attesa.</span><span class="sxs-lookup"><span data-stu-id="255b1-140">Overloads with timeouts are provided, to allow threads to give up the wait.</span></span> <span data-ttu-id="255b1-141">A differenza della classe <xref:System.Threading.Monitor>, un mutex può essere sia locale che globale.</span><span class="sxs-lookup"><span data-stu-id="255b1-141">Unlike the <xref:System.Threading.Monitor> class, a mutex can be either local or global.</span></span> <span data-ttu-id="255b1-142">I mutex globali, denominati anche mutex, sono visibili in tutto il sistema operativo e possono essere usati per sincronizzare i thread in più domini applicazioni o processi.</span><span class="sxs-lookup"><span data-stu-id="255b1-142">Global mutexes, also called named mutexes, are visible throughout the operating system, and can be used to synchronize threads in multiple application domains or processes.</span></span> <span data-ttu-id="255b1-143">I mutex locali derivano da <xref:System.MarshalByRefObject> e possono essere usati tra i limiti dei domini applicazioni.</span><span class="sxs-lookup"><span data-stu-id="255b1-143">Local mutexes derive from <xref:System.MarshalByRefObject>, and can be used across application domain boundaries.</span></span>  
  
 <span data-ttu-id="255b1-144">Inoltre <xref:System.Threading.Mutex> deriva da <xref:System.Threading.WaitHandle>, quindi può essere usato con i meccanismi di segnalazione forniti da <xref:System.Threading.WaitHandle>, ad esempio i metodi <xref:System.Threading.WaitHandle.WaitAll%2A>, <xref:System.Threading.WaitHandle.WaitAny%2A> e <xref:System.Threading.WaitHandle.SignalAndWait%2A>.</span><span class="sxs-lookup"><span data-stu-id="255b1-144">In addition, <xref:System.Threading.Mutex> derives from <xref:System.Threading.WaitHandle>, which means that it can be used with the signaling mechanisms provided by <xref:System.Threading.WaitHandle>, such as the <xref:System.Threading.WaitHandle.WaitAll%2A>, <xref:System.Threading.WaitHandle.WaitAny%2A>, and <xref:System.Threading.WaitHandle.SignalAndWait%2A> methods.</span></span>  
  
 <span data-ttu-id="255b1-145">Analogamente a <xref:System.Threading.Monitor>, <xref:System.Threading.Mutex> presenta affinità di thread.</span><span class="sxs-lookup"><span data-stu-id="255b1-145">Like <xref:System.Threading.Monitor>, <xref:System.Threading.Mutex> has thread affinity.</span></span> <span data-ttu-id="255b1-146">A differenza di <xref:System.Threading.Monitor>, <xref:System.Threading.Mutex> è un oggetto istanziabile.</span><span class="sxs-lookup"><span data-stu-id="255b1-146">Unlike <xref:System.Threading.Monitor>, a <xref:System.Threading.Mutex> is an instantiable object.</span></span>  
  
 <span data-ttu-id="255b1-147">Per una panoramica concettuale, vedere [Mutex](../../../docs/standard/threading/mutexes.md).</span><span class="sxs-lookup"><span data-stu-id="255b1-147">For a conceptual overview, see [Mutexes](../../../docs/standard/threading/mutexes.md).</span></span>  
  
#### <a name="spinlock-class"></a><span data-ttu-id="255b1-148">Classe SpinLock</span><span class="sxs-lookup"><span data-stu-id="255b1-148">SpinLock Class</span></span>  
 <span data-ttu-id="255b1-149">A partire dal [!INCLUDE[net_v40_long](../../../includes/net-v40-long-md.md)], è possibile utilizzare il <xref:System.Threading.SpinLock> classe quando il sovraccarico richiesto da <xref:System.Threading.Monitor> comporta una riduzione delle prestazioni.</span><span class="sxs-lookup"><span data-stu-id="255b1-149">Starting with the [!INCLUDE[net_v40_long](../../../includes/net-v40-long-md.md)], you can use the <xref:System.Threading.SpinLock> class when the overhead required by <xref:System.Threading.Monitor> degrades performance.</span></span> <span data-ttu-id="255b1-150">Quando <xref:System.Threading.SpinLock> rileva una sezione critica bloccata, avvia semplicemente una rotazione ciclica finché il blocco non diventa disponibile.</span><span class="sxs-lookup"><span data-stu-id="255b1-150">When <xref:System.Threading.SpinLock> encounters a locked critical section, it simply spins in a loop until the lock becomes available.</span></span> <span data-ttu-id="255b1-151">Se il blocco viene mantenuto per un tempo molto breve, la rotazione può fornire prestazioni migliori rispetto al blocco.</span><span class="sxs-lookup"><span data-stu-id="255b1-151">If the lock is held for a very short time, spinning can provide better performance than blocking.</span></span> <span data-ttu-id="255b1-152">Tuttavia, se il blocco viene mantenuto per più di qualche decine di cicli, <xref:System.Threading.SpinLock> così come <xref:System.Threading.Monitor>, ma richiedono più cicli CPU, riducendo le prestazioni di altri thread o processi.</span><span class="sxs-lookup"><span data-stu-id="255b1-152">However, if the lock is held for more than a few tens of cycles, <xref:System.Threading.SpinLock> performs just as well as <xref:System.Threading.Monitor>, but will use more CPU cycles and thus can degrade the performance of other threads or processes.</span></span>  
  
### <a name="other-locks"></a><span data-ttu-id="255b1-153">Altri blocchi</span><span class="sxs-lookup"><span data-stu-id="255b1-153">Other Locks</span></span>  
 <span data-ttu-id="255b1-154">Non è necessario che i blocchi siano esclusivi.</span><span class="sxs-lookup"><span data-stu-id="255b1-154">Locks need not be exclusive.</span></span> <span data-ttu-id="255b1-155">Spesso è utile consentire l'accesso simultaneo a una risorsa a un numero limitato di thread.</span><span class="sxs-lookup"><span data-stu-id="255b1-155">It is often useful to allow a limited number of threads concurrent access to a resource.</span></span> <span data-ttu-id="255b1-156">I semafori e i blocchi in lettura/scrittura sono progettati per controllare questo tipo di accesso alle risorse in pool.</span><span class="sxs-lookup"><span data-stu-id="255b1-156">Semaphores and reader-writer locks are designed to control this kind of pooled resource access.</span></span>  
  
#### <a name="readerwriterlock-class"></a><span data-ttu-id="255b1-157">Classe ReaderWriterLock</span><span class="sxs-lookup"><span data-stu-id="255b1-157">ReaderWriterLock Class</span></span>  
 <span data-ttu-id="255b1-158">La classe <xref:System.Threading.ReaderWriterLockSlim> viene usata quando un thread in grado di modificare i dati (writer) deve avere un accesso esclusivo a una risorsa.</span><span class="sxs-lookup"><span data-stu-id="255b1-158">The <xref:System.Threading.ReaderWriterLockSlim> class addresses the case where a thread that changes data, the writer, must have exclusive access to a resource.</span></span> <span data-ttu-id="255b1-159">Quando il writer non è arrivo, l'accesso alla risorsa può essere eseguito da un qualsiasi numero di lettori (ad esempio, chiamando il metodo <xref:System.Threading.ReaderWriterLockSlim.EnterReadLock%2A>).</span><span class="sxs-lookup"><span data-stu-id="255b1-159">When the writer is not active, any number of readers can access the resource (for example, by calling the <xref:System.Threading.ReaderWriterLockSlim.EnterReadLock%2A> method).</span></span> <span data-ttu-id="255b1-160">Quando un thread richiede l'accesso esclusivo, ad esempio chiamando il metodo <xref:System.Threading.ReaderWriterLockSlim.EnterWriteLock%2A>, le richieste del lettore successive vengono bloccate finché tutti i lettori esistenti non escono dal blocco e il writer non è entrato e uscito dal blocco.</span><span class="sxs-lookup"><span data-stu-id="255b1-160">When a thread requests exclusive access, (for example, by calling the <xref:System.Threading.ReaderWriterLockSlim.EnterWriteLock%2A> method), subsequent reader requests block until all existing readers have exited the lock, and the writer has entered and exited the lock.</span></span>  
  
 <span data-ttu-id="255b1-161"><xref:System.Threading.ReaderWriterLockSlim> presenta affinità di thread.</span><span class="sxs-lookup"><span data-stu-id="255b1-161"><xref:System.Threading.ReaderWriterLockSlim> has thread affinity.</span></span>  
  
 <span data-ttu-id="255b1-162">Per una panoramica concettuale, vedere [Blocchi in lettura/scrittura](../../../docs/standard/threading/reader-writer-locks.md).</span><span class="sxs-lookup"><span data-stu-id="255b1-162">For a conceptual overview, see [Reader-Writer Locks](../../../docs/standard/threading/reader-writer-locks.md).</span></span>  
  
#### <a name="semaphore-class"></a><span data-ttu-id="255b1-163">Semaphore (classe)</span><span class="sxs-lookup"><span data-stu-id="255b1-163">Semaphore Class</span></span>  
 <span data-ttu-id="255b1-164">La classe <xref:System.Threading.Semaphore> consente a un numero di thread specificato di accedere a una risorsa.</span><span class="sxs-lookup"><span data-stu-id="255b1-164">The <xref:System.Threading.Semaphore> class allows a specified number of threads to access a resource.</span></span> <span data-ttu-id="255b1-165">Eventuali altri thread che richiedono la risorsa vengono bloccati finché un thread rilascia il semaforo.</span><span class="sxs-lookup"><span data-stu-id="255b1-165">Additional threads requesting the resource block until a thread releases the semaphore.</span></span>  
  
 <span data-ttu-id="255b1-166">Analogamente alla classe <xref:System.Threading.Mutex>, <xref:System.Threading.Semaphore> deriva da <xref:System.Threading.WaitHandle>.</span><span class="sxs-lookup"><span data-stu-id="255b1-166">Like the <xref:System.Threading.Mutex> class, <xref:System.Threading.Semaphore> derives from <xref:System.Threading.WaitHandle>.</span></span> <span data-ttu-id="255b1-167">Analogamente a <xref:System.Threading.Mutex>, inoltre, <xref:System.Threading.Semaphore> può essere sia locale che globale.</span><span class="sxs-lookup"><span data-stu-id="255b1-167">Also like <xref:System.Threading.Mutex>, a <xref:System.Threading.Semaphore> can be either local or global.</span></span> <span data-ttu-id="255b1-168">Può essere usato tra i limiti dei domini applicazioni.</span><span class="sxs-lookup"><span data-stu-id="255b1-168">It can be used across application domain boundaries.</span></span>  
  
 <span data-ttu-id="255b1-169">A differenza di <xref:System.Threading.Monitor>, <xref:System.Threading.Mutex> e <xref:System.Threading.ReaderWriterLock>, <xref:System.Threading.Semaphore> non presenta affinità di thread.</span><span class="sxs-lookup"><span data-stu-id="255b1-169">Unlike <xref:System.Threading.Monitor>, <xref:System.Threading.Mutex>, and <xref:System.Threading.ReaderWriterLock>, <xref:System.Threading.Semaphore> does not have thread affinity.</span></span> <span data-ttu-id="255b1-170">Ciò significa che può essere usato in scenari in cui un thread acquisisce il semaforo e un altro lo rilascia.</span><span class="sxs-lookup"><span data-stu-id="255b1-170">This means it can be used in scenarios where one thread acquires the semaphore and another releases it.</span></span>  
  
 <span data-ttu-id="255b1-171">Per una panoramica concettuale, vedere [Semaphore e SemaphoreSlim](../../../docs/standard/threading/semaphore-and-semaphoreslim.md).</span><span class="sxs-lookup"><span data-stu-id="255b1-171">For a conceptual overview, see [Semaphore and SemaphoreSlim](../../../docs/standard/threading/semaphore-and-semaphoreslim.md).</span></span>  
  
 <span data-ttu-id="255b1-172"><xref:System.Threading.SemaphoreSlim?displayProperty=nameWithType> è un semaforo leggero per la sincronizzazione all'interno di un unico processo.</span><span class="sxs-lookup"><span data-stu-id="255b1-172"><xref:System.Threading.SemaphoreSlim?displayProperty=nameWithType> is a lightweight semaphore for synchronization within a single process boundary.</span></span>  
  
 [<span data-ttu-id="255b1-173">Torna all'inizio</span><span class="sxs-lookup"><span data-stu-id="255b1-173">Back to top</span></span>](#top)  
  
<a name="signaling"></a>   
## <a name="signaling"></a><span data-ttu-id="255b1-174">Signaling</span><span class="sxs-lookup"><span data-stu-id="255b1-174">Signaling</span></span>  
 <span data-ttu-id="255b1-175">Il modo più semplice per attendere un segnale da un altro thread consiste nel chiamare il metodo <xref:System.Threading.Thread.Join%2A> che si blocca fino al completamento dell'altro thread.</span><span class="sxs-lookup"><span data-stu-id="255b1-175">The simplest way to wait for a signal from another thread is to call the <xref:System.Threading.Thread.Join%2A> method, which blocks until the other thread completes.</span></span> <span data-ttu-id="255b1-176"><xref:System.Threading.Thread.Join%2A> ha due overload che consentono al thread bloccato di interrompere l'attesa dopo che è trascorso un intervallo di tempo specificato.</span><span class="sxs-lookup"><span data-stu-id="255b1-176"><xref:System.Threading.Thread.Join%2A> has two overloads that allow the blocked thread to break out of the wait after a specified interval has elapsed.</span></span>  
  
 <span data-ttu-id="255b1-177">Gli handle di attesa forniscono un set di funzionalità di attesa e di segnalazione più completo.</span><span class="sxs-lookup"><span data-stu-id="255b1-177">Wait handles provide a much richer set of waiting and signaling capabilities.</span></span>  
  
### <a name="wait-handles"></a><span data-ttu-id="255b1-178">Handle di attesa</span><span class="sxs-lookup"><span data-stu-id="255b1-178">Wait Handles</span></span>  
 <span data-ttu-id="255b1-179">Gli handle di attesa derivano dalla classe <xref:System.Threading.WaitHandle>, che a sua volta deriva da <xref:System.MarshalByRefObject>.</span><span class="sxs-lookup"><span data-stu-id="255b1-179">Wait handles derive from the <xref:System.Threading.WaitHandle> class, which in turn derives from <xref:System.MarshalByRefObject>.</span></span> <span data-ttu-id="255b1-180">Quindi, gli handle di attesa possono essere usati per sincronizzare le attività dei thread tra i limiti dei domini applicazioni.</span><span class="sxs-lookup"><span data-stu-id="255b1-180">Thus, wait handles can be used to synchronize the activities of threads across application domain boundaries.</span></span>  
  
 <span data-ttu-id="255b1-181">I thread si bloccano negli handle di attesa chiamando il metodo di istanza <xref:System.Threading.WaitHandle.WaitOne%2A> o uno dei metodi statici <xref:System.Threading.WaitHandle.WaitAll%2A>, <xref:System.Threading.WaitHandle.WaitAny%2A> o <xref:System.Threading.WaitHandle.SignalAndWait%2A>.</span><span class="sxs-lookup"><span data-stu-id="255b1-181">Threads block on wait handles by calling the instance method <xref:System.Threading.WaitHandle.WaitOne%2A> or one of the static methods <xref:System.Threading.WaitHandle.WaitAll%2A>, <xref:System.Threading.WaitHandle.WaitAny%2A>, or <xref:System.Threading.WaitHandle.SignalAndWait%2A>.</span></span> <span data-ttu-id="255b1-182">Le modalità di rilascio dipendono dal metodo chiamato e dal tipo di handle di attesa.</span><span class="sxs-lookup"><span data-stu-id="255b1-182">How they are released depends on which method was called, and on the kind of wait handles.</span></span>  
  
 <span data-ttu-id="255b1-183">Per una panoramica concettuale, vedere [Handle di attesa](http://msdn.microsoft.com/library/48d10b6f-5fd7-407c-86ab-0179aef72489).</span><span class="sxs-lookup"><span data-stu-id="255b1-183">For a conceptual overview, see [Wait Handles](http://msdn.microsoft.com/library/48d10b6f-5fd7-407c-86ab-0179aef72489).</span></span>  
  
#### <a name="event-wait-handles"></a><span data-ttu-id="255b1-184">Handle di attesa evento</span><span class="sxs-lookup"><span data-stu-id="255b1-184">Event Wait Handles</span></span>  
 <span data-ttu-id="255b1-185">Gli handle di attesa evento includono la classe <xref:System.Threading.EventWaitHandle> e le classi derivate, <xref:System.Threading.AutoResetEvent> e <xref:System.Threading.ManualResetEvent>.</span><span class="sxs-lookup"><span data-stu-id="255b1-185">Event wait handles include the <xref:System.Threading.EventWaitHandle> class and its derived classes, <xref:System.Threading.AutoResetEvent> and <xref:System.Threading.ManualResetEvent>.</span></span> <span data-ttu-id="255b1-186">I thread vengono rilasciati da un handle di attesa evento quando questo handle viene segnalato chiamando il metodo <xref:System.Threading.EventWaitHandle.Set%2A> o usando il metodo <xref:System.Threading.WaitHandle.SignalAndWait%2A>.</span><span class="sxs-lookup"><span data-stu-id="255b1-186">Threads are released from an event wait handle when the event wait handle is signaled by calling its <xref:System.Threading.EventWaitHandle.Set%2A> method or by using the <xref:System.Threading.WaitHandle.SignalAndWait%2A> method.</span></span>  
  
 <span data-ttu-id="255b1-187">L'handle di attesa evento li reimposta automaticamente, come un tornello che consente il passaggio di solo un thread ogni volta che viene segnalato, oppure è necessario reimpostarli manualmente, come un cancello che viene chiuso fino a segnalazione e resta aperto finché qualcuno non lo chiude.</span><span class="sxs-lookup"><span data-stu-id="255b1-187">Event wait handles either reset themselves automatically, like a turnstile that allows only one thread through each time it is signaled, or must be reset manually, like a gate that is closed until signaled and then open until someone closes it.</span></span> <span data-ttu-id="255b1-188">Come indicato dai nomi, <xref:System.Threading.AutoResetEvent> e <xref:System.Threading.ManualResetEvent> rappresentano la prima e la seconda opzione, rispettivamente.</span><span class="sxs-lookup"><span data-stu-id="255b1-188">As their names imply, <xref:System.Threading.AutoResetEvent> and <xref:System.Threading.ManualResetEvent> represent the former and latter, respectively.</span></span> <span data-ttu-id="255b1-189"><xref:System.Threading.ManualResetEventSlim?displayProperty=nameWithType> è un evento leggero per la sincronizzazione all'interno di un unico processo.</span><span class="sxs-lookup"><span data-stu-id="255b1-189"><xref:System.Threading.ManualResetEventSlim?displayProperty=nameWithType> is a lightweight event for synchronization within a single process boundary.</span></span>  
  
 <span data-ttu-id="255b1-190"><xref:System.Threading.EventWaitHandle> può rappresentare qualsiasi tipo di evento e può essere locale o globale.</span><span class="sxs-lookup"><span data-stu-id="255b1-190">An <xref:System.Threading.EventWaitHandle> can represent either type of event, and can be either local or global.</span></span> <span data-ttu-id="255b1-191">Le classi derivate <xref:System.Threading.AutoResetEvent> e <xref:System.Threading.ManualResetEvent> sono sempre locali.</span><span class="sxs-lookup"><span data-stu-id="255b1-191">The derived classes <xref:System.Threading.AutoResetEvent> and <xref:System.Threading.ManualResetEvent> are always local.</span></span>  
  
 <span data-ttu-id="255b1-192">Gli handle di attesa evento non presentano affinità di thread.</span><span class="sxs-lookup"><span data-stu-id="255b1-192">Event wait handles do not have thread affinity.</span></span> <span data-ttu-id="255b1-193">Qualsiasi thread può segnalare un handle di attesa evento.</span><span class="sxs-lookup"><span data-stu-id="255b1-193">Any thread can signal an event wait handle.</span></span>  
  
 <span data-ttu-id="255b1-194">Per una panoramica concettuale, vedere [EventWaitHandle, AutoResetEvent, CountdownEvent, ManualResetEvent](../../../docs/standard/threading/eventwaithandle-autoresetevent-countdownevent-manualresetevent.md).</span><span class="sxs-lookup"><span data-stu-id="255b1-194">For a conceptual overview, see [EventWaitHandle, AutoResetEvent, CountdownEvent, ManualResetEvent](../../../docs/standard/threading/eventwaithandle-autoresetevent-countdownevent-manualresetevent.md).</span></span>  
  
#### <a name="mutex-and-semaphore-classes"></a><span data-ttu-id="255b1-195">Classi Mutex e Semaphore</span><span class="sxs-lookup"><span data-stu-id="255b1-195">Mutex and Semaphore Classes</span></span>  
 <span data-ttu-id="255b1-196">Poiché le classi <xref:System.Threading.Mutex> e <xref:System.Threading.Semaphore> derivano da <xref:System.Threading.WaitHandle>, possono essere usate con i metodi statici di <xref:System.Threading.WaitHandle>.</span><span class="sxs-lookup"><span data-stu-id="255b1-196">Because the <xref:System.Threading.Mutex> and <xref:System.Threading.Semaphore> classes derive from <xref:System.Threading.WaitHandle>, they can be used with the static methods of <xref:System.Threading.WaitHandle>.</span></span> <span data-ttu-id="255b1-197">Ad esempio, un thread può usare il metodo <xref:System.Threading.WaitHandle.WaitAll%2A> per attendere finché tutte e tre le condizioni seguenti non risultano vere: <xref:System.Threading.EventWaitHandle> viene segnalato e <xref:System.Threading.Mutex> e <xref:System.Threading.Semaphore> vengono rilasciati.</span><span class="sxs-lookup"><span data-stu-id="255b1-197">For example, a thread can use the <xref:System.Threading.WaitHandle.WaitAll%2A> method to wait until all three of the following are true: an <xref:System.Threading.EventWaitHandle> is signaled, a <xref:System.Threading.Mutex> is released, and a <xref:System.Threading.Semaphore> is released.</span></span> <span data-ttu-id="255b1-198">Analogamente, un thread può usare il metodo <xref:System.Threading.WaitHandle.WaitAny%2A> per attendere finché non si verifica una delle condizioni.</span><span class="sxs-lookup"><span data-stu-id="255b1-198">Similarly, a thread can use the <xref:System.Threading.WaitHandle.WaitAny%2A> method to wait until any one of those conditions is true.</span></span>  
  
 <span data-ttu-id="255b1-199">Per <xref:System.Threading.Mutex> o <xref:System.Threading.Semaphore>, la segnalazione equivale al rilascio.</span><span class="sxs-lookup"><span data-stu-id="255b1-199">For a <xref:System.Threading.Mutex> or a <xref:System.Threading.Semaphore>, being signaled means being released.</span></span> <span data-ttu-id="255b1-200">Se uno dei due tipi viene usato come primo argomento del metodo <xref:System.Threading.WaitHandle.SignalAndWait%2A>, viene rilasciato.</span><span class="sxs-lookup"><span data-stu-id="255b1-200">If either type is used as the first argument of the <xref:System.Threading.WaitHandle.SignalAndWait%2A> method, it is released.</span></span> <span data-ttu-id="255b1-201">Nel caso di <xref:System.Threading.Mutex>, che presenta affinità di thread, viene generata un'eccezione se il thread chiamante non è proprietario del mutex.</span><span class="sxs-lookup"><span data-stu-id="255b1-201">In the case of a <xref:System.Threading.Mutex>, which has thread affinity, an exception is thrown if the calling thread does not own the mutex.</span></span> <span data-ttu-id="255b1-202">Come indicato in precedenza, i semafori non presentano affinità di thread.</span><span class="sxs-lookup"><span data-stu-id="255b1-202">As noted previously, semaphores do not have thread affinity.</span></span>  
  
#### <a name="barrier"></a><span data-ttu-id="255b1-203">Barriera</span><span class="sxs-lookup"><span data-stu-id="255b1-203">Barrier</span></span>  
 <span data-ttu-id="255b1-204">La classe <xref:System.Threading.Barrier> fornisce un modo per sincronizzare ciclicamente più thread in modo che tutti si blocchino allo stesso punto e attendano il completamento degli altri thread.</span><span class="sxs-lookup"><span data-stu-id="255b1-204">The <xref:System.Threading.Barrier> class provides a way to cyclically synchronize multiple threads so that they all block at the same point and wait for all other threads to complete.</span></span> <span data-ttu-id="255b1-205">Una barriera è utile quando uno o più thread richiede i risultati di un altro thread prima di continuare con la fase successiva dell'algoritmo.</span><span class="sxs-lookup"><span data-stu-id="255b1-205">A barrier is useful when one or more threads require the results of another thread before continuing to the next phase of an algorithm.</span></span> <span data-ttu-id="255b1-206">Per altre informazioni, vedere [Barriera](../../../docs/standard/threading/barrier.md).</span><span class="sxs-lookup"><span data-stu-id="255b1-206">For more information, see [Barrier](../../../docs/standard/threading/barrier.md).</span></span>  
  
 [<span data-ttu-id="255b1-207">Torna all'inizio</span><span class="sxs-lookup"><span data-stu-id="255b1-207">Back to top</span></span>](#top)  
  
<a name="lightweight_synchronization_types"></a>   
## <a name="lightweight-synchronization-types"></a><span data-ttu-id="255b1-208">Tipi di sincronizzazione leggera</span><span class="sxs-lookup"><span data-stu-id="255b1-208">Lightweight Synchronization Types</span></span>  
 <span data-ttu-id="255b1-209">A partire da [!INCLUDE[net_v40_short](../../../includes/net-v40-short-md.md)], è possibile usare le primitive di sincronizzazione che forniscono prestazioni ottimali perché, quando è possibile, evitano la dipendenza da oggetti kernel Win32, come gli handle di attesa, dispendiosa in termini di tempo.</span><span class="sxs-lookup"><span data-stu-id="255b1-209">Starting with the [!INCLUDE[net_v40_short](../../../includes/net-v40-short-md.md)], you can use synchronization primitives that provide fast performance by avoiding expensive reliance on Win32 kernel objects such as wait handles whenever possible.</span></span> <span data-ttu-id="255b1-210">In generale, è opportuno usare questi tipi quando i tempi di attesa sono brevi e solo quando i tipi di sincronizzazione originali sono stati testati e sono risultati inefficaci.</span><span class="sxs-lookup"><span data-stu-id="255b1-210">In general, you should use these types when wait times are short and only when the original synchronization types have been tried and found to be unsatisfactory.</span></span> <span data-ttu-id="255b1-211">I tipi leggeri non possono essere usati in scenari che richiedono la comunicazione tra processi.</span><span class="sxs-lookup"><span data-stu-id="255b1-211">The lightweight types cannot be used in scenarios that require cross-process communication.</span></span>  
  
-   <span data-ttu-id="255b1-212"><xref:System.Threading.SemaphoreSlim?displayProperty=nameWithType> è una versione leggera di <xref:System.Threading.Semaphore?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="255b1-212"><xref:System.Threading.SemaphoreSlim?displayProperty=nameWithType> is a lightweight version of <xref:System.Threading.Semaphore?displayProperty=nameWithType>.</span></span>  
  
-   <span data-ttu-id="255b1-213"><xref:System.Threading.ManualResetEventSlim?displayProperty=nameWithType> è una versione leggera di <xref:System.Threading.ManualResetEvent?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="255b1-213"><xref:System.Threading.ManualResetEventSlim?displayProperty=nameWithType> is a lightweight version of <xref:System.Threading.ManualResetEvent?displayProperty=nameWithType>.</span></span>  
  
-   <span data-ttu-id="255b1-214"><xref:System.Threading.CountdownEvent?displayProperty=nameWithType> rappresenta l'evento che diventa segnalato quando il relativo conteggio è zero.</span><span class="sxs-lookup"><span data-stu-id="255b1-214"><xref:System.Threading.CountdownEvent?displayProperty=nameWithType> represents an event that becomes signaled when its count is zero.</span></span>  
  
-   <span data-ttu-id="255b1-215"><xref:System.Threading.Barrier?displayProperty=nameWithType> abilita la sincronizzazione reciproca di più thread senza richiedere il controllo da parte di un thread master.</span><span class="sxs-lookup"><span data-stu-id="255b1-215"><xref:System.Threading.Barrier?displayProperty=nameWithType> enables multiple threads to synchronize with one another without requiring control by a master thread.</span></span> <span data-ttu-id="255b1-216">Una barriera evita che i singoli thread proseguano le operazioni finché tutti i thread non hanno raggiunto un punto specificato.</span><span class="sxs-lookup"><span data-stu-id="255b1-216">A barrier prevents each thread from continuing until all threads have reached a specified point.</span></span>  
  
 [<span data-ttu-id="255b1-217">Torna all'inizio</span><span class="sxs-lookup"><span data-stu-id="255b1-217">Back to top</span></span>](#top)  
  
<a name="spinwait"></a>   
## <a name="spinwait"></a><span data-ttu-id="255b1-218">SpinWait</span><span class="sxs-lookup"><span data-stu-id="255b1-218">SpinWait</span></span>  
 <span data-ttu-id="255b1-219">A partire dal [!INCLUDE[net_v40_short](../../../includes/net-v40-short-md.md)], è possibile utilizzare il <xref:System.Threading.SpinWait?displayProperty=nameWithType> struttura quando un thread deve attendere un evento venga segnalato o una condizione da soddisfare, ma quando il tempo di attesa effettivo deve essere inferiore al tempo di attesa richiesto da un handle di attesa o da otherwi se bloccare il thread corrente.</span><span class="sxs-lookup"><span data-stu-id="255b1-219">Starting with the [!INCLUDE[net_v40_short](../../../includes/net-v40-short-md.md)], you can use the <xref:System.Threading.SpinWait?displayProperty=nameWithType> structure when a thread has to wait for an event to be signaled or a condition to be met, but when the actual wait time is expected to be less than the waiting time required by using a wait handle or by otherwise blocking the current thread.</span></span> <span data-ttu-id="255b1-220">Usando <xref:System.Threading.SpinWait>, è possibile specificare un breve intervallo di tempo di rotazione durante l'attesa e quindi produrre un risultato (ad esempio, mediante l'attesa o la sospensione) solo se la condizione non viene soddisfatta nel tempo specificato.</span><span class="sxs-lookup"><span data-stu-id="255b1-220">By using <xref:System.Threading.SpinWait>, you can specify a short period of time to spin while waiting, and then yield (for example, by waiting or sleeping) only if the condition was not met in the specified time.</span></span>  
  
 [<span data-ttu-id="255b1-221">Torna all'inizio</span><span class="sxs-lookup"><span data-stu-id="255b1-221">Back to top</span></span>](#top)  
  
<a name="interlocked_operations"></a>   
## <a name="interlocked-operations"></a><span data-ttu-id="255b1-222">Operazioni interlocked</span><span class="sxs-lookup"><span data-stu-id="255b1-222">Interlocked Operations</span></span>  
 <span data-ttu-id="255b1-223">Le operazioni interlocked sono operazioni atomiche semplici eseguite in un percorso di memoria dai metodi statici della classe <xref:System.Threading.Interlocked>.</span><span class="sxs-lookup"><span data-stu-id="255b1-223">Interlocked operations are simple atomic operations performed on a memory location by static methods of the <xref:System.Threading.Interlocked> class.</span></span> <span data-ttu-id="255b1-224">Queste operazioni atomiche includono operazioni di aggiunta, incremento e decremento, scambio, scambio condizionale in base a un confronto e lettura per i valori a 64 bit in piattaforme a 32 bit.</span><span class="sxs-lookup"><span data-stu-id="255b1-224">Those atomic operations include addition, increment and decrement, exchange, conditional exchange depending on a comparison, and read operations for 64-bit values on 32-bit platforms.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="255b1-225">La garanzia di atomicità è limitata alle singole operazioni. Se è necessario eseguire più operazioni unitariamente, è necessario usare un meccanismo di sincronizzazione con granularità più grossolana.</span><span class="sxs-lookup"><span data-stu-id="255b1-225">The guarantee of atomicity is limited to individual operations; when multiple operations must be performed as a unit, a more coarse-grained synchronization mechanism must be used.</span></span>  
  
 <span data-ttu-id="255b1-226">Sebbene nessuna di queste operazioni corrisponda a blocchi o segnali, è possibile usarle per costruire blocchi e segnali.</span><span class="sxs-lookup"><span data-stu-id="255b1-226">Although none of these operations are locks or signals, they can be used to construct locks and signals.</span></span> <span data-ttu-id="255b1-227">Poiché sono native nel sistema operativo Windows, le operazioni interlocked sono estremamente veloci.</span><span class="sxs-lookup"><span data-stu-id="255b1-227">Because they are native to the Windows operating system, interlocked operations are extremely fast.</span></span>  
  
 <span data-ttu-id="255b1-228">Le operazioni interlocked possono essere usate con le garanzie di memoria volatile per scrivere applicazioni con un'efficace concorrenza senza blocchi.</span><span class="sxs-lookup"><span data-stu-id="255b1-228">Interlocked operations can be used with volatile memory guarantees to write applications that exhibit powerful non-blocking concurrency.</span></span> <span data-ttu-id="255b1-229">Tuttavia, richiedono programmazione sofisticata di basso livello, quindi per la maggior parte degli obiettivi la scelta migliore restano i blocchi semplici.</span><span class="sxs-lookup"><span data-stu-id="255b1-229">However, they require sophisticated, low-level programming, so for most purposes, simple locks are a better choice.</span></span>  
  
 <span data-ttu-id="255b1-230">Per una panoramica concettuale, vedere [Operazioni Interlocked](../../../docs/standard/threading/interlocked-operations.md).</span><span class="sxs-lookup"><span data-stu-id="255b1-230">For a conceptual overview, see [Interlocked Operations](../../../docs/standard/threading/interlocked-operations.md).</span></span>  
  
## <a name="see-also"></a><span data-ttu-id="255b1-231">Vedere anche</span><span class="sxs-lookup"><span data-stu-id="255b1-231">See Also</span></span>  
 [<span data-ttu-id="255b1-232">Sincronizzazione dei dati per il multithreading</span><span class="sxs-lookup"><span data-stu-id="255b1-232">Synchronizing Data for Multithreading</span></span>](../../../docs/standard/threading/synchronizing-data-for-multithreading.md)  
 [<span data-ttu-id="255b1-233">Monitoraggi</span><span class="sxs-lookup"><span data-stu-id="255b1-233">Monitors</span></span>](http://msdn.microsoft.com/library/33fe4aef-b44b-42fd-9e72-c908e39e75db)  
 [<span data-ttu-id="255b1-234">Mutex</span><span class="sxs-lookup"><span data-stu-id="255b1-234">Mutexes</span></span>](../../../docs/standard/threading/mutexes.md)  
 [<span data-ttu-id="255b1-235">Semaphore e SemaphoreSlim</span><span class="sxs-lookup"><span data-stu-id="255b1-235">Semaphore and SemaphoreSlim</span></span>](../../../docs/standard/threading/semaphore-and-semaphoreslim.md)  
 [<span data-ttu-id="255b1-236">EventWaitHandle, AutoResetEvent, CountdownEvent, ManualResetEvent</span><span class="sxs-lookup"><span data-stu-id="255b1-236">EventWaitHandle, AutoResetEvent, CountdownEvent, ManualResetEvent</span></span>](../../../docs/standard/threading/eventwaithandle-autoresetevent-countdownevent-manualresetevent.md)  
 [<span data-ttu-id="255b1-237">Handle di attesa</span><span class="sxs-lookup"><span data-stu-id="255b1-237">Wait Handles</span></span>](http://msdn.microsoft.com/library/48d10b6f-5fd7-407c-86ab-0179aef72489)  
 [<span data-ttu-id="255b1-238">Operazioni interlocked</span><span class="sxs-lookup"><span data-stu-id="255b1-238">Interlocked Operations</span></span>](../../../docs/standard/threading/interlocked-operations.md)  
 [<span data-ttu-id="255b1-239">Blocchi in lettura/scrittura</span><span class="sxs-lookup"><span data-stu-id="255b1-239">Reader-Writer Locks</span></span>](../../../docs/standard/threading/reader-writer-locks.md)  
 [<span data-ttu-id="255b1-240">Barrier</span><span class="sxs-lookup"><span data-stu-id="255b1-240">Barrier</span></span>](../../../docs/standard/threading/barrier.md)  
 [<span data-ttu-id="255b1-241">SpinWait</span><span class="sxs-lookup"><span data-stu-id="255b1-241">SpinWait</span></span>](../../../docs/standard/threading/spinwait.md)  
 [<span data-ttu-id="255b1-242">SpinLock</span><span class="sxs-lookup"><span data-stu-id="255b1-242">SpinLock</span></span>](../../../docs/standard/threading/spinlock.md)
