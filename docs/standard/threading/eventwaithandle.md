---
title: EventWaitHandle
ms.custom: 
ms.date: 03/30/2017
ms.prod: .net
ms.reviewer: 
ms.suite: 
ms.technology: dotnet-standard
ms.tgt_pltfrm: 
ms.topic: article
helpviewer_keywords:
- threading [.NET Framework], EventWaitHandle class
- EventWaitHandle class
- event wait handles [.NET Framework]
- threading [.NET Framework], cross-process synchronization
ms.assetid: 11ee0b38-d663-4617-b793-35eb6c64e9fc
caps.latest.revision: "9"
author: rpetrusha
ms.author: ronpet
manager: wpickett
ms.openlocfilehash: 1bd248133bd95ff05246eb36a8e250247fd7ed61
ms.sourcegitcommit: 4f3fef493080a43e70e951223894768d36ce430a
ms.translationtype: HT
ms.contentlocale: it-IT
ms.lasthandoff: 11/21/2017
---
# <a name="eventwaithandle"></a><span data-ttu-id="273ff-102">EventWaitHandle</span><span class="sxs-lookup"><span data-stu-id="273ff-102">EventWaitHandle</span></span>
<span data-ttu-id="273ff-103">La <xref:System.Threading.EventWaitHandle> classe consente ai thread di comunicare tra loro tramite segnalazioni e attendendo segnali.</span><span class="sxs-lookup"><span data-stu-id="273ff-103">The <xref:System.Threading.EventWaitHandle> class allows threads to communicate with each other by signaling and by waiting for signals.</span></span> <span data-ttu-id="273ff-104">Handle di attesa di eventi (nota anche semplicemente come eventi) sono handle di attesa che possono essere segnalati per rilasciare una o più thread in attesa.</span><span class="sxs-lookup"><span data-stu-id="273ff-104">Event wait handles (also referred to simply as events) are wait handles that can be signaled in order to release one or more waiting threads.</span></span> <span data-ttu-id="273ff-105">Dopo essere stato segnalato, un handle di attesa dell'evento viene reimpostato automaticamente o manualmente.</span><span class="sxs-lookup"><span data-stu-id="273ff-105">After it is signaled, an event wait handle is reset either manually or automatically.</span></span> <span data-ttu-id="273ff-106">La <xref:System.Threading.EventWaitHandle> classe può rappresentare un handle a attesa evento locale (evento locale) o handle (denominato evento o sistema, visibili a tutti i processi) di attesa di un evento di sistema denominato.</span><span class="sxs-lookup"><span data-stu-id="273ff-106">The <xref:System.Threading.EventWaitHandle> class can represent either a local event wait handle (local event) or a named system event wait handle (named event or system event, visible to all processes).</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="273ff-107">Handle di attesa eventi non sono gli eventi in quanto in genere indicata con tale parola in .NET Framework.</span><span class="sxs-lookup"><span data-stu-id="273ff-107">Event wait handles are not events in the sense usually meant by that word in the .NET Framework.</span></span> <span data-ttu-id="273ff-108">Non è coinvolto Nessun delegati o gestori di eventi.</span><span class="sxs-lookup"><span data-stu-id="273ff-108">There are no delegates or event handlers involved.</span></span> <span data-ttu-id="273ff-109">L'evento"word" viene utilizzato per descrivere le poiché essi passato sono stati definiti per come eventi di sistema operativo e l'azione di segnalazione dell'handle di attesa indica al thread in attesa che si è verificato un evento.</span><span class="sxs-lookup"><span data-stu-id="273ff-109">The word "event" is used to describe them because they have traditionally been referred to as operating-system events, and because the act of signaling the wait handle indicates to waiting threads that an event has occurred.</span></span>  
  
 <span data-ttu-id="273ff-110">Entrambi gli handle di attesa dell'evento locale che denominato utilizzano oggetti di sincronizzazione del sistema, che sono protetti da <xref:Microsoft.Win32.SafeHandles.SafeWaitHandle> wrapper per garantire che le risorse vengono rilasciate.</span><span class="sxs-lookup"><span data-stu-id="273ff-110">Both local and named event wait handles use system synchronization objects, which are protected by <xref:Microsoft.Win32.SafeHandles.SafeWaitHandle> wrappers to ensure that the resources are released.</span></span> <span data-ttu-id="273ff-111">È possibile utilizzare il <xref:System.Threading.WaitHandle.Dispose%2A> metodo per liberare le risorse quando è terminato di utilizzare l'oggetto.</span><span class="sxs-lookup"><span data-stu-id="273ff-111">You can use the <xref:System.Threading.WaitHandle.Dispose%2A> method to free the resources immediately when you have finished using the object.</span></span>  
  
## <a name="event-wait-handles-that-reset-automatically"></a><span data-ttu-id="273ff-112">Handle di attesa di eventi di reimpostazione automatica</span><span class="sxs-lookup"><span data-stu-id="273ff-112">Event Wait Handles That Reset Automatically</span></span>  
 <span data-ttu-id="273ff-113">Per creare un evento di reimpostazione automatica specificando <xref:System.Threading.EventResetMode.AutoReset?displayProperty=nameWithType> quando si crea il <xref:System.Threading.EventWaitHandle> oggetto.</span><span class="sxs-lookup"><span data-stu-id="273ff-113">You create an automatic reset event by specifying <xref:System.Threading.EventResetMode.AutoReset?displayProperty=nameWithType> when you create the <xref:System.Threading.EventWaitHandle> object.</span></span> <span data-ttu-id="273ff-114">Come suggerisce il nome, questo evento di sincronizzazione viene reimpostato automaticamente quando viene segnalato, dopo il rilascio di un singolo thread in attesa.</span><span class="sxs-lookup"><span data-stu-id="273ff-114">As its name implies, this synchronization event resets automatically when signaled, after releasing a single waiting thread.</span></span> <span data-ttu-id="273ff-115">Segnalare l'evento chiamando il relativo <xref:System.Threading.EventWaitHandle.Set%2A> metodo.</span><span class="sxs-lookup"><span data-stu-id="273ff-115">Signal the event by calling its <xref:System.Threading.EventWaitHandle.Set%2A> method.</span></span>  
  
 <span data-ttu-id="273ff-116">Eventi di reimpostazione automatica vengono in genere utilizzati per fornire l'accesso esclusivo a una risorsa per un solo thread alla volta.</span><span class="sxs-lookup"><span data-stu-id="273ff-116">Automatic reset events are usually used to provide exclusive access to a resource for a single thread at a time.</span></span> <span data-ttu-id="273ff-117">Un thread richiede la risorsa chiamando il <xref:System.Threading.WaitHandle.WaitOne%2A> metodo.</span><span class="sxs-lookup"><span data-stu-id="273ff-117">A thread requests the resource by calling the <xref:System.Threading.WaitHandle.WaitOne%2A> method.</span></span> <span data-ttu-id="273ff-118">Se nessun altro thread contiene l'handle di attesa, il metodo restituisce `true` e il thread chiamante ha il controllo della risorsa.</span><span class="sxs-lookup"><span data-stu-id="273ff-118">If no other thread is holding the wait handle, the method returns `true` and the calling thread has control of the resource.</span></span>  
  
> [!IMPORTANT]
>  <span data-ttu-id="273ff-119">Come con tutti i meccanismi di sincronizzazione, è necessario assicurarsi che tutti i percorsi del codice in attesa dell'handle di attesa appropriato prima di accedere a una risorsa protetta.</span><span class="sxs-lookup"><span data-stu-id="273ff-119">As with all synchronization mechanisms, you must ensure that all code paths wait on the appropriate wait handle before accessing a protected resource.</span></span> <span data-ttu-id="273ff-120">La sincronizzazione dei thread è cooperativa.</span><span class="sxs-lookup"><span data-stu-id="273ff-120">Thread synchronization is cooperative.</span></span>  
  
 <span data-ttu-id="273ff-121">Se un evento di reimpostazione automatica viene segnalato quando nessun thread è in attesa, rimane segnalato fino un thread in attesa.</span><span class="sxs-lookup"><span data-stu-id="273ff-121">If an automatic reset event is signaled when no threads are waiting, it remains signaled until a thread attempts to wait on it.</span></span> <span data-ttu-id="273ff-122">L'evento rilascia il thread e viene reimpostato immediatamente bloccando i thread successivi.</span><span class="sxs-lookup"><span data-stu-id="273ff-122">The event releases the thread and immediately resets, blocking subsequent threads.</span></span>  
  
## <a name="event-wait-handles-that-reset-manually"></a><span data-ttu-id="273ff-123">Handle di attesa evento reimpostato manualmente</span><span class="sxs-lookup"><span data-stu-id="273ff-123">Event Wait Handles That Reset Manually</span></span>  
 <span data-ttu-id="273ff-124">Per creare un evento di reimpostazione manuale specificando <xref:System.Threading.EventResetMode.ManualReset?displayProperty=nameWithType> quando si crea il <xref:System.Threading.EventWaitHandle> oggetto.</span><span class="sxs-lookup"><span data-stu-id="273ff-124">You create a manual reset event by specifying <xref:System.Threading.EventResetMode.ManualReset?displayProperty=nameWithType> when you create the <xref:System.Threading.EventWaitHandle> object.</span></span> <span data-ttu-id="273ff-125">Come suggerisce il nome, questo evento di sincronizzazione deve essere reimpostato manualmente dopo che è stato segnalato.</span><span class="sxs-lookup"><span data-stu-id="273ff-125">As its name implies, this synchronization event must be reset manually after it has been signaled.</span></span> <span data-ttu-id="273ff-126">Finché viene reimpostata, chiamando il relativo <xref:System.Threading.EventWaitHandle.Reset%2A> (metodo), i thread in attesa dell'handle di evento procedono immediatamente senza bloccare.</span><span class="sxs-lookup"><span data-stu-id="273ff-126">Until it is reset, by calling its <xref:System.Threading.EventWaitHandle.Reset%2A> method, threads that wait on the event handle proceed immediately without blocking.</span></span>  
  
 <span data-ttu-id="273ff-127">Un reimpostazione manuale evento funziona come il controllo di un recinto.</span><span class="sxs-lookup"><span data-stu-id="273ff-127">A manual reset event acts like the gate of a corral.</span></span> <span data-ttu-id="273ff-128">Quando l'evento non viene segnalato, bloccano i thread in attesa su di esso, come cavalli in un recinto.</span><span class="sxs-lookup"><span data-stu-id="273ff-128">When the event is not signaled, threads that wait on it block, like horses in a corral.</span></span> <span data-ttu-id="273ff-129">Quando l'evento viene segnalato, chiamando il relativo <xref:System.Threading.EventWaitHandle.Set%2A> (metodo), tutti i thread in attesa sono disponibili per continuare.</span><span class="sxs-lookup"><span data-stu-id="273ff-129">When the event is signaled, by calling its <xref:System.Threading.EventWaitHandle.Set%2A> method, all waiting threads are free to proceed.</span></span> <span data-ttu-id="273ff-130">L'evento rimane segnalato fino a quando il relativo <xref:System.Threading.EventWaitHandle.Reset%2A> metodo viene chiamato.</span><span class="sxs-lookup"><span data-stu-id="273ff-130">The event remains signaled until its <xref:System.Threading.EventWaitHandle.Reset%2A> method is called.</span></span> <span data-ttu-id="273ff-131">In questo modo l'evento di reimpostazione manuale di una soluzione ideale per contenere i thread che è necessario attendere fino a quando un thread termina un'attività.</span><span class="sxs-lookup"><span data-stu-id="273ff-131">This makes the manual reset event an ideal way to hold up threads that need to wait until one thread finishes a task.</span></span>  
  
 <span data-ttu-id="273ff-132">Ad esempio horse lasciando un recinto, il tempo è per i thread rilasciati per la pianificazione dal sistema operativo e per riprendere l'esecuzione.</span><span class="sxs-lookup"><span data-stu-id="273ff-132">Like horses leaving a corral, it takes time for the released threads to be scheduled by the operating system and to resume execution.</span></span> <span data-ttu-id="273ff-133">Se il <xref:System.Threading.EventWaitHandle.Reset%2A> metodo viene chiamato prima di ripresa dell'esecuzione di tutti i thread, thread rimanenti si bloccano di nuovo.</span><span class="sxs-lookup"><span data-stu-id="273ff-133">If the <xref:System.Threading.EventWaitHandle.Reset%2A> method is called before all the threads have resumed execution, the remaining threads once again block.</span></span> <span data-ttu-id="273ff-134">Quali ripresa di thread e il blocco del thread dipende casuale fattori quali il carico sul sistema, il numero di thread in attesa per l'utilità di pianificazione e così via.</span><span class="sxs-lookup"><span data-stu-id="273ff-134">Which threads resume and which threads block depends on random factors like the load on the system, the number of threads waiting for the scheduler, and so on.</span></span> <span data-ttu-id="273ff-135">Questo non costituisce un problema se il thread che segnala l'evento termina dopo la segnalazione, ovvero il modello di utilizzo più comune.</span><span class="sxs-lookup"><span data-stu-id="273ff-135">This is not a problem if the thread that signals the event ends after signaling, which is the most common usage pattern.</span></span> <span data-ttu-id="273ff-136">Se si desidera il thread che ha segnalato l'evento per avviare una nuova attività dopo che tutti in attesa di ripresa thread, è necessario bloccare fino a quando tutti i thread in attesa ripresa.</span><span class="sxs-lookup"><span data-stu-id="273ff-136">If you want the thread that signaled the event to begin a new task after all the waiting threads have resumed, you must block it until all the waiting threads have resumed.</span></span> <span data-ttu-id="273ff-137">In caso contrario, si dispone di una race condition e il comportamento del codice è imprevedibile.</span><span class="sxs-lookup"><span data-stu-id="273ff-137">Otherwise, you have a race condition, and the behavior of your code is unpredictable.</span></span>  
  
## <a name="features-common-to-automatic-and-manual-events"></a><span data-ttu-id="273ff-138">Funzionalità comuni a eventi automatici e manuali</span><span class="sxs-lookup"><span data-stu-id="273ff-138">Features Common to Automatic and Manual Events</span></span>  
 <span data-ttu-id="273ff-139">In genere, uno o più thread bloccati in un <xref:System.Threading.EventWaitHandle> fino a quando un thread sbloccato chiama il <xref:System.Threading.EventWaitHandle.Set%2A> metodo, che rilascia uno dei thread in attesa (in caso di eventi di reimpostazione automatica) o tutti i parametri (reimpostazione manuale eventi).</span><span class="sxs-lookup"><span data-stu-id="273ff-139">Typically, one or more threads block on an <xref:System.Threading.EventWaitHandle> until an unblocked thread calls the <xref:System.Threading.EventWaitHandle.Set%2A> method, which releases one of the waiting threads (in the case of automatic reset events) or all of them (in the case of manual reset events).</span></span> <span data-ttu-id="273ff-140">Un thread può segnalare un <xref:System.Threading.EventWaitHandle> e quindi bloccare su di esso, come operazione atomica, chiamando il metodo statico <xref:System.Threading.WaitHandle.SignalAndWait%2A?displayProperty=nameWithType> metodo.</span><span class="sxs-lookup"><span data-stu-id="273ff-140">A thread can signal an <xref:System.Threading.EventWaitHandle> and then block on it, as an atomic operation, by calling the static <xref:System.Threading.WaitHandle.SignalAndWait%2A?displayProperty=nameWithType> method.</span></span>  
  
 <span data-ttu-id="273ff-141"><xref:System.Threading.EventWaitHandle>oggetti possono essere utilizzati con il metodo statico <xref:System.Threading.WaitHandle.WaitAll%2A?displayProperty=nameWithType> e <xref:System.Threading.WaitHandle.WaitAny%2A?displayProperty=nameWithType> metodi.</span><span class="sxs-lookup"><span data-stu-id="273ff-141"><xref:System.Threading.EventWaitHandle> objects can be used with the static <xref:System.Threading.WaitHandle.WaitAll%2A?displayProperty=nameWithType> and <xref:System.Threading.WaitHandle.WaitAny%2A?displayProperty=nameWithType> methods.</span></span> <span data-ttu-id="273ff-142">Poiché il <xref:System.Threading.EventWaitHandle> e <xref:System.Threading.Mutex> derivano entrambe da <xref:System.Threading.WaitHandle>, è possibile utilizzare entrambe le classi con questi metodi.</span><span class="sxs-lookup"><span data-stu-id="273ff-142">Because the <xref:System.Threading.EventWaitHandle> and <xref:System.Threading.Mutex> classes both derive from <xref:System.Threading.WaitHandle>, you can use both classes with these methods.</span></span>  
  
### <a name="named-events"></a><span data-ttu-id="273ff-143">Eventi denominati</span><span class="sxs-lookup"><span data-stu-id="273ff-143">Named Events</span></span>  
 <span data-ttu-id="273ff-144">Il sistema operativo Windows consente gli handle di attesa evento dispongano di nomi.</span><span class="sxs-lookup"><span data-stu-id="273ff-144">The Windows operating system allows event wait handles to have names.</span></span> <span data-ttu-id="273ff-145">Un evento denominato è a livello di sistema.</span><span class="sxs-lookup"><span data-stu-id="273ff-145">A named event is system wide.</span></span> <span data-ttu-id="273ff-146">Vale a dire, una volta creato l'evento, è visibile a tutti i thread in tutti i processi.</span><span class="sxs-lookup"><span data-stu-id="273ff-146">That is, once the named event is created, it is visible to all threads in all processes.</span></span> <span data-ttu-id="273ff-147">Di conseguenza, gli eventi denominati consente di sincronizzare le attività di processi e thread.</span><span class="sxs-lookup"><span data-stu-id="273ff-147">Thus, named events can be used to synchronize the activities of processes as well as threads.</span></span>  
  
 <span data-ttu-id="273ff-148">È possibile creare un <xref:System.Threading.EventWaitHandle> oggetto che rappresenta un evento di sistema denominato usando uno dei costruttori che specifica un nome di evento.</span><span class="sxs-lookup"><span data-stu-id="273ff-148">You can create an <xref:System.Threading.EventWaitHandle> object that represents a named system event by using one of the constructors that specifies an event name.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="273ff-149">Poiché gli eventi denominati sono a livello di sistema, è possibile avere più <xref:System.Threading.EventWaitHandle> gli oggetti che rappresentano lo stesso evento denominato.</span><span class="sxs-lookup"><span data-stu-id="273ff-149">Because named events are system wide, it is possible to have multiple <xref:System.Threading.EventWaitHandle> objects that represent the same named event.</span></span> <span data-ttu-id="273ff-150">Ogni volta che si chiama un costruttore, o <xref:System.Threading.EventWaitHandle.OpenExisting%2A> (metodo), un nuovo <xref:System.Threading.EventWaitHandle> viene creato l'oggetto.</span><span class="sxs-lookup"><span data-stu-id="273ff-150">Each time you call a constructor, or the <xref:System.Threading.EventWaitHandle.OpenExisting%2A> method, a new <xref:System.Threading.EventWaitHandle> object is created.</span></span> <span data-ttu-id="273ff-151">Specificando lo stesso nome ripetutamente crea più oggetti che rappresentano lo stesso evento denominato.</span><span class="sxs-lookup"><span data-stu-id="273ff-151">Specifying the same name repeatedly creates multiple objects that represent the same named event.</span></span>  
  
 <span data-ttu-id="273ff-152">È consigliabile prestare attenzione nell'utilizzo degli eventi denominati.</span><span class="sxs-lookup"><span data-stu-id="273ff-152">Caution is advised in using named events.</span></span> <span data-ttu-id="273ff-153">Poiché sono a livello di sistema, un altro processo che utilizza lo stesso nome può bloccare i thread in modo imprevisto.</span><span class="sxs-lookup"><span data-stu-id="273ff-153">Because they are system wide, another process that uses the same name can block your threads unexpectedly.</span></span> <span data-ttu-id="273ff-154">Il malware in esecuzione sullo stesso computer potrebbe sfruttare questa opportunità per un attacco Denial of Service.</span><span class="sxs-lookup"><span data-stu-id="273ff-154">Malicious code executing on the same computer could use this as the basis of a denial-of-service attack.</span></span>  
  
 <span data-ttu-id="273ff-155">Utilizzare la sicurezza del controllo di accesso per proteggere un <xref:System.Threading.EventWaitHandle> oggetto che rappresenta un evento denominato, preferibilmente usando un costruttore che specifica un <xref:System.Security.AccessControl.EventWaitHandleSecurity> oggetto.</span><span class="sxs-lookup"><span data-stu-id="273ff-155">Use access control security to protect an <xref:System.Threading.EventWaitHandle> object that represents a named event, preferably by using a constructor that specifies an <xref:System.Security.AccessControl.EventWaitHandleSecurity> object.</span></span> <span data-ttu-id="273ff-156">È inoltre possibile applicare una sicurezza utilizzando il <xref:System.Threading.EventWaitHandle.SetAccessControl%2A> (metodo), ma in tal modo una finestra di vulnerabilità tra l'ora in cui viene creato l'handle di attesa evento e l'ora è protetto.</span><span class="sxs-lookup"><span data-stu-id="273ff-156">You can also apply access control security using the <xref:System.Threading.EventWaitHandle.SetAccessControl%2A> method, but this leaves a window of vulnerability between the time the event wait handle is created and the time it is protected.</span></span> <span data-ttu-id="273ff-157">Eventi con il controllo di accesso sicurezza impedisce gli attacchi dannosi, ma non risolve il problema dei conflitti di nomi non intenzionali.</span><span class="sxs-lookup"><span data-stu-id="273ff-157">Protecting events with access control security helps prevent malicious attacks, but it does not solve the problem of unintentional name collisions.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="273ff-158">A differenza di <xref:System.Threading.EventWaitHandle> (classe), le classi derivate <xref:System.Threading.AutoResetEvent> e <xref:System.Threading.ManualResetEvent> possa rappresentare solo handle di attesa.</span><span class="sxs-lookup"><span data-stu-id="273ff-158">Unlike the <xref:System.Threading.EventWaitHandle> class, the derived classes <xref:System.Threading.AutoResetEvent> and <xref:System.Threading.ManualResetEvent> can represent only local wait handles.</span></span> <span data-ttu-id="273ff-159">Non possono rappresentare gli eventi di sistema denominato.</span><span class="sxs-lookup"><span data-stu-id="273ff-159">They cannot represent named system events.</span></span>  
  
## <a name="see-also"></a><span data-ttu-id="273ff-160">Vedere anche</span><span class="sxs-lookup"><span data-stu-id="273ff-160">See Also</span></span>  
 <xref:System.Threading.EventWaitHandle>  
 <xref:System.Threading.WaitHandle>  
 <xref:System.Threading.AutoResetEvent>  
 <xref:System.Threading.ManualResetEvent>  
 [<span data-ttu-id="273ff-161">EventWaitHandle, AutoResetEvent, CountdownEvent, ManualResetEvent</span><span class="sxs-lookup"><span data-stu-id="273ff-161">EventWaitHandle, AutoResetEvent, CountdownEvent, ManualResetEvent</span></span>](../../../docs/standard/threading/eventwaithandle-autoresetevent-countdownevent-manualresetevent.md)
