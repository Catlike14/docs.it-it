---
title: Eventi del dominio. Progettazione e implementazione
description: Architettura di Microservizi .NET per le applicazioni nei contenitori .NET | Implementazione, progettazione e gli eventi di dominio
keywords: Docker, microservizi, ASP.NET, contenitore
author: CESARDELATORRE
ms.author: wiwagn
ms.date: 05/26/2017
ms.prod: .net-core
ms.technology: dotnet-docker
ms.topic: article
ms.openlocfilehash: 2d98b302be4ee72d8225526944fc3e41cbadcb5f
ms.sourcegitcommit: bd1ef61f4bb794b25383d3d72e71041a5ced172e
ms.translationtype: HT
ms.contentlocale: it-IT
ms.lasthandoff: 10/18/2017
---
# <a name="domain-events-design-and-implementation"></a><span data-ttu-id="9974f-105">Eventi del dominio: progettazione e implementazione</span><span class="sxs-lookup"><span data-stu-id="9974f-105">Domain events: design and implementation</span></span>

<span data-ttu-id="9974f-106">Utilizzare gli eventi di dominio per implementare in modo esplicito gli effetti collaterali delle modifiche all'interno del dominio.</span><span class="sxs-lookup"><span data-stu-id="9974f-106">Use domain events to explicitly implement side effects of changes within your domain.</span></span> <span data-ttu-id="9974f-107">In altre parole e utilizzando la terminologia DDD, utilizzare gli eventi di dominio per implementare in modo esplicito gli effetti collaterali tra più funzioni di aggregazione.</span><span class="sxs-lookup"><span data-stu-id="9974f-107">In other words, and using DDD terminology, use domain events to explicitly implement side effects across multiple aggregates.</span></span> <span data-ttu-id="9974f-108">Facoltativamente, per una migliore scalabilità e minore impatto in blocchi di database, utilizzare la coerenza eventuale tra funzioni di aggregazione all'interno dello stesso dominio.</span><span class="sxs-lookup"><span data-stu-id="9974f-108">Optionally, for better scalability and less impact in database locks, use eventual consistency between aggregates within the same domain.</span></span>

## <a name="what-is-a-domain-event"></a><span data-ttu-id="9974f-109">Che cos'è un evento di dominio?</span><span class="sxs-lookup"><span data-stu-id="9974f-109">What is a domain event?</span></span>

<span data-ttu-id="9974f-110">Un evento è un elemento che si è verificato in precedenza.</span><span class="sxs-lookup"><span data-stu-id="9974f-110">An event is something that has happened in the past.</span></span> <span data-ttu-id="9974f-111">Dominio sia un evento, in modo logico, un elemento che si sono verificati in un particolare dominio, e un elemento si desidera altre parti del dominio stesso (in-process) da tenere in considerazione e potenzialmente reagire di conseguenza.</span><span class="sxs-lookup"><span data-stu-id="9974f-111">A domain event is, logically, something that happened in a particular domain, and something you want other parts of the same domain (in-process) to be aware of and potentially react to.</span></span>

<span data-ttu-id="9974f-112">Un importante vantaggio di eventi di dominio è che gli effetti collaterali dopo è verificato un problema in un dominio possono essere espressi in modo esplicito anziché in modo implicito.</span><span class="sxs-lookup"><span data-stu-id="9974f-112">An important benefit of domain events is that side effects after something happened in a domain can be expressed explicitly instead of implicitly.</span></span> <span data-ttu-id="9974f-113">Tali lato effetti devono essere coerenti in modo verificarsi entrambi tutte le operazioni correlate all'attività di business, o nessuno di essi.</span><span class="sxs-lookup"><span data-stu-id="9974f-113">Those side effects must be consistent so either all the operations related to the business task happen, or none of them.</span></span> <span data-ttu-id="9974f-114">Inoltre, gli eventi di dominio consentono una migliore separazione delle problematiche tra le classi all'interno dello stesso dominio.</span><span class="sxs-lookup"><span data-stu-id="9974f-114">In addition, domain events enable a better separation of concerns among classes within the same domain.</span></span>

<span data-ttu-id="9974f-115">Ad esempio, se si utilizza soltanto solo Entity Framework e le entità o anche le aggregazioni, se essere causate da un caso d'uso di effetti collaterali, quelli verrà implementati come un concetto implicito nel codice a dopo che è verificato un problema.</span><span class="sxs-lookup"><span data-stu-id="9974f-115">For example, if you are just using just Entity Framework and entities or even aggregates, if there have to be side effects provoked by a use case, those will be implemented as an implicit concept in the coupled code after something happened.</span></span> <span data-ttu-id="9974f-116">Tuttavia, se è possibile visualizzare solo il codice, si potrebbe sapere se tale codice (l'effetto collaterale) fa parte dell'operazione principale o se è effettivamente un effetto collaterale.</span><span class="sxs-lookup"><span data-stu-id="9974f-116">But, if you just see that code, you might not know if that code (the side effect) is part of the main operation or if it really is a side effect.</span></span> <span data-ttu-id="9974f-117">D'altra parte, l'uso di eventi del dominio rende il concetto esplicite e una parte del linguaggio universale.</span><span class="sxs-lookup"><span data-stu-id="9974f-117">On the other hand, using domain events makes the concept explicit and part of the ubiquitous language.</span></span> <span data-ttu-id="9974f-118">Ad esempio, nell'applicazione eShopOnContainers, si crea un ordine non è quasi nell'ordine. Aggiorna o si crea un acquirente di aggregazione in base all'utente originale, in quanto l'utente non è un acquirente fino a quando non è disponibile un ordine.</span><span class="sxs-lookup"><span data-stu-id="9974f-118">For example, in the eShopOnContainers application, creating an order is not just about the order; it updates or creates a buyer aggregate based on the original user, because the user is not a buyer until there is an order in place.</span></span> <span data-ttu-id="9974f-119">Se si utilizzano gli eventi di dominio, è possibile esprimere in modo esplicito tale regola di dominio basato su nel linguaggio universale fornito da esperti del settore.</span><span class="sxs-lookup"><span data-stu-id="9974f-119">If you use domain events, you can explicitly express that domain rule based in the ubiquitous language provided by the domain experts.</span></span>

<span data-ttu-id="9974f-120">Gli eventi di dominio sono simili agli eventi di messaggistica in stile, con una differenza importante.</span><span class="sxs-lookup"><span data-stu-id="9974f-120">Domain events are somewhat similar to messaging-style events, with one important difference.</span></span> <span data-ttu-id="9974f-121">Con la messaggistica reale, Accodamento messaggi, gestori di messaggi o un bus di servizio mediante AMPQ, un messaggio viene sempre inviato in modo asincrono e comunicato tra i processi e le macchine.</span><span class="sxs-lookup"><span data-stu-id="9974f-121">With real messaging, message queuing, message brokers, or a service bus using AMPQ, a message is always sent asynchronously and communicated across processes and machines.</span></span> <span data-ttu-id="9974f-122">Ciò è utile per l'integrazione di più contesti delimitata, microservizi o addirittura nelle diverse applicazioni.</span><span class="sxs-lookup"><span data-stu-id="9974f-122">This is useful for integrating multiple Bounded Contexts, microservices, or even different applications.</span></span> <span data-ttu-id="9974f-123">Tuttavia, con gli eventi di dominio, che si desidera generare un evento dall'operazione di dominio che è in esecuzione, ma si desidera che tutti gli effetti collaterali si verifichi all'interno dello stesso dominio.</span><span class="sxs-lookup"><span data-stu-id="9974f-123">However, with domain events, you want to raise an event from the domain operation you are currently running, but you want any side effects to occur within the same domain.</span></span>

<span data-ttu-id="9974f-124">Gli eventi di dominio e i relativi effetti collaterali (le azioni attivate in seguito che sono gestite da gestori di eventi) deve verificarsi quasi immediatamente, in genere in-process e all'interno dello stesso dominio.</span><span class="sxs-lookup"><span data-stu-id="9974f-124">The domain events and their side effects (the actions triggered afterwards that are managed by event handlers) should occur almost immediately, usually in-process, and within the same domain.</span></span> <span data-ttu-id="9974f-125">Pertanto, gli eventi di dominio potrebbe essere sincrono o asincrono.</span><span class="sxs-lookup"><span data-stu-id="9974f-125">Thus, domain events could be synchronous or asynchronous.</span></span> <span data-ttu-id="9974f-126">Eventi di integrazione, tuttavia, devono essere sempre asincroni.</span><span class="sxs-lookup"><span data-stu-id="9974f-126">Integration events, however, should always be asynchronous.</span></span>

## <a name="domain-events-versus-integration-events"></a><span data-ttu-id="9974f-127">Eventi del dominio e gli eventi di integrazione</span><span class="sxs-lookup"><span data-stu-id="9974f-127">Domain events versus integration events</span></span>

<span data-ttu-id="9974f-128">Semanticamente, dominio e l'integrazione di eventi sono la stessa cosa: notifiche solo si è verificato qualcosa.</span><span class="sxs-lookup"><span data-stu-id="9974f-128">Semantically, domain and integration events are the same thing: notifications about something that just happened.</span></span> <span data-ttu-id="9974f-129">Tuttavia, l'implementazione deve essere diversa.</span><span class="sxs-lookup"><span data-stu-id="9974f-129">However, their implementation must be different.</span></span> <span data-ttu-id="9974f-130">Gli eventi di dominio sono solo i messaggi inviati al dispatcher eventi dominio, che potrebbe essere implementato come un mediatore in memoria in base a un contenitore IoC o qualsiasi altro metodo.</span><span class="sxs-lookup"><span data-stu-id="9974f-130">Domain events are just messages pushed to a domain event dispatcher, which could be implemented as an in-memory mediator based on an IoC container or any other method.</span></span>

<span data-ttu-id="9974f-131">D'altra parte, lo scopo di eventi di integrazione è per propagare il commit delle transazioni e gli aggiornamenti per altri sottosistemi, siano essi altri microservizi, delimitata contesti o applicazioni anche esterne.</span><span class="sxs-lookup"><span data-stu-id="9974f-131">On the other hand, the purpose of integration events is to propagate committed transactions and updates to additional subsystems, whether they are other microservices, Bounded Contexts or even external applications.</span></span> <span data-ttu-id="9974f-132">Di conseguenza, dovranno essere eseguite solo se l'entità è stata resa persistente, poiché in molti scenari in caso di errore, l'intera operazione non si è verificato.</span><span class="sxs-lookup"><span data-stu-id="9974f-132">Hence, they should occur only if the entity is successfully persisted, since in many scenarios if this fails, the entire operation effectively never happened.</span></span>

<span data-ttu-id="9974f-133">Inoltre e come indicato, integrazione con gli eventi devono essere basati sulla comunicazione asincrona tra più microservizi (altri contesti delimitata) o sistemi esterne o le applicazioni.</span><span class="sxs-lookup"><span data-stu-id="9974f-133">In addition, and as mentioned, integration events must be based on asynchronous communication between multiple microservices (other Bounded Contexts) or even external systems/applications.</span></span> <span data-ttu-id="9974f-134">Di conseguenza, l'interfaccia del bus di eventi deve parte dell'infrastruttura che consente di inter-process e distribuito la comunicazione tra servizi potenzialmente remoto.</span><span class="sxs-lookup"><span data-stu-id="9974f-134">Thus, the event bus interface needs some infrastructure that allows inter-process and distributed communication between potentially remote services.</span></span> <span data-ttu-id="9974f-135">Può basarsi su un bus di servizio esterno, code, un database condiviso utilizzato come una cassetta postale o qualsiasi altro distribuiti e idealmente push sistema di messaggistica basato su.</span><span class="sxs-lookup"><span data-stu-id="9974f-135">It can be based on a commercial service bus, queues, a shared database used as a mailbox, or any other distributed and ideally push based messaging system.</span></span>

## <a name="domain-events-as-a-preferred-way-to-trigger-side-effects-across-multiple-aggregates-within-the-same-domain"></a><span data-ttu-id="9974f-136">Eventi come un modo migliore per attivare gli effetti collaterali tra più aggregazioni all'interno dello stesso dominio del dominio</span><span class="sxs-lookup"><span data-stu-id="9974f-136">Domain events as a preferred way to trigger side effects across multiple aggregates within the same domain</span></span>

<span data-ttu-id="9974f-137">Se eseguire un comando relative a una istanza di aggregazione richiede regole di dominio aggiuntivi per l'esecuzione su una o più aggregazioni aggiuntive, è necessario progettare e implementare tali effetti collaterali verrà attivata da eventi del dominio.</span><span class="sxs-lookup"><span data-stu-id="9974f-137">If executing a command related to one aggregate instance requires additional domain rules to be run on one or more additional aggregates, you should design and implement those side effects to be triggered by domain events.</span></span> <span data-ttu-id="9974f-138">Come illustrato nella figura 9-14 e come uno dei principali casi d'uso, l'evento di un dominio deve essere usato per propagare le modifiche dello stato tra più aggregazioni all'interno del modello di dominio stesso.</span><span class="sxs-lookup"><span data-stu-id="9974f-138">As shown in Figure 9-14, and as one of the most important use cases, a domain event should be used to propagate state changes across multiple aggregates within the same domain model.</span></span>

![](./media/image15.png)

<span data-ttu-id="9974f-139">**Figura 9-14**.</span><span class="sxs-lookup"><span data-stu-id="9974f-139">**Figure 9-14**.</span></span> <span data-ttu-id="9974f-140">Eventi per garantire la coerenza tra più aggregazioni all'interno dello stesso dominio del dominio</span><span class="sxs-lookup"><span data-stu-id="9974f-140">Domain events to enforce consistency between multiple aggregates within the same domain</span></span>

<span data-ttu-id="9974f-141">Nella figura, quando l'utente avvia un ordine, l'evento di dominio OrderStarted genera la creazione di un oggetto Buyer in microservizio l'ordinamento, in base (le informazioni fornite nel comando CreateOrder) le informazioni utente originale da microservizio l'identità.</span><span class="sxs-lookup"><span data-stu-id="9974f-141">In the figure, when the user initiates an order, the OrderStarted domain event triggers creation of a Buyer object in the ordering microservice, based on the original user info from the identity microservice (with information provided in the CreateOrder command).</span></span> <span data-ttu-id="9974f-142">Quando viene creato in primo luogo, dall'aggregazione ordine viene generato l'evento di dominio.</span><span class="sxs-lookup"><span data-stu-id="9974f-142">The domain event is generated by the order aggregate when it is created in the first place.</span></span>

<span data-ttu-id="9974f-143">In alternativa, è possibile avere la radice di aggregazione sottoscritta gli eventi generati dai membri del relativo aggregazioni (entità figlio).</span><span class="sxs-lookup"><span data-stu-id="9974f-143">Alternately, you can have the aggregate root subscribed for events raised by members of its aggregates (child entities).</span></span> <span data-ttu-id="9974f-144">Ad esempio, ogni entità figlio OrderItem può generare un evento quando il prezzo dell'articolo è superiore a una quantità specifica o quando la quantità di elementi di prodotto è troppo elevata.</span><span class="sxs-lookup"><span data-stu-id="9974f-144">For instance, each OrderItem child entity can raise an event when the item price is higher than a specific amount, or when the product item amount is too high.</span></span> <span data-ttu-id="9974f-145">La radice di aggregazione può ricevere tali eventi ed eseguire un calcolo globale o l'aggregazione.</span><span class="sxs-lookup"><span data-stu-id="9974f-145">The aggregate root can then receive those events and perform a global calculation or aggregation.</span></span>

<span data-ttu-id="9974f-146">È importante comprendere che questa comunicazione basata su eventi non è implementata direttamente all'interno di funzioni di aggregazione; è necessario implementare i gestori di eventi di dominio.</span><span class="sxs-lookup"><span data-stu-id="9974f-146">It is important to understand that this event-based communication is not implemented directly within the aggregates; you need to implement domain event handlers.</span></span> <span data-ttu-id="9974f-147">Gestione degli eventi di dominio è un problema dell'applicazione.</span><span class="sxs-lookup"><span data-stu-id="9974f-147">Handling the domain events is an application concern.</span></span> <span data-ttu-id="9974f-148">Il livello del modello di dominio deve solo concentrarsi sulla logica di dominio, operazioni che si potrebbe considerare un esperto di dominio, non infrastruttura dell'applicazione come gestori eventi e azioni di persistenza effetto collaterale utilizzando repository.</span><span class="sxs-lookup"><span data-stu-id="9974f-148">The domain model layer should only focus on the domain logic—things that a domain expert would understand, not application infrastructure like handlers and side-effect persistence actions using repositories.</span></span> <span data-ttu-id="9974f-149">Pertanto, al livello applicazione è in cui si hanno i gestori di eventi di dominio attivano azioni quando viene generato un evento di dominio.</span><span class="sxs-lookup"><span data-stu-id="9974f-149">Therefore, the application layer level is where you should have domain event handlers triggering actions when a domain event is raised.</span></span>

<span data-ttu-id="9974f-150">Eventi del dominio possono anche essere utilizzati per avviare qualsiasi numero di azioni di applicazione, e ciò che è più importante, deve essere aperta per aumentare il numero in futuro in modo separato.</span><span class="sxs-lookup"><span data-stu-id="9974f-150">Domain events can also be used to trigger any number of application actions, and what is more important, must be open to increase that number in the future in a decoupled way.</span></span> <span data-ttu-id="9974f-151">Ad esempio, quando l'ordine viene avviato, potrebbe essere da pubblicare un evento di dominio per propagare tali informazioni da altre funzioni di aggregazione o anche per generare le azioni di applicazioni quali le notifiche.</span><span class="sxs-lookup"><span data-stu-id="9974f-151">For instance, when the order is started, you might want to publish a domain event to propagate that info to other aggregates or even to raise application actions like notifications.</span></span>

<span data-ttu-id="9974f-152">Il punto chiave è il numero di azioni da eseguire quando si verifica un evento di dominio aprire.</span><span class="sxs-lookup"><span data-stu-id="9974f-152">The key point is the open number of actions to be executed when a domain event occurs.</span></span> <span data-ttu-id="9974f-153">Infine, aumentano le azioni e le regole del dominio e l'applicazione.</span><span class="sxs-lookup"><span data-stu-id="9974f-153">Eventually, the actions and rules in the domain and application will grow.</span></span> <span data-ttu-id="9974f-154">La complessità o il numero di azioni di effetto collaterale, quando si verifica un evento aumenteranno, ma se il codice sono stato combinato con "glue" (ovvero solo istanze di oggetti con la parola chiave new in C\#), quindi ogni volta che è necessario aggiungere una nuova azione è necessario modificare il codice originale.</span><span class="sxs-lookup"><span data-stu-id="9974f-154">The complexity or number of side-effect actions when something happens will grow, but if your code were coupled with “glue” (that is, just instantiating objects with the new keyword in C\#), then every time you needed to add a new action you would need to change the original code.</span></span> <span data-ttu-id="9974f-155">Ciò potrebbe causare nuovi bug, poiché con ogni nuovo requisito è necessario modificare il flusso di codice originale.</span><span class="sxs-lookup"><span data-stu-id="9974f-155">This could result in new bugs, because with each new requirement you would need to change the original code flow.</span></span> <span data-ttu-id="9974f-156">Questo va contro il [principio aperto o chiuso](https://en.wikipedia.org/wiki/Open/closed_principle) da [a tinta unita](https://en.wikipedia.org/wiki/SOLID_(object-oriented_design)).</span><span class="sxs-lookup"><span data-stu-id="9974f-156">This goes against the [Open/Closed principle](https://en.wikipedia.org/wiki/Open/closed_principle) from [SOLID](https://en.wikipedia.org/wiki/SOLID_(object-oriented_design)).</span></span> <span data-ttu-id="9974f-157">Non solo, la classe originale che è stato orchestrazione le operazioni di aumento delle dimensioni e aumento delle dimensioni, che va contro il [singolo responsabilità principio (criteri di restrizione software)](https://en.wikipedia.org/wiki/Single_responsibility_principle).</span><span class="sxs-lookup"><span data-stu-id="9974f-157">Not only that, the original class that was orchestrating the operations would grow and grow, which goes against the [Single Responsibility Principle (SRP)](https://en.wikipedia.org/wiki/Single_responsibility_principle).</span></span>

<span data-ttu-id="9974f-158">D'altra parte, se si utilizzano gli eventi di dominio, è possibile creare un'implementazione con granularità fine e disaccoppiata adeguatamente responsabilità utilizzando questo approccio:</span><span class="sxs-lookup"><span data-stu-id="9974f-158">On the other hand, if you use domain events, you can create a fine-grained and decoupled implementation by segregating responsibilities using this approach:</span></span>

1.  <span data-ttu-id="9974f-159">Inviare un comando (ad esempio, CreateOrder).</span><span class="sxs-lookup"><span data-stu-id="9974f-159">Send a command (for example, CreateOrder).</span></span>
2.  <span data-ttu-id="9974f-160">Il comando di ricezione in un gestore del comando.</span><span class="sxs-lookup"><span data-stu-id="9974f-160">Receive the command in a command handler.</span></span>
    -   <span data-ttu-id="9974f-161">Eseguire la transazione della funzione di aggregazione singolo.</span><span class="sxs-lookup"><span data-stu-id="9974f-161">Execute a single aggregate’s transaction.</span></span>
    -   <span data-ttu-id="9974f-162">(Facoltativo) Generare eventi di dominio per gli effetti collaterali (ad esempio, OrderStartedDomainDvent).</span><span class="sxs-lookup"><span data-stu-id="9974f-162">(Optional) Raise domain events for side effects (for example, OrderStartedDomainDvent).</span></span>
1.  <span data-ttu-id="9974f-163">Handle dominio eventi (all'interno del processo corrente) thast verrà eseguito un numero di aprire gli effetti collaterali in più funzioni di aggregazione o azioni di applicazione.</span><span class="sxs-lookup"><span data-stu-id="9974f-163">Handle domain events (within the current process) thast will execute an open number of side effects in multiple aggregates or application actions.</span></span> <span data-ttu-id="9974f-164">Ad esempio:</span><span class="sxs-lookup"><span data-stu-id="9974f-164">For example:</span></span>
    -   <span data-ttu-id="9974f-165">Verificare o create (metodo di pagamento e l'acquirente).</span><span class="sxs-lookup"><span data-stu-id="9974f-165">Verify or create buyer and payment method.</span></span>
    -   <span data-ttu-id="9974f-166">Creare e inviare un evento correlato di integrazione per il bus di eventi per gli stati si propagano tra microservizi o trigger azioni esterne quali l'invio di un messaggio di posta elettronica all'acquirente.</span><span class="sxs-lookup"><span data-stu-id="9974f-166">Create and send a related integration event to the event bus to propagate states across microservices or trigger external actions like sending an email to the buyer.</span></span>
    -   <span data-ttu-id="9974f-167">Gestire altri effetti collaterali.</span><span class="sxs-lookup"><span data-stu-id="9974f-167">Handle other side effects.</span></span>

<span data-ttu-id="9974f-168">Come illustrato nella figura 9-15, a partire dall'evento stesso dominio, è possibile gestire più azioni relative a altre funzioni di aggregazione nel dominio o azioni di applicazione aggiuntiva che è necessario eseguire tra microservizi connessione con il bus di eventi ed eventi di integrazione.</span><span class="sxs-lookup"><span data-stu-id="9974f-168">As shown in Figure 9-15, starting from the same domain event, you can handle multiple actions related to other aggregates in the domain or additional application actions you need to perform across microservices connecting with integration events and the event bus.</span></span>

![](./media/image16.png)

<span data-ttu-id="9974f-169">**Figura 9-15**.</span><span class="sxs-lookup"><span data-stu-id="9974f-169">**Figure 9-15**.</span></span> <span data-ttu-id="9974f-170">La gestione di più azioni per ogni dominio</span><span class="sxs-lookup"><span data-stu-id="9974f-170">Handling multiple actions per domain</span></span>

<span data-ttu-id="9974f-171">I gestori di eventi sono in genere nel livello dell'applicazione, poiché si utilizzeranno gli oggetti di infrastruttura come repository o un'API di applicazione per il comportamento del microservizio.</span><span class="sxs-lookup"><span data-stu-id="9974f-171">The event handlers are typically in the application layer, because you will use infrastructure objects like repositories or an application API for the microservice’s behavior.</span></span> <span data-ttu-id="9974f-172">In tal senso, i gestori di eventi sono simili ai gestori di comando, in modo che entrambi siano parte del livello di applicazione.</span><span class="sxs-lookup"><span data-stu-id="9974f-172">In that sense, event handlers are similar to command handlers, so both are part of the application layer.</span></span> <span data-ttu-id="9974f-173">La differenza importante è che un comando deve essere elaborato una sola volta.</span><span class="sxs-lookup"><span data-stu-id="9974f-173">The important difference is that a command should be processed just once.</span></span> <span data-ttu-id="9974f-174">Un evento di dominio può essere elaborato da zero o  *n*  volte, poiché se possono essere ricevuti da più ricevitori o gestori di eventi con uno scopo diverso per ogni gestore.</span><span class="sxs-lookup"><span data-stu-id="9974f-174">A domain event could be processed zero or *n* times, because if can be received by multiple receivers or event handlers with a different purpose for each handler.</span></span>

<span data-ttu-id="9974f-175">La possibilità di un numero di gestori per l'evento di dominio aprire consente di aggiungere molte altre regole di dominio senza conseguenze per il codice corrente.</span><span class="sxs-lookup"><span data-stu-id="9974f-175">The possibility of an open number of handlers per domain event allows you to add many more domain rules without impacting your current code.</span></span> <span data-ttu-id="9974f-176">Implementa la seguente regola di business che deve essere eseguita a destra dopo un evento, ad esempio, potrebbe essere facile come aggiungere alcuni gestori di eventi (o anche solo una):</span><span class="sxs-lookup"><span data-stu-id="9974f-176">For instance, implementing the following business rule that has to happen right after an event might be as easy as adding a few event handlers (or even just one):</span></span>

<span data-ttu-id="9974f-177">Quando la quantità totale acquistata da un cliente nell'archivio, in qualsiasi numero di ordini, supera $6.000, applicare un sconto del 10% per ogni nuovo ordine e una notifica al cliente con un messaggio di posta elettronica su tale sconto per gli ordini futuri.</span><span class="sxs-lookup"><span data-stu-id="9974f-177">When the total amount purchased by a customer in the store, across any number of orders, exceeds $6,000, apply a 10% off discount to every new order and notify the customer with an email about that discount for future orders.</span></span>

## <a name="implementing-domain-events"></a><span data-ttu-id="9974f-178">Implementazione di eventi di dominio</span><span class="sxs-lookup"><span data-stu-id="9974f-178">Implementing domain events</span></span>

<span data-ttu-id="9974f-179">In c#, l'evento di un dominio è semplicemente una struttura di dati azienda o classe, come un DTO, con tutte le informazioni correlate a cosa è successo solo nel dominio, come illustrato nell'esempio seguente:</span><span class="sxs-lookup"><span data-stu-id="9974f-179">In C#, a domain event is simply a data-holding structure or class, like a DTO, with all the information related to what just happened in the domain, as shown in the following example:</span></span>

```csharp
public class OrderStartedDomainEvent : IAsyncNotification
{
    public int CardTypeId { get; private set; }
    public string CardNumber { get; private set; }
    public string CardSecurityNumber { get; private set; }
    public string CardHolderName { get; private set; }
    public DateTime CardExpiration { get; private set; }
    public Order Order { get; private set; }

    public OrderStartedDomainEvent(Order order,
        int cardTypeId, string cardNumber,
        string cardSecurityNumber, string cardHolderName,
        DateTime cardExpiration)
    {
        Order = order;
        CardTypeId = cardTypeId;
        CardNumber = cardNumber;
        CardSecurityNumber = cardSecurityNumber;
        CardHolderName = cardHolderName;
        CardExpiration = cardExpiration;
    }
}
```

<span data-ttu-id="9974f-180">Si tratta essenzialmente di una classe che contiene tutti i dati relativi all'evento OrderStarted.</span><span class="sxs-lookup"><span data-stu-id="9974f-180">This is essentially a class that holds all the data related to the OrderStarted event.</span></span>

<span data-ttu-id="9974f-181">In termini di linguaggio universale di dominio, poiché un evento è un elemento che si sono verificati in passato, il nome della classe dell'evento deve essere rappresentato come un verbo passato, ad esempio OrderStartedDomainEvent o OrderShippedDomainEvent.</span><span class="sxs-lookup"><span data-stu-id="9974f-181">In terms of the ubiquitous language of the domain, since an event is something that happened in the past, the class name of the event should be represented as a past-tense verb, like OrderStartedDomainEvent or OrderShippedDomainEvent.</span></span> <span data-ttu-id="9974f-182">Che è l'implementazione di eventi di dominio l'ordinamento microservizio in eShopOnContainers.</span><span class="sxs-lookup"><span data-stu-id="9974f-182">That is how the domain event is implemented in the ordering microservice in eShopOnContainers.</span></span>

<span data-ttu-id="9974f-183">Come notato in precedenza, una caratteristica importante degli eventi è che poiché un evento è un elemento che si sono verificati in passato, consiglia di non modificare.</span><span class="sxs-lookup"><span data-stu-id="9974f-183">As we have noted, an important characteristic of events is that since an event is something that happened in the past, it should not change.</span></span> <span data-ttu-id="9974f-184">Di conseguenza deve essere una classe non modificabile.</span><span class="sxs-lookup"><span data-stu-id="9974f-184">Therefore it must be an immutable class.</span></span> <span data-ttu-id="9974f-185">È possibile visualizzare nel codice precedente che le proprietà sono di sola lettura all'esterno dell'oggetto.</span><span class="sxs-lookup"><span data-stu-id="9974f-185">You can see in the preceding code that the properties are read-only from outside of the object.</span></span> <span data-ttu-id="9974f-186">L'unico modo per aggiornare l'oggetto è tramite il costruttore quando si crea l'oggetto evento.</span><span class="sxs-lookup"><span data-stu-id="9974f-186">The only way to update the object is through the constructor when you create the event object.</span></span>

### <a name="raising-domain-events"></a><span data-ttu-id="9974f-187">Generazione di eventi di dominio</span><span class="sxs-lookup"><span data-stu-id="9974f-187">Raising domain events</span></span>

<span data-ttu-id="9974f-188">Domanda successiva viene illustrato come generare un evento di dominio in modo da raggiungere relativi gestori di eventi correlati.</span><span class="sxs-lookup"><span data-stu-id="9974f-188">The next question is how to raise a domain event so it reaches its related event handlers.</span></span> <span data-ttu-id="9974f-189">È possibile utilizzare diversi approcci disponibili.</span><span class="sxs-lookup"><span data-stu-id="9974f-189">You can use multiple approaches.</span></span>

<span data-ttu-id="9974f-190">udi Dahan proposto in origine (ad esempio, in diversi correlata post, ad esempio [dominio eventi e richiedere 2](http://udidahan.com/2008/08/25/domain-events-take-2/)) utilizzando una classe statica per la gestione e generazione degli eventi.</span><span class="sxs-lookup"><span data-stu-id="9974f-190">Udi Dahan originally proposed (for example, in several related posts, such as [Domain Events – Take 2](http://udidahan.com/2008/08/25/domain-events-take-2/)) using a static class for managing and raising the events.</span></span> <span data-ttu-id="9974f-191">Potrebbe trattarsi di una classe statica denominata DomainEvents che determina la generazione di eventi di dominio immediatamente quando viene chiamato, utilizzando una sintassi analoga DomainEvents.Raise (evento myEvent).</span><span class="sxs-lookup"><span data-stu-id="9974f-191">This might include a static class named DomainEvents that would raise domain events immediately when it is called, using syntax like DomainEvents.Raise(Event myEvent).</span></span> <span data-ttu-id="9974f-192">Jimmy Bogard ha scritto un post di blog ([rafforzare il dominio: eventi del dominio](https://lostechies.com/jimmybogard/2010/04/08/strengthening-your-domain-domain-events/)) che si consiglia un approccio simile.</span><span class="sxs-lookup"><span data-stu-id="9974f-192">Jimmy Bogard wrote a blog post ([Strengthening your domain: Domain Events](https://lostechies.com/jimmybogard/2010/04/08/strengthening-your-domain-domain-events/)) that recommends a similar approach.</span></span>

<span data-ttu-id="9974f-193">Tuttavia, quando la classe di eventi di dominio è statica, anche invia ai gestori immediatamente.</span><span class="sxs-lookup"><span data-stu-id="9974f-193">However, when the domain events class is static, it also dispatches to handlers immediately.</span></span> <span data-ttu-id="9974f-194">Questo test e debug più difficile, perché i gestori di eventi con la logica di effetti collaterali vengono eseguiti immediatamente dopo l'evento viene generato.</span><span class="sxs-lookup"><span data-stu-id="9974f-194">This makes testing and debugging more difficult, because the event handlers with side-effects logic are executed immediately after the event is raised.</span></span> <span data-ttu-id="9974f-195">Quando si eseguono test e debug, si desidera lo stato attivo su solo ciò che accade nelle classi aggregazione corrente; non si desidera improvvisamente reindirizzati ad altri gestori di eventi per gli effetti collaterali correlati ad altre funzioni di aggregazione o la logica dell'applicazione.</span><span class="sxs-lookup"><span data-stu-id="9974f-195">When you are testing and debugging, you want to focus on and just what is happening in the current aggregate classes; you do not want to suddenly be redirected to other event handlers for side effects related to other aggregates or application logic.</span></span> <span data-ttu-id="9974f-196">Ecco perché altri approcci sono stati ulteriormente sviluppati, come illustrato nella sezione successiva.</span><span class="sxs-lookup"><span data-stu-id="9974f-196">This is why other approaches have evolved, as explained in the next section.</span></span>

#### <a name="the-deferred-approach-for-raising-and-dispatching-events"></a><span data-ttu-id="9974f-197">L'approccio posticipata per la generazione e invio di eventi</span><span class="sxs-lookup"><span data-stu-id="9974f-197">The deferred approach for raising and dispatching events</span></span>

<span data-ttu-id="9974f-198">Invece di invio immediatamente a un gestore di dominio, un approccio migliore consiste nell'aggiungere gli eventi di dominio a una raccolta e quindi per inviare gli eventi di dominio *immediatamente prima di* o *destra*  *Dopo aver* il commit della transazione (come con SaveChanges in Entity Framework).</span><span class="sxs-lookup"><span data-stu-id="9974f-198">Instead of dispatching to a domain event handler immediately, a better approach is to add the domain events to a collection and then to dispatch those domain events *right before* or *right* *after* committing the transaction (as with SaveChanges in EF).</span></span> <span data-ttu-id="9974f-199">(Questo approccio descritto da Jimmy Bogard in questo post di [un modello di eventi di dominio migliorato](https://lostechies.com/jimmybogard/2014/05/13/a-better-domain-events-pattern/).)</span><span class="sxs-lookup"><span data-stu-id="9974f-199">(This approach was described by Jimmy Bogard in this post [A better domain events pattern](https://lostechies.com/jimmybogard/2014/05/13/a-better-domain-events-pattern/).)</span></span>

<span data-ttu-id="9974f-200">Decidere se inviare gli eventi di dominio immediatamente prima o a destra dopo il commit della transazione è importante, poiché determina se gli effetti collaterali verranno incluse come parte della stessa transazione o in transazioni diverse.</span><span class="sxs-lookup"><span data-stu-id="9974f-200">Deciding if you send the domain events right before or right after committing the transaction is important, since it determines whether you will include the side effects as part of the same transaction or in different transactions.</span></span> <span data-ttu-id="9974f-201">Nel secondo caso, è necessario affrontare la coerenza eventuale tra più funzioni di aggregazione.</span><span class="sxs-lookup"><span data-stu-id="9974f-201">In the latter case, you need to deal with eventual consistency across multiple aggregates.</span></span> <span data-ttu-id="9974f-202">In questo argomento viene illustrato nella sezione successiva.</span><span class="sxs-lookup"><span data-stu-id="9974f-202">This topic is discussed in the next section.</span></span>

<span data-ttu-id="9974f-203">L'approccio posticipata è quali eShopOnContainers utilizza.</span><span class="sxs-lookup"><span data-stu-id="9974f-203">The deferred approach is what eShopOnContainers uses.</span></span> <span data-ttu-id="9974f-204">È innanzitutto necessario aggiungere gli eventi in corso nelle entità in una raccolta o un elenco di eventi per l'entità.</span><span class="sxs-lookup"><span data-stu-id="9974f-204">First, you add the events happening in your entities into a collection or list of events per entity.</span></span> <span data-ttu-id="9974f-205">Tale elenco deve essere fanno parte dell'oggetto entità, o, ancora meglio, la classe di entità di base, come illustrato nell'esempio seguente:</span><span class="sxs-lookup"><span data-stu-id="9974f-205">That list should be part of the entity object, or even better, part of your base entity class, as shown in the following example:</span></span>

```csharp
public abstract class Entity
{
    private List<IAsyncNotification> _domainEvents;

    public List<IAsyncNotification> DomainEvents => _domainEvents;

    public void AddDomainEvent(IAsyncNotification eventItem)
    {
        _domainEvents = _domainEvents ?? new List<IAsyncNotification>();
        _domainEvents.Add(eventItem);
    }

    public void RemoveDomainEvent(IAsyncNotification eventItem)
    {
        if (_domainEvents is null) return;
        _domainEvents.Remove(eventItem);
    }
    // ...
}
```

<span data-ttu-id="9974f-206">Quando si desidera generare un evento, viene semplicemente aggiunto alla raccolta di eventi per essere inserito all'interno di un metodo di aggregazione di entità, come illustrato nel codice seguente:</span><span class="sxs-lookup"><span data-stu-id="9974f-206">When you want to raise an event, you just add it to the event collection to be placed within an aggregate entity method, as the following code shows:</span></span>

```csharp
var orderStartedDomainEvent = new OrderStartedDomainEvent(this, //Order object
    cardTypeId,
    cardNumber,
    cardSecurityNumber,
    cardHolderName,
    cardExpiration);
this.AddDomainEvent(orderStartedDomainEvent);
```

<span data-ttu-id="9974f-207">Si noti che l'unico elemento che esegue il metodo AddDomainEvent viene aggiunta di un evento all'elenco.</span><span class="sxs-lookup"><span data-stu-id="9974f-207">Notice that the only thing that the AddDomainEvent method is doing is adding an event to the list.</span></span> <span data-ttu-id="9974f-208">Viene generato alcun evento ancora, e nessun gestore dell'evento viene richiamato ancora.</span><span class="sxs-lookup"><span data-stu-id="9974f-208">No event is raised yet, and no event handler is invoked yet.</span></span>

<span data-ttu-id="9974f-209">In realtà si desidera inviare gli eventi in un secondo momento quando si esegue il commit della transazione nel database.</span><span class="sxs-lookup"><span data-stu-id="9974f-209">You actually want to dispatch the events later on, when you commit the transaction to the database.</span></span> <span data-ttu-id="9974f-210">Se si utilizza Entity Framework Core, significa che nel metodo SaveChanges DbContext l'Entity Framework, come illustrato nel codice seguente:</span><span class="sxs-lookup"><span data-stu-id="9974f-210">If you are using Entity Framework Core, that means in the SaveChanges method of your EF DbContext, as in the following code:</span></span>

```csharp
// EF Core DbContext
public class OrderingContext : DbContext, IUnitOfWork
{
    // ...
    public async Task<int> SaveEntitiesAsync()
    {
        // Dispatch Domain Events collection.
        // Choices:
        // A) Right BEFORE committing data (EF SaveChanges) into the DB. This makes
        // a single transaction including side effects from the domain event
        // handlers that are using the same DbContext with Scope lifetime
        // B) Right AFTER committing data (EF SaveChanges) into the DB. This makes
        // multiple transactions. You will need to handle eventual consistency and
        // compensatory actions in case of failures.
        await _mediator.DispatchDomainEventsAsync(this);
        // After this line runs, all the changes (from the Command Handler and Domain
        // event handlers) performed through the DbContext will be commited
        var result = await base.SaveChangesAsync();
    }
}
```

<span data-ttu-id="9974f-211">Con questo codice, inviare gli eventi di entità per i rispettivi gestori eventi.</span><span class="sxs-lookup"><span data-stu-id="9974f-211">With this code, you dispatch the entity events to their respective event handlers.</span></span>

<span data-ttu-id="9974f-212">Il risultato complessivo è è avere separata la generazione di un evento di dominio (aggiunta di un semplice in un elenco in memoria) da distribuirlo a un gestore eventi.</span><span class="sxs-lookup"><span data-stu-id="9974f-212">The overall result is that you have decoupled the raising of a domain event (a simple add into a list in memory) from dispatching it to an event handler.</span></span> <span data-ttu-id="9974f-213">Inoltre, a seconda di quale tipo di dispatcher in uso, si potrebbero inviare gli eventi in modo sincrono o asincrono.</span><span class="sxs-lookup"><span data-stu-id="9974f-213">In addition, depending on what kind of dispatcher you are using, you could dispatch the events synchronously or asynchronously.</span></span>

<span data-ttu-id="9974f-214">Tenere presente che limiti transazionali diventi significativi riprodurre qui.</span><span class="sxs-lookup"><span data-stu-id="9974f-214">Be aware that transactional boundaries come into significant play here.</span></span> <span data-ttu-id="9974f-215">Se l'unità di lavoro e delle transazioni può estendersi su più di una funzione di aggregazione (come avviene quando si utilizza Entity Framework Core e un database relazionale), questo può funzionare bene.</span><span class="sxs-lookup"><span data-stu-id="9974f-215">If your unit of work and transaction can span more than one aggregate (as when using EF Core and a relational database), this can work well.</span></span> <span data-ttu-id="9974f-216">Tuttavia, se la transazione non può estendersi aggregati, ad esempio quando si utilizza un database NoSQL come Azure DocumentDB, è necessario implementare i passaggi aggiuntivi per ottenere la coerenza.</span><span class="sxs-lookup"><span data-stu-id="9974f-216">But if the transaction cannot span aggregates, such as when you are using a NoSQL database like Azure DocumentDB, you have to implement additional steps to achieve consistency.</span></span> <span data-ttu-id="9974f-217">Si tratta di un altro motivo mancato riconoscimento della persistenza non universale; a seconda del sistema di archiviazione in uso.</span><span class="sxs-lookup"><span data-stu-id="9974f-217">This is another reason why persistence ignorance is not universal; it depends on the storage system you use.</span></span>

### <a name="single-transaction-across-aggregates-versus-eventual-consistency-across-aggregates"></a><span data-ttu-id="9974f-218">Singola transazione tra funzioni di aggregazione e la coerenza eventuale tra funzioni di aggregazione</span><span class="sxs-lookup"><span data-stu-id="9974f-218">Single transaction across aggregates versus eventual consistency across aggregates</span></span>

<span data-ttu-id="9974f-219">Se si desidera eseguire una singola transazione tra funzioni di aggregazione e basarsi su coerenza finale tra tali aggregazioni alla domanda è controversi.</span><span class="sxs-lookup"><span data-stu-id="9974f-219">The question of whether to perform a single transaction across aggregates versus relying on eventual consistency across those aggregates is a controversial one.</span></span> <span data-ttu-id="9974f-220">Molti autori DDD come Eric Evans e Vaughn Vernon sostenere la regola che una transazione = un'aggregazione e pertanto sostenere per la coerenza finale in funzioni di aggregazione.</span><span class="sxs-lookup"><span data-stu-id="9974f-220">Many DDD authors like Eric Evans and Vaughn Vernon advocate the rule that one transaction = one aggregate and therefore argue for eventual consistency across aggregates.</span></span> <span data-ttu-id="9974f-221">Ad esempio, nel suo libro *la progettazione*, Eric Evans afferma:</span><span class="sxs-lookup"><span data-stu-id="9974f-221">For example, in his book *Domain-Driven Design*, Eric Evans says this:</span></span>

<span data-ttu-id="9974f-222">Una regola che si estende su aggregazioni non previsto per essere aggiornate in qualsiasi momento.</span><span class="sxs-lookup"><span data-stu-id="9974f-222">Any rule that spans Aggregates will not be expected to be up-to-date at all times.</span></span> <span data-ttu-id="9974f-223">Tramite l'elaborazione degli eventi, l'elaborazione batch o altri meccanismi di aggiornamento, altre dipendenze possono essere risolti all'interno di tempo specifico.</span><span class="sxs-lookup"><span data-stu-id="9974f-223">Through event processing, batch processing, or other update mechanisms, other dependencies can be resolved within some specific time.</span></span> <span data-ttu-id="9974f-224">(pagina.</span><span class="sxs-lookup"><span data-stu-id="9974f-224">(pg.</span></span> <span data-ttu-id="9974f-225">128)</span><span class="sxs-lookup"><span data-stu-id="9974f-225">128)</span></span>

<span data-ttu-id="9974f-226">Vaughn Vernon il messaggio seguente in [progettazione di aggregazione efficace. Parte II: Apportato aggrega lavoro insieme](http://dddcommunity.org/wp-content/uploads/files/pdf_articles/Vernon_2011_2.pdf):</span><span class="sxs-lookup"><span data-stu-id="9974f-226">Vaughn Vernon says the following in [Effective Aggregate Design. Part II: Making Aggregates Work Together](http://dddcommunity.org/wp-content/uploads/files/pdf_articles/Vernon_2011_2.pdf):</span></span>

<span data-ttu-id="9974f-227">Di conseguenza, se l'esecuzione di un comando in una istanza di aggregazione richiede che le regole di business aggiuntive eseguire su una o più aggregazioni, utilizzare la coerenza eventuale \[...\] È un modo pratico per supportare la coerenza eventuale in un modello DDD.</span><span class="sxs-lookup"><span data-stu-id="9974f-227">Thus, if executing a command on one aggregate instance requires that additional business rules execute on one or more aggregates, use eventual consistency \[...\] There is a practical way to support eventual consistency in a DDD model.</span></span> <span data-ttu-id="9974f-228">Un metodo di aggregazione pubblica un evento di dominio che è nel tempo recapitato a uno o più sottoscrittori asincroni.</span><span class="sxs-lookup"><span data-stu-id="9974f-228">An aggregate method publishes a domain event that is in time delivered to one or more asynchronous subscribers.</span></span>

<span data-ttu-id="9974f-229">Questa spiegazione logica si basa su adottando granulari per le transazioni anziché le transazioni che si estende su molte funzioni di aggregazione o entità.</span><span class="sxs-lookup"><span data-stu-id="9974f-229">This rationale is based on embracing fine-grained transactions instead of transactions spanning many aggregates or entities.</span></span> <span data-ttu-id="9974f-230">L'idea è che nel secondo caso, il numero di blocchi di database sarà significativo nelle applicazioni su larga scala con esigenze di scalabilità.</span><span class="sxs-lookup"><span data-stu-id="9974f-230">The idea is that in the second case, the number of database locks will be substantial in large-scale applications with high scalability needs.</span></span> <span data-ttu-id="9974f-231">L'adozione del fatto che le applicazioni con scalabilità elevata, deve necessariamente contenere immediata coerenza transazionale tra più aggregazioni consente di accettare il concetto di coerenza finale.</span><span class="sxs-lookup"><span data-stu-id="9974f-231">Embracing the fact that high-scalable applications need not have instant transactional consistency between multiple aggregates helps with accepting the concept of eventual consistency.</span></span> <span data-ttu-id="9974f-232">Le modifiche spesso non sono necessari per l'azienda ed è in ogni caso la responsabilità di esperti del settore per pronunciare le necessitano operazioni particolari transazioni atomiche o non è atomico.</span><span class="sxs-lookup"><span data-stu-id="9974f-232">Atomic changes are often not needed by the business, and it is in any case the responsibility of the domain experts to say whether particular operations need atomic transactions or not.</span></span> <span data-ttu-id="9974f-233">Se una transazione atomica tra più funzioni di aggregazione è sempre un'operazione, è possibile chiedere se la funzione di aggregazione deve essere maggiore o non è stato progettato in modo corretto.</span><span class="sxs-lookup"><span data-stu-id="9974f-233">If an operation always needs an atomic transaction between multiple aggregates, you might ask whether your aggregate should be larger or was not correctly designed.</span></span>

<span data-ttu-id="9974f-234">Tuttavia, altri sviluppatori e progettisti come Jimmy Bogard desidera che si estende su una singola transazione tra diverse funzioni di aggregazione, ma solo quando le aggregazioni aggiuntive sono correlate gli effetti collaterali per lo stesso comando originale.</span><span class="sxs-lookup"><span data-stu-id="9974f-234">However, other developers and architects like Jimmy Bogard are okay with spanning a single transaction across several aggregates—but only when those additional aggregates are related to side effects for the same original command.</span></span> <span data-ttu-id="9974f-235">Ad esempio, in [un modello di eventi di dominio migliorato](https://lostechies.com/jimmybogard/2014/05/13/a-better-domain-events-pattern/), Bogard afferma:</span><span class="sxs-lookup"><span data-stu-id="9974f-235">For instance, in [A better domain events pattern](https://lostechies.com/jimmybogard/2014/05/13/a-better-domain-events-pattern/), Bogard says this:</span></span>

<span data-ttu-id="9974f-236">In genere, desidero che gli effetti collaterali di un evento di dominio di cui si verificano all'interno della stessa transazione logica, ma non necessariamente nello stesso ambito di generazione dell'evento di dominio \[...\] Prima che si esegue il commit della transazione, si invia gli eventi per i rispettivi gestori.</span><span class="sxs-lookup"><span data-stu-id="9974f-236">Typically, I want the side effects of a domain event to occur within the same logical transaction, but not necessarily in the same scope of raising the domain event \[...\] Just before we commit our transaction, we dispatch our events to their respective handlers.</span></span>

<span data-ttu-id="9974f-237">Se si dispatch destra eventi dominio *prima* eseguito il commit della transazione originale, è perché si vuole che gli effetti collaterali di tali eventi da includere nella stessa transazione.</span><span class="sxs-lookup"><span data-stu-id="9974f-237">If you dispatch the domain events right *before* committing the original transaction, it is because you want the side effects of those events to be included in the same transaction.</span></span> <span data-ttu-id="9974f-238">Ad esempio, se il metodo DbContext SaveChanges EF non riesce, la transazione verrà rollback tutte le modifiche, tra cui il risultato di tutte le operazioni di effetto collaterale implementato per i gestori di eventi del dominio correlate.</span><span class="sxs-lookup"><span data-stu-id="9974f-238">For example, if the EF DbContext SaveChanges method fails, the transaction will roll back all changes, including the result of any side effect operations implemented by the related domain event handlers.</span></span> <span data-ttu-id="9974f-239">Questo è poiché l'ambito della vita DbContext per impostazione predefinita, definito come "con ambito."</span><span class="sxs-lookup"><span data-stu-id="9974f-239">This is because the DbContext life scope is by default defined as "scoped."</span></span> <span data-ttu-id="9974f-240">Pertanto, l'oggetto DbContext è condiviso da più oggetti di repository viene creata un'istanza all'interno della stesso ambito o di un oggetto grafico.</span><span class="sxs-lookup"><span data-stu-id="9974f-240">Therefore, the DbContext object is shared across multiple repository objects being instantiated within the same scope or object graph.</span></span> <span data-ttu-id="9974f-241">Che coincide con l'ambito di HttpRequest quando si sviluppano applicazioni API Web o di MVC.</span><span class="sxs-lookup"><span data-stu-id="9974f-241">This coincides with the HttpRequest scope when developing Web API or MVC apps.</span></span>

<span data-ttu-id="9974f-242">In realtà, entrambi gli approcci (singola transazione atomica e la coerenza eventuale) possono essere corretti.</span><span class="sxs-lookup"><span data-stu-id="9974f-242">In reality, both approaches (single atomic transaction and eventual consistency) can be right.</span></span> <span data-ttu-id="9974f-243">Questo dipende i dominio o dei requisiti aziendali e cosa esperti del settore indicano.</span><span class="sxs-lookup"><span data-stu-id="9974f-243">It really depends on your domain or business requirements and what the domain experts tell you.</span></span> <span data-ttu-id="9974f-244">Dipende inoltre come scalabile è necessario il servizio sia (più granulare transazioni hanno un impatto minore in relazione a blocchi di database).</span><span class="sxs-lookup"><span data-stu-id="9974f-244">It also depends on how scalable you need the service to be (more granular transactions have less impact with regard to database locks).</span></span> <span data-ttu-id="9974f-245">E dipende quanto investimento che si desidera apportare al codice, poiché la coerenza eventuale codice più complesso è necessario per rilevare possibili incoerenze tra funzioni di aggregazione e la necessità di implementare le azioni di compensazione.</span><span class="sxs-lookup"><span data-stu-id="9974f-245">And it depends on how much investment you are willing to make in your code, since eventual consistency requires more complex code in order to detect possible inconsistencies across aggregates and the need to implement compensatory actions.</span></span> <span data-ttu-id="9974f-246">Prendere in considerazione che se si esegue il commit delle modifiche per l'aggregazione originale e, successivamente, quando gli eventi inviati, si verifica un problema e i gestori eventi non è possibile eseguire il commit i relativi effetti collaterali, sarà necessario incoerenze tra funzioni di aggregazione.</span><span class="sxs-lookup"><span data-stu-id="9974f-246">Take into account that if you commit changes to the original aggregate and afterwards, when the events are being dispatched, there is an issue and the event handlers cannot commit their side effects, you will have inconsistencies between aggregates.</span></span>

<span data-ttu-id="9974f-247">Un modo per consentire le azioni di compensazione, è possibile archiviare gli eventi di dominio nelle tabelle di database aggiuntivi in modo che possono far parte della transazione originale.</span><span class="sxs-lookup"><span data-stu-id="9974f-247">A way to allow compensatory actions would be to store the domain events in additional database tables so they can be part of the original transaction.</span></span> <span data-ttu-id="9974f-248">Successivamente, è possibile usare un processo batch che rileva le incoerenze ed esegue le azioni di compensazione, confrontando l'elenco di eventi con lo stato corrente delle aggregazioni.</span><span class="sxs-lookup"><span data-stu-id="9974f-248">Afterwards, you could have a batch process that detects inconsistencies and runs compensatory actions by comparing the list of events with the current state of the aggregates.</span></span> <span data-ttu-id="9974f-249">Le azioni di compensazione fanno parte di un argomento di tipo complesso che richiederà l'analisi approfondita del lato, che include la discussione con l'utente di business e gli esperti di dominio.</span><span class="sxs-lookup"><span data-stu-id="9974f-249">The compensatory actions are part of a complex topic that will require deep analysis from your side, which includes discussing it with the business user and domain experts.</span></span>

<span data-ttu-id="9974f-250">In ogni caso, è possibile scegliere l'approccio che è necessario.</span><span class="sxs-lookup"><span data-stu-id="9974f-250">In any case, you can choose the approach you need.</span></span> <span data-ttu-id="9974f-251">Ma iniziale posticipata approccio-generazione degli eventi prima di eseguire il commit, in modo da utilizzare una singola transazione, è l'approccio più semplice quando si utilizza Entity Framework Core e un database relazionale.</span><span class="sxs-lookup"><span data-stu-id="9974f-251">But the initial deferred approach—raising the events before committing, so you use a single transaction—is the simplest approach when using EF Core and a relational database.</span></span> <span data-ttu-id="9974f-252">È più facile da implementare e in molti casi è valido.</span><span class="sxs-lookup"><span data-stu-id="9974f-252">It is easier to implement and valid in many business cases.</span></span> <span data-ttu-id="9974f-253">È anche l'approccio adottato nell'ordinamento microservizio in eShopOnContainers.</span><span class="sxs-lookup"><span data-stu-id="9974f-253">It is also the approach used in the ordering microservice in eShopOnContainers.</span></span>

<span data-ttu-id="9974f-254">Ma, come effettivamente inviare gli eventi ai relativi gestori eventi rispettivi?</span><span class="sxs-lookup"><span data-stu-id="9974f-254">But how do you actually dispatch those events to their respective event handlers?</span></span> <span data-ttu-id="9974f-255">Che cos'è il \_oggetto mediatore che viene visualizzato nell'esempio precedente?</span><span class="sxs-lookup"><span data-stu-id="9974f-255">What is the \_mediator object that you see in the previous example?</span></span> <span data-ttu-id="9974f-256">Che deve eseguire con le tecniche e gli elementi che è possibile utilizzare per eseguire il mapping tra gli eventi e i relativi gestori eventi.</span><span class="sxs-lookup"><span data-stu-id="9974f-256">That has to do with the techniques and artifacts you can use to map between events and their event handlers.</span></span>

### <a name="the-domain-event-dispatcher-mapping-from-events-to-event-handlers"></a><span data-ttu-id="9974f-257">Il dispatcher di eventi di dominio: mapping dagli eventi ai gestori di eventi</span><span class="sxs-lookup"><span data-stu-id="9974f-257">The domain event dispatcher: mapping from events to event handlers</span></span>

<span data-ttu-id="9974f-258">Quando si sarà in grado di inviare o pubblicare gli eventi, è necessario un tipo di elemento per la pubblicazione dell'evento in modo che ogni gestore correlati può accedervi e gli effetti collaterali di processo in base a tale evento.</span><span class="sxs-lookup"><span data-stu-id="9974f-258">Once you are able to dispatch or publish the events, you need some kind of artifact that will publish the event so that every related handler can get it and process side effects based on that event.</span></span>

<span data-ttu-id="9974f-259">Un approccio è un sistema di messaggistica reale o anche un bus di eventi, eventualmente in base a un bus di servizio anziché gli eventi in memoria.</span><span class="sxs-lookup"><span data-stu-id="9974f-259">One approach is a real messaging system or even an event bus, possibly based on a service bus as opposed to in-memory events.</span></span> <span data-ttu-id="9974f-260">Tuttavia, nel primo caso, messaggistica reale sarebbe eccessivi per l'elaborazione di eventi del dominio, poiché è sufficiente elaborare gli eventi all'interno dello stesso processo (ovvero, all'interno del livello di applicazione e del dominio stesso).</span><span class="sxs-lookup"><span data-stu-id="9974f-260">However, for the first case, real messaging would be overkill for processing domain events, since you just need to process those events within the same process (that is, within the same domain and application layer).</span></span>

<span data-ttu-id="9974f-261">Un altro modo per eseguire il mapping a più gestori eventi è tramite la registrazione di tipi in un contenitore di inversione di controllo in modo che è in grado di dedurre in modo dinamico dove inviare gli eventi.</span><span class="sxs-lookup"><span data-stu-id="9974f-261">Another way to map events to multiple event handlers is by using types registration in an IoC container so that you can dynamically infer where to dispatch the events.</span></span> <span data-ttu-id="9974f-262">In altre parole, è necessario conoscere i requisiti di gestori eventi per ottenere un evento specifico.</span><span class="sxs-lookup"><span data-stu-id="9974f-262">In other words, you need to know what event handlers need to get a specific event.</span></span> <span data-ttu-id="9974f-263">Nella figura 9-16 viene illustrato un approccio semplificato per tale.</span><span class="sxs-lookup"><span data-stu-id="9974f-263">Figure 9-16 shows a simplified approach for that.</span></span>

![](./media/image17.png)

<span data-ttu-id="9974f-264">**Nella figura 9-16**.</span><span class="sxs-lookup"><span data-stu-id="9974f-264">**Figure 9-16**.</span></span> <span data-ttu-id="9974f-265">Dispatcher di eventi di dominio usando IoC</span><span class="sxs-lookup"><span data-stu-id="9974f-265">Domain event dispatcher using IoC</span></span>

<span data-ttu-id="9974f-266">È possibile compilare tutti i plumbing e gli elementi per implementare tale approccio personalmente.</span><span class="sxs-lookup"><span data-stu-id="9974f-266">You can build all the plumbing and artifacts to implement that approach by yourself.</span></span> <span data-ttu-id="9974f-267">Tuttavia, è inoltre possibile utilizzare le librerie disponibili come [MediatR](https://github.com/jbogard/MediatR), che nel sistema l'Usa il contenitore di IoT.</span><span class="sxs-lookup"><span data-stu-id="9974f-267">However, you can also use available libraries like [MediatR](https://github.com/jbogard/MediatR), which underneath the covers uses your IoT container.</span></span> <span data-ttu-id="9974f-268">È possibile pertanto è utilizzare direttamente le interfacce predefinite e i metodi di pubblicazione/distribuzione dell'oggetto mediatore.</span><span class="sxs-lookup"><span data-stu-id="9974f-268">You can therefore directly use the predefined interfaces and the mediator object’s publish/dispatch methods.</span></span>

<span data-ttu-id="9974f-269">Nel codice, è innanzitutto necessario registrare i tipi di gestore di evento nel contenitore di inversione di controllo, come illustrato nell'esempio seguente:</span><span class="sxs-lookup"><span data-stu-id="9974f-269">In code, you first need to register the event handler types in your IoC container, as shown in the following example:</span></span>

```csharp
public class MediatorModule : Autofac.Module
{
    protected override void Load(ContainerBuilder builder)
    {
        // Other registrations ...
        // Register the DomainEventHandler classes (they implement
        // IAsyncNotificationHandler<>) in assembly holding the Domain Events
        builder.RegisterAssemblyTypes(
            typeof(ValidateOrAddBuyerAggregateWhenOrderStartedDomainEventHandler)
            .GetTypeInfo().Assembly)
            .Where(t => t.IsClosedTypeOf(typeof(IAsyncNotificationHandler<>)))
            .AsImplementedInterfaces();
        // Other registrations ...
    }
}
```

<span data-ttu-id="9974f-270">Il codice innanzitutto identifica l'assembly contenente i gestori di eventi di dominio, individuazione dell'assembly contenente i gestori (Usa typeof(ValidateOrAddBuyerAggregateWhenXxxx), ma è stato scelto un altro gestore eventi per individuare l'assembly).</span><span class="sxs-lookup"><span data-stu-id="9974f-270">The code first identifies the assembly that contains the domain event handlers by locating the assembly that holds any of the handlers (using typeof(ValidateOrAddBuyerAggregateWhenXxxx), but you could have chosen any other event handler to locate the assembly).</span></span> <span data-ttu-id="9974f-271">Poiché tutti i gestori di eventi implementano l'interfaccia IAsyncNotificationHandler, il codice quindi cerca solo i tipi e registra tutti i gestori eventi.</span><span class="sxs-lookup"><span data-stu-id="9974f-271">Since all the event handlers implement the IAsyncNotificationHandler interface, the code then just searches for those types and registers all the event handlers.</span></span>

### <a name="how-to-subscribe-to-domain-events"></a><span data-ttu-id="9974f-272">Come sottoscrivere gli eventi di dominio</span><span class="sxs-lookup"><span data-stu-id="9974f-272">How to subscribe to domain events</span></span>

<span data-ttu-id="9974f-273">Quando si utilizza MediatR, ogni gestore eventi deve utilizzare un tipo di evento che viene fornito nel parametro generico dell'interfaccia IAsyncNotificationHandler, come si può notare nel codice seguente:</span><span class="sxs-lookup"><span data-stu-id="9974f-273">When you use MediatR, each event handler must use an event type that is provided on the generic parameter of the IAsyncNotificationHandler interface, as you can see in the following code:</span></span>

```csharp
public class ValidateOrAddBuyerAggregateWhenOrderStartedDomainEventHandler
  : IAsyncNotificationHandler<OrderStartedDomainEvent>
```

<span data-ttu-id="9974f-274">In base alla relazione tra eventi e il gestore eventi, che può essere considerato la sottoscrizione, l'elemento MediatR può individuare tutti i gestori eventi per ogni evento e attivare ognuno di tali gestori eventi.</span><span class="sxs-lookup"><span data-stu-id="9974f-274">Based on the relationship between event and event handler, which can be considered the subscription, the MediatR artifact can discover all the event handlers for each event and trigger each of those event handlers.</span></span>

### <a name="how-to-handle-domain-events"></a><span data-ttu-id="9974f-275">Come gestire gli eventi di dominio</span><span class="sxs-lookup"><span data-stu-id="9974f-275">How to handle domain events</span></span>

<span data-ttu-id="9974f-276">Infine, il gestore dell'evento implementa in genere codice del livello applicazione che utilizza il repository di infrastruttura per ottenere le aggregazioni aggiuntive necessarie e di eseguire la logica di dominio effetto collaterale.</span><span class="sxs-lookup"><span data-stu-id="9974f-276">Finally, the event handler usually implements application layer code that uses infrastructure repositories to obtain the required additional aggregates and to execute side-effect domain logic.</span></span> <span data-ttu-id="9974f-277">Il codice seguente illustra un esempio.</span><span class="sxs-lookup"><span data-stu-id="9974f-277">The following code shows an example.</span></span>

```csharp
public class ValidateOrAddBuyerAggregateWhenOrderStartedDomainEventHandler
    : IAsyncNotificationHandler<OrderStartedDomainEvent>
{
    private readonly ILoggerFactory _logger;
    private readonly IBuyerRepository<Buyer> _buyerRepository;
    private readonly IIdentityService _identityService;
    public ValidateOrAddBuyerAggregateWhenOrderStartedDomainEventHandler(
        ILoggerFactory logger,
        IBuyerRepository<Buyer> buyerRepository,
        IIdentityService identityService)
    {
        // Parameter validations
        //...
    }

    public async Task Handle(OrderStartedDomainEvent orderStartedEvent)
    {
        var cardTypeId = (orderStartedEvent.CardTypeId != 0) ?
            orderStartedEvent.CardTypeId : 1;
        var userGuid = _identityService.GetUserIdentity();
        var buyer = await _buyerRepository.FindAsync(userGuid);
        bool buyerOriginallyExisted = (buyer == null) ? false : true;
        if (!buyerOriginallyExisted)
        {
            buyer = new Buyer(userGuid);
        }
        buyer.VerifyOrAddPaymentMethod(cardTypeId,
            $"Payment Method on {DateTime.UtcNow}",
            orderStartedEvent.CardNumber,
            orderStartedEvent.CardSecurityNumber,
            orderStartedEvent.CardHolderName,
            orderStartedEvent.CardExpiration,
            orderStartedEvent.Order.Id);
        var buyerUpdated = buyerOriginallyExisted ? _buyerRepository.Update(buyer) :
        _buyerRepository.Add(buyer);
        await _buyerRepository.UnitOfWork.SaveEntitiesAsync();
        // Logging code using buyerUpdated info, etc.
    }
}
```

<span data-ttu-id="9974f-278">Questo codice del gestore eventi viene considerato codice del livello applicazione, perché Usa il repository di infrastruttura, come spiegato nella sezione successiva nel livello di persistenza di infrastruttura.</span><span class="sxs-lookup"><span data-stu-id="9974f-278">This event handler code is considered application layer code because it uses infrastructure repositories, as explained in the next section on the infrastructure-persistence layer.</span></span> <span data-ttu-id="9974f-279">I gestori di eventi è possibile usare anche altri componenti dell'infrastruttura.</span><span class="sxs-lookup"><span data-stu-id="9974f-279">Event handlers could also use other infrastructure components.</span></span>

#### <a name="domain-events-can-generate-integration-events-to-be-published-outside-of-the-microservice-boundaries"></a><span data-ttu-id="9974f-280">Gli eventi di dominio possono generare eventi di integrazione da pubblicare all'esterno dei limiti microservizio</span><span class="sxs-lookup"><span data-stu-id="9974f-280">Domain events can generate integration events to be published outside of the microservice boundaries</span></span>

<span data-ttu-id="9974f-281">Infine, è importante ricordare che si potrebbe desiderare di eventi si propagano tra più microservizi.</span><span class="sxs-lookup"><span data-stu-id="9974f-281">Finally, is important to mention that you might sometimes want to propagate events across multiple microservices.</span></span> <span data-ttu-id="9974f-282">Che viene considerato un evento di integrazione e possono essere pubblicato tramite un bus di eventi da qualsiasi gestore di dominio specifico.</span><span class="sxs-lookup"><span data-stu-id="9974f-282">That is considered an integration event, and it could be published through an event bus from any specific domain event handler.</span></span>

## <a name="conclusions-on-domain-events"></a><span data-ttu-id="9974f-283">Conclusioni sugli eventi di dominio</span><span class="sxs-lookup"><span data-stu-id="9974f-283">Conclusions on domain events</span></span> 

<span data-ttu-id="9974f-284">Come indicato, utilizzare gli eventi di dominio per implementare in modo esplicito gli effetti collaterali delle modifiche all'interno del dominio.</span><span class="sxs-lookup"><span data-stu-id="9974f-284">As stated, use domain events to explicitly implement side effects of changes within your domain.</span></span> <span data-ttu-id="9974f-285">Per utilizzare terminologia DDD, utilizzare gli eventi di dominio per implementare in modo esplicito gli effetti collaterali in uno o più funzioni di aggregazione.</span><span class="sxs-lookup"><span data-stu-id="9974f-285">To use DDD terminology, use domain events to explicitly implement side effects across one or multiple aggregates.</span></span> <span data-ttu-id="9974f-286">Inoltre e per una migliore scalabilità e un minore impatto sui blocchi di database, utilizzare la coerenza eventuale tra funzioni di aggregazione all'interno dello stesso dominio.</span><span class="sxs-lookup"><span data-stu-id="9974f-286">Additionally, and for better scalability and less impact on database locks, use eventual consistency between aggregates within the same domain.</span></span>

#### <a name="additional-resources"></a><span data-ttu-id="9974f-287">Risorse aggiuntive</span><span class="sxs-lookup"><span data-stu-id="9974f-287">Additional resources</span></span>

-   <span data-ttu-id="9974f-288">**Greg Young. Che cos'è un evento di dominio? ** 
     [ *http://codebetter.com/gregyoung/2010/04/11/what-is-a-domain-event/*](http://codebetter.com/gregyoung/2010/04/11/what-is-a-domain-event/)</span><span class="sxs-lookup"><span data-stu-id="9974f-288">**Greg Young. What is a Domain Event?**
[*http://codebetter.com/gregyoung/2010/04/11/what-is-a-domain-event/*](http://codebetter.com/gregyoung/2010/04/11/what-is-a-domain-event/)</span></span>

-   <span data-ttu-id="9974f-289">**Jan Stenberg. Eventi del dominio e la coerenza eventuale**
    [*https://www.infoq.com/news/2015/09/domain-events-consistency*](https://www.infoq.com/news/2015/09/domain-events-consistency)</span><span class="sxs-lookup"><span data-stu-id="9974f-289">**Jan Stenberg. Domain Events and Eventual Consistency**
[*https://www.infoq.com/news/2015/09/domain-events-consistency*](https://www.infoq.com/news/2015/09/domain-events-consistency)</span></span>

-   <span data-ttu-id="9974f-290">**Jimmy Bogard. Un modello di eventi di dominio migliorato**
    [*https://lostechies.com/jimmybogard/2014/05/13/a-better-domain-events-pattern/*](https://lostechies.com/jimmybogard/2014/05/13/a-better-domain-events-pattern/)</span><span class="sxs-lookup"><span data-stu-id="9974f-290">**Jimmy Bogard. A better domain events pattern**
[*https://lostechies.com/jimmybogard/2014/05/13/a-better-domain-events-pattern/*](https://lostechies.com/jimmybogard/2014/05/13/a-better-domain-events-pattern/)</span></span>

-   <span data-ttu-id="9974f-291">**Vaughn Vernon. Efficace aggregazione progettazione parte II: Effettua aggregazioni lavoro insieme**
    [*http://dddcommunity.org/wp-content/uploads/files/pdf\_articoli/Vernon\_2011\_ 2. pdf*](http://dddcommunity.org/wp-content/uploads/files/pdf_articles/Vernon_2011_2.pdf)</span><span class="sxs-lookup"><span data-stu-id="9974f-291">**Vaughn Vernon. Effective Aggregate Design Part II: Making Aggregates Work Together**
[*http://dddcommunity.org/wp-content/uploads/files/pdf\_articles/Vernon\_2011\_2.pdf*](http://dddcommunity.org/wp-content/uploads/files/pdf_articles/Vernon_2011_2.pdf)</span></span>

-   <span data-ttu-id="9974f-292">**Jimmy Bogard. Il dominio rafforzare: eventi del dominio**
    *<https://lostechies.com/jimmybogard/2010/04/08/strengthening-your-domain-domain-events/>*</span><span class="sxs-lookup"><span data-stu-id="9974f-292">**Jimmy Bogard. Strengthening your domain: Domain Events**
*<https://lostechies.com/jimmybogard/2010/04/08/strengthening-your-domain-domain-events/> *</span></span>

-   <span data-ttu-id="9974f-293">**Tony Truong. Esempio di schema di eventi del dominio**
    [*http://www.tonytruong.net/domain-events-pattern-example/*](http://www.tonytruong.net/domain-events-pattern-example/)</span><span class="sxs-lookup"><span data-stu-id="9974f-293">**Tony Truong. Domain Events Pattern Example**
[*http://www.tonytruong.net/domain-events-pattern-example/*](http://www.tonytruong.net/domain-events-pattern-example/)</span></span>

-   <span data-ttu-id="9974f-294">**udi Dahan. Come creare completamente incapsulato i modelli di dominio**
    [*http://udidahan.com/2008/02/29/how-to-create-fully-encapsulated-domain-models/*](http://udidahan.com/2008/02/29/how-to-create-fully-encapsulated-domain-models/)</span><span class="sxs-lookup"><span data-stu-id="9974f-294">**Udi Dahan. How to create fully encapsulated Domain Models**
[*http://udidahan.com/2008/02/29/how-to-create-fully-encapsulated-domain-models/*](http://udidahan.com/2008/02/29/how-to-create-fully-encapsulated-domain-models/)</span></span>

-   <span data-ttu-id="9974f-295">**udi Dahan. Eventi di dominio e richiedere 2**
    [*http://udidahan.com/2008/08/25/domain-events-take-2/*](http://udidahan.com/2008/08/25/domain-events-take-2/%20)</span><span class="sxs-lookup"><span data-stu-id="9974f-295">**Udi Dahan. Domain Events – Take 2**
[*http://udidahan.com/2008/08/25/domain-events-take-2/*](http://udidahan.com/2008/08/25/domain-events-take-2/%20)</span></span>

-   <span data-ttu-id="9974f-296">**udi Dahan. Eventi del dominio: Salvation**
    [*http://udidahan.com/2009/06/14/domain-events-salvation/*](http://udidahan.com/2009/06/14/domain-events-salvation/)</span><span class="sxs-lookup"><span data-stu-id="9974f-296">**Udi Dahan. Domain Events – Salvation**
[*http://udidahan.com/2009/06/14/domain-events-salvation/*](http://udidahan.com/2009/06/14/domain-events-salvation/)</span></span>

-   <span data-ttu-id="9974f-297">**Jan Kronquist. Non pubblicare eventi di dominio, li restituiscono. ** 
     [ *https://blog.jayway.com/2013/06/20/dont-publish-domain-events-return-them/*](https://blog.jayway.com/2013/06/20/dont-publish-domain-events-return-them/)</span><span class="sxs-lookup"><span data-stu-id="9974f-297">**Jan Kronquist. Don't publish Domain Events, return them!**
[*https://blog.jayway.com/2013/06/20/dont-publish-domain-events-return-them/*](https://blog.jayway.com/2013/06/20/dont-publish-domain-events-return-them/)</span></span>

-   <span data-ttu-id="9974f-298">**Cesar de la Torre. Visual Studio gli eventi di dominio. Eventi di integrazione nelle architetture DDD e microservizi**
    [*https://blogs.msdn.microsoft.com/cesardelatorre/2017/02/07/domain-events-vs-integration-events-in-domain-driven-design-and-microservices-architectures/*](https://blogs.msdn.microsoft.com/cesardelatorre/2017/02/07/domain-events-vs-integration-events-in-domain-driven-design-and-microservices-architectures/)</span><span class="sxs-lookup"><span data-stu-id="9974f-298">**Cesar de la Torre. Domain Events vs. Integration Events in DDD and microservices architectures**
[*https://blogs.msdn.microsoft.com/cesardelatorre/2017/02/07/domain-events-vs-integration-events-in-domain-driven-design-and-microservices-architectures/*](https://blogs.msdn.microsoft.com/cesardelatorre/2017/02/07/domain-events-vs-integration-events-in-domain-driven-design-and-microservices-architectures/)</span></span>


>[!div class="step-by-step"]
<span data-ttu-id="9974f-299">[Precedente] (client-side-validation.md) [Avanti] (infrastruttura persistenza-livello design.md)</span><span class="sxs-lookup"><span data-stu-id="9974f-299">[Previous] (client-side-validation.md) [Next] (infrastructure-persistence-layer-design.md)</span></span>
