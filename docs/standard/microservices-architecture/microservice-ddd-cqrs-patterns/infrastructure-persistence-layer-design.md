---
title: Progettazione del livello di persistenza dell'infrastruttura
description: Informazioni su come progettare il livello di persistenza dell'infrastruttura.
author: CESARDELATORRE
ms.author: wiwagn
ms.date: 06/28/2017
ms.openlocfilehash: a0fcaead363e41f0dd02ed1e2ddfc90afb8d0c57
ms.sourcegitcommit: 4c158beee818c408d45a9609bfc06f209a523e22
ms.translationtype: HT
ms.contentlocale: it-IT
ms.lasthandoff: 07/03/2018
ms.locfileid: "37404473"
---
# <a name="designing-the-infrastructure-persistence-layer"></a><span data-ttu-id="4f8fc-103">Progettazione del livello di persistenza dell'infrastruttura</span><span class="sxs-lookup"><span data-stu-id="4f8fc-103">Designing the infrastructure persistence layer</span></span>

<span data-ttu-id="4f8fc-104">I componenti di persistenza dei dati forniscono l'accesso ai dati ospitati entro i limiti di un microservizio (vale a dire, il database di un microservizio).</span><span class="sxs-lookup"><span data-stu-id="4f8fc-104">Data persistence components provide access to the data hosted within the boundaries of a microservice (that is, a microservice’s database).</span></span> <span data-ttu-id="4f8fc-105">Contengono l'implementazione effettiva di componenti come repository e classi di [unità di lavoro](https://martinfowler.com/eaaCatalog/unitOfWork.html), ad esempio gli oggetti Entity Framework (EF) <xref:Microsoft.EntityFrameworkCore.DbContext> personalizzati.</span><span class="sxs-lookup"><span data-stu-id="4f8fc-105">They contain the actual implementation of components such as repositories and [Unit of Work](https://martinfowler.com/eaaCatalog/unitOfWork.html) classes, like custom Entity Framework (EF) <xref:Microsoft.EntityFrameworkCore.DbContext> objects.</span></span>

## <a name="the-repository-pattern"></a><span data-ttu-id="4f8fc-106">Schema repository</span><span class="sxs-lookup"><span data-stu-id="4f8fc-106">The Repository pattern</span></span>

<span data-ttu-id="4f8fc-107">I repository sono classi o componenti che incapsulano la logica necessaria per accedere alle origini dati.</span><span class="sxs-lookup"><span data-stu-id="4f8fc-107">Repositories are classes or components that encapsulate the logic required to access data sources.</span></span> <span data-ttu-id="4f8fc-108">Centralizzano la funzionalità di accesso ai dati comuni, migliorando la manutenibilità e il disaccoppiamento dell'infrastruttura o della tecnologia usata per accedere ai database dal livello del modello di dominio.</span><span class="sxs-lookup"><span data-stu-id="4f8fc-108">They centralize common data access functionality, providing better maintainability and decoupling the infrastructure or technology used to access databases from the domain model layer.</span></span> <span data-ttu-id="4f8fc-109">Se si usa un object-relational mapping (ORM) come Entity Framework, il codice da implementare viene semplificato grazie a LINQ e alla tipizzazione forte.</span><span class="sxs-lookup"><span data-stu-id="4f8fc-109">If you use an object-relational mapping (ORM) like Entity Framework, the code that must be implemented is simplified, thanks to LINQ and strong typing.</span></span> <span data-ttu-id="4f8fc-110">In questo modo è possibile concentrarsi sulla logica di persistenza dei dati anziché sulle attività di plumbing per l'accesso ai dati.</span><span class="sxs-lookup"><span data-stu-id="4f8fc-110">This lets you focus on the data persistence logic rather than on data access plumbing.</span></span>

<span data-ttu-id="4f8fc-111">Lo schema Repository è una modalità di utilizzo di un'origine dati ben documentata.</span><span class="sxs-lookup"><span data-stu-id="4f8fc-111">The Repository pattern is a well-documented way of working with a data source.</span></span> <span data-ttu-id="4f8fc-112">Nel libro [Patterns of Enterprise Application Architecture](https://www.amazon.com/Patterns-Enterprise-Application-Architecture-Martin/dp/0321127420/), Martin Fowler descrive un repository come segue:</span><span class="sxs-lookup"><span data-stu-id="4f8fc-112">In the book [Patterns of Enterprise Application Architecture](https://www.amazon.com/Patterns-Enterprise-Application-Architecture-Martin/dp/0321127420/), Martin Fowler describes a repository as follows:</span></span>

> <span data-ttu-id="4f8fc-113">Un repository esegue le attività di intermediario tra i livelli del modello di dominio e il mapping dei dati, agendo in modo analogo a un set di oggetti di dominio in memoria.</span><span class="sxs-lookup"><span data-stu-id="4f8fc-113">A repository performs the tasks of an intermediary between the domain model layers and data mapping, acting in a similar way to a set of domain objects in memory.</span></span> <span data-ttu-id="4f8fc-114">Gli oggetti client compilare query in modo dichiarativo e le inviano ai repository per le risposte.</span><span class="sxs-lookup"><span data-stu-id="4f8fc-114">Client objects declaratively build queries and send them to the repositories for answers.</span></span> <span data-ttu-id="4f8fc-115">Concettualmente, un repository incapsula un set di oggetti archiviati nel database e le operazioni che possono essere eseguite sugli oggetti stessi, offrendo un modo che più si avvicina al livello di persistenza.</span><span class="sxs-lookup"><span data-stu-id="4f8fc-115">Conceptually, a repository encapsulates a set of objects stored in the database and operations that can be performed on them, providing a way that is closer to the persistence layer.</span></span> <span data-ttu-id="4f8fc-116">I repository, inoltre, supportano lo scopo di separare chiaramente e in una sola direzione la dipendenza tra il dominio di lavoro e l'allocazione o il mapping dei dati.</span><span class="sxs-lookup"><span data-stu-id="4f8fc-116">Repositories, also, support the purpose of separating, clearly and in one direction, the dependency between the work domain and the data allocation or mapping.</span></span>

### <a name="define-one-repository-per-aggregate"></a><span data-ttu-id="4f8fc-117">Definire un repository per ogni aggregazione</span><span class="sxs-lookup"><span data-stu-id="4f8fc-117">Define one repository per aggregate</span></span>

<span data-ttu-id="4f8fc-118">Per ogni aggregazione o radice di aggregazione è necessario creare una classe di repository.</span><span class="sxs-lookup"><span data-stu-id="4f8fc-118">For each aggregate or aggregate root, you should create one repository class.</span></span> <span data-ttu-id="4f8fc-119">In un microservizio che si basa su schemi progettuali basati su dominio (DDD), l'unico canale che è necessario usare per aggiornare il database deve essere il repository,</span><span class="sxs-lookup"><span data-stu-id="4f8fc-119">In a microservice based on domain-driven design (DDD) patterns, the only channel you should use to update the database should be the repositories.</span></span> <span data-ttu-id="4f8fc-120">perché ha una relazione uno-a-uno con la radice di aggregazione, che controlla le invarianti di aggregazione e la coerenza delle transazioni.</span><span class="sxs-lookup"><span data-stu-id="4f8fc-120">This is because they have a one-to-one relationship with the aggregate root, which controls the aggregate’s invariants and transactional consistency.</span></span> <span data-ttu-id="4f8fc-121">È possibile eseguire query sul database tramite altri canali (seguendo un approccio CQRS), perché le query non modificano lo stato del database.</span><span class="sxs-lookup"><span data-stu-id="4f8fc-121">It's okay to query the database through other channels (as you can do following a CQRS approach), because queries don't change the state of the database.</span></span> <span data-ttu-id="4f8fc-122">Tuttavia, l'area transazionale, ovvero gli aggiornamenti, deve sempre essere controllata dai repository e dalle radici di aggregazione.</span><span class="sxs-lookup"><span data-stu-id="4f8fc-122">However, the transactional area (that is, the updates) must always be controlled by the repositories and the aggregate roots.</span></span>

<span data-ttu-id="4f8fc-123">In pratica, un repository consente di popolare i dati in memoria che provengono dal database sotto forma di entità di dominio.</span><span class="sxs-lookup"><span data-stu-id="4f8fc-123">Basically, a repository allows you to populate data in memory that comes from the database in the form of the domain entities.</span></span> <span data-ttu-id="4f8fc-124">Quando le entità sono in memoria, è possibile modificarle e quindi salvarle in modo permanente nel database tramite le transazioni.</span><span class="sxs-lookup"><span data-stu-id="4f8fc-124">Once the entities are in memory, they can be changed and then persisted back to the database through transactions.</span></span>

<span data-ttu-id="4f8fc-125">Come notato in precedenza, se si usa lo schema architetturale CQS/CQRS, le query iniziali verranno eseguite da query secondarie all'esterno del modello di dominio, eseguite da semplici istruzioni SQL con Dapper.</span><span class="sxs-lookup"><span data-stu-id="4f8fc-125">As noted earlier, if you're using the CQS/CQRS architectural pattern, the initial queries are performed by side queries out of the domain model, performed by simple SQL statements using Dapper.</span></span> <span data-ttu-id="4f8fc-126">Questo approccio è molto più flessibile dei repository perché è possibile eseguire query e join di tutte le tabelle necessarie, e tali query non sono limitate da regole dalle aggregazioni.</span><span class="sxs-lookup"><span data-stu-id="4f8fc-126">This approach is much more flexible than repositories because you can query and join any tables you need, and these queries aren't restricted by rules from the aggregates.</span></span> <span data-ttu-id="4f8fc-127">Tali dati verranno inviati al livello di presentazione o all'app client.</span><span class="sxs-lookup"><span data-stu-id="4f8fc-127">That data goes to the presentation layer or client app.</span></span>

<span data-ttu-id="4f8fc-128">Se l'utente apporta modifiche, i dati da aggiornare proverranno dal livello di presentazione o dall'app client al livello di applicazione (ad esempio, un servizio Web API).</span><span class="sxs-lookup"><span data-stu-id="4f8fc-128">If the user makes changes, the data to be updated comes from the client app or presentation layer to the application layer (such as a Web API service).</span></span> <span data-ttu-id="4f8fc-129">Quando si riceve un comando con dati in un gestore dei comandi, usare i repository per ottenere i dati da aggiornare dal database.</span><span class="sxs-lookup"><span data-stu-id="4f8fc-129">When you receive a command with data in a command handler, you use repositories to get the data you want to update from the database.</span></span> <span data-ttu-id="4f8fc-130">È possibile aggiornarli in memoria con le informazioni passate con i comandi e quindi aggiungere o aggiornare i dati (entità di dominio) nel database tramite una transazione.</span><span class="sxs-lookup"><span data-stu-id="4f8fc-130">You update it in memory with the information passed with the commands, and you then add or update the data (domain entities) in the database through a transaction.</span></span>

<span data-ttu-id="4f8fc-131">Tenere presente che deve essere definito un solo repository per ogni radice di aggregazione, come illustrato nella figura 9-17.</span><span class="sxs-lookup"><span data-stu-id="4f8fc-131">Remember that only one repository should be defined for each aggregate root, as shown in Figure 9-17.</span></span> <span data-ttu-id="4f8fc-132">Per raggiungere l'obiettivo della radice dell'aggregazione per mantenere la coerenza delle transazioni tra tutti gli oggetti all'interno dell'aggregazione, è consigliabile non creare mai un repository per ogni tabella nel database.</span><span class="sxs-lookup"><span data-stu-id="4f8fc-132">To achieve the goal of the aggregate root to maintain transactional consistency between all the objects within the aggregate, you should never create a repository for each table in the database.</span></span>

![](./media/image18.png)

<span data-ttu-id="4f8fc-133">**Figura 9-17**.</span><span class="sxs-lookup"><span data-stu-id="4f8fc-133">**Figure 9-17**.</span></span> <span data-ttu-id="4f8fc-134">Relazione tra repository, aggregazioni e tabelle del database</span><span class="sxs-lookup"><span data-stu-id="4f8fc-134">The relationship between repositories, aggregates, and database tables</span></span>

### <a name="enforcing-one-aggregate-root-per-repository"></a><span data-ttu-id="4f8fc-135">Applicazione di una radice di aggregazione per ogni repository</span><span class="sxs-lookup"><span data-stu-id="4f8fc-135">Enforcing one aggregate root per repository</span></span>

<span data-ttu-id="4f8fc-136">Può essere utile per implementare la progettazione del repository in modo che venga applicata la regola che solo le radici di aggregazione devono contenere repository.</span><span class="sxs-lookup"><span data-stu-id="4f8fc-136">It can be valuable to implement your repository design in such a way that it enforces the rule that only aggregate roots should have repositories.</span></span> <span data-ttu-id="4f8fc-137">È possibile creare un tipo di repository generico o di base che limita il tipo di entità usate per assicurarsi di avere l'interfaccia dei marcatori `IAggregateRoot`.</span><span class="sxs-lookup"><span data-stu-id="4f8fc-137">You can create a generic or base repository type that constrains the type of entities it works with to ensure they have the `IAggregateRoot` marker interface.</span></span>

<span data-ttu-id="4f8fc-138">Di conseguenza, ogni classe di repository implementata a livello infrastruttura implementa il proprio contratto o interfaccia, come illustrato nel codice seguente:</span><span class="sxs-lookup"><span data-stu-id="4f8fc-138">Thus, each repository class implemented at the infrastructure layer implements its own contract or interface, as shown in the following code:</span></span>

```csharp
namespace Microsoft.eShopOnContainers.Services.Ordering.Infrastructure.Repositories
{
    public class OrderRepository : IOrderRepository
    {
      // ...
    }
}
```

<span data-ttu-id="4f8fc-139">Ogni interfaccia specifica del repository implementa l'interfaccia IRepository generica:</span><span class="sxs-lookup"><span data-stu-id="4f8fc-139">Each specific repository interface implements the generic IRepository interface:</span></span>

```csharp
public interface IOrderRepository : IRepository<Order>
{
    Order Add(Order order);
    // ...
}
```

<span data-ttu-id="4f8fc-140">Tuttavia, un modo migliore perché il codice applichi la convenzione secondo cui ogni repository è correlato a un singolo aggregato consiste nell'implementare un tipo di repository generico.</span><span class="sxs-lookup"><span data-stu-id="4f8fc-140">However, a better way to have the code enforce the convention that each repository is related to a single aggregate is to implement a generic repository type.</span></span> <span data-ttu-id="4f8fc-141">In questo modo è evidente che si sta usando un repository per un aggregato specifico.</span><span class="sxs-lookup"><span data-stu-id="4f8fc-141">That way, it's explicit that you're using a repository to target a specific aggregate.</span></span> <span data-ttu-id="4f8fc-142">A tale scopo, è possibile implementare un'interfaccia di base `IRepository` generica, come illustrato nel codice seguente:</span><span class="sxs-lookup"><span data-stu-id="4f8fc-142">That can be easily done by implementing a generic `IRepository` base interface, as in the following code:</span></span>

```csharp
public interface IRepository<T> where T : IAggregateRoot
{
    //....
}
```

### <a name="the-repository-pattern-makes-it-easier-to-test-your-application-logic"></a><span data-ttu-id="4f8fc-143">Lo schema Repository rende più semplice testare la logica dell'applicazione</span><span class="sxs-lookup"><span data-stu-id="4f8fc-143">The Repository pattern makes it easier to test your application logic</span></span>

<span data-ttu-id="4f8fc-144">Lo schema Repository consente di testare facilmente l'applicazione con gli unit test.</span><span class="sxs-lookup"><span data-stu-id="4f8fc-144">The Repository pattern allows you to easily test your application with unit tests.</span></span> <span data-ttu-id="4f8fc-145">Tenere presente che gli unit test testano solo il codice, non l'infrastruttura, in modo che le astrazioni dei repository consentono di raggiungere più facilmente tale obiettivo.</span><span class="sxs-lookup"><span data-stu-id="4f8fc-145">Remember that unit tests only test your code, not infrastructure, so the repository abstractions make it easier to achieve that goal.</span></span>

<span data-ttu-id="4f8fc-146">Come indicato in una sezione precedente, è consigliabile definire e inserire le interfacce di repository nel livello del modello di dominio in modo tale che il livello dell'applicazione, come un microservizio API Web, non dipenda direttamente dal livello infrastruttura in cui sono state implementate le classi di repository effettive.</span><span class="sxs-lookup"><span data-stu-id="4f8fc-146">As noted in an earlier section, it's recommended that you define and place the repository interfaces in the domain model layer so the application layer, such as your Web API microservice, doesn't depend directly on the infrastructure layer where you've implemented the actual repository classes.</span></span> <span data-ttu-id="4f8fc-147">In questo modo e grazie all'uso dell'inserimento di dipendenze nei controller dell'API Web, è possibile implementare repository fittizi che restituiscono dati falsi anziché i dati del database.</span><span class="sxs-lookup"><span data-stu-id="4f8fc-147">By doing this and using Dependency Injection in the controllers of your Web API, you can implement mock repositories that return fake data instead of data from the database.</span></span> <span data-ttu-id="4f8fc-148">Questo approccio disaccoppiato consente di creare ed eseguire unit test che possono testare solo la logica dell'applicazione senza richiedere la connettività al database.</span><span class="sxs-lookup"><span data-stu-id="4f8fc-148">This decoupled approach allows you to create and run unit tests that can test just the logic of your application without requiring connectivity to the database.</span></span>

<span data-ttu-id="4f8fc-149">Le connessioni ai database possono non riuscire e, cosa ancora più importante, l'esecuzione di centinaia di test in un database è sconsigliata per due motivi.</span><span class="sxs-lookup"><span data-stu-id="4f8fc-149">Connections to databases can fail and, more importantly, running hundreds of tests against a database is bad for two reasons.</span></span> <span data-ttu-id="4f8fc-150">In primo luogo, può richiedere molto tempo a causa dell'elevato numero di test.</span><span class="sxs-lookup"><span data-stu-id="4f8fc-150">First, it can take a long time because of the large number of tests.</span></span> <span data-ttu-id="4f8fc-151">In secondo luogo, i record del database potrebbero cambiare e influire sui risultati dei test, in modo che potrebbe non essere coerenti.</span><span class="sxs-lookup"><span data-stu-id="4f8fc-151">Second, the database records might change and impact the results of your tests, so that they might not be consistent.</span></span> <span data-ttu-id="4f8fc-152">I test sui database non sono unit test, ma test di integrazione.</span><span class="sxs-lookup"><span data-stu-id="4f8fc-152">Testing against the database isn't a unit test but an integration test.</span></span> <span data-ttu-id="4f8fc-153">È consigliabile avere molti unit test che vengono eseguiti rapidamente ma pochi test di integrazione sui database.</span><span class="sxs-lookup"><span data-stu-id="4f8fc-153">You should have many unit tests running fast, but fewer integration tests against the databases.</span></span>

<span data-ttu-id="4f8fc-154">In termini di separazione delle problematiche per gli unit test, la logica opera sulle entità di dominio in memoria.</span><span class="sxs-lookup"><span data-stu-id="4f8fc-154">In terms of separation of concerns for unit tests, your logic operates on domain entities in memory.</span></span> <span data-ttu-id="4f8fc-155">Si presuppone che la classe di repository abbia usato queste ultime.</span><span class="sxs-lookup"><span data-stu-id="4f8fc-155">It assumes the repository class has delivered those.</span></span> <span data-ttu-id="4f8fc-156">Una volta che la logica modifica le entità di dominio, si presuppone che la classe di repository le archivi in modo corretto.</span><span class="sxs-lookup"><span data-stu-id="4f8fc-156">Once your logic modifies the domain entities, it assumes the repository class will store them correctly.</span></span> <span data-ttu-id="4f8fc-157">Il punto importante consiste nel creare unit test su un modello di dominio e la relativa logica di dominio.</span><span class="sxs-lookup"><span data-stu-id="4f8fc-157">The important point here is to create unit tests against your domain model and its domain logic.</span></span> <span data-ttu-id="4f8fc-158">Le radici di aggregazione sono i limiti principali della coerenza in DDD.</span><span class="sxs-lookup"><span data-stu-id="4f8fc-158">Aggregate roots are the main consistency boundaries in DDD.</span></span>

### <a name="the-difference-between-the-repository-pattern-and-the-legacy-data-access-class-dal-class-pattern"></a><span data-ttu-id="4f8fc-159">Differenza tra lo schema Repository e lo schema legacy Data Access class (DAL class)</span><span class="sxs-lookup"><span data-stu-id="4f8fc-159">The difference between the Repository pattern and the legacy Data Access class (DAL class) pattern</span></span>

<span data-ttu-id="4f8fc-160">Un oggetto di accesso ai dati esegue direttamente le operazioni di persistenza e accesso ai dati su un archivio.</span><span class="sxs-lookup"><span data-stu-id="4f8fc-160">A data access object directly performs data access and persistence operations against storage.</span></span> <span data-ttu-id="4f8fc-161">Un repository contrassegna i dati con le operazioni da eseguire nella memoria di un oggetto unità di lavoro (ad esempio, EF quando si usa la classe <xref:Microsoft.EntityFrameworkCore.DbContext>), ma questi aggiornamenti non vengono eseguiti immediatamente.</span><span class="sxs-lookup"><span data-stu-id="4f8fc-161">A repository marks the data with the operations you want to perform in the memory of a unit of work object (as in EF when using the <xref:Microsoft.EntityFrameworkCore.DbContext> class), but these updates aren't performed immediately.</span></span>

<span data-ttu-id="4f8fc-162">Per unità di lavoro si intende una singola transazione che coinvolge più operazioni di inserimento, aggiornamento o eliminazione.</span><span class="sxs-lookup"><span data-stu-id="4f8fc-162">A unit of work is referred to as a single transaction that involves multiple insert, update, or delete operations.</span></span> <span data-ttu-id="4f8fc-163">In altre parole, significa che per un'azione utente specifica, come ad esempio, la registrazione in un sito Web, tutte le transazioni di inserimento, aggiornamento ed eliminazione vengono gestite in un'unica transazione.</span><span class="sxs-lookup"><span data-stu-id="4f8fc-163">In simple terms, it means that for a specific user action, such as a registration on a website, all the insert, update, and delete transactions are handled in a single transaction.</span></span> <span data-ttu-id="4f8fc-164">Questa procedura è più efficiente rispetto alla gestione di più transazioni di database in maniera più frammentata.</span><span class="sxs-lookup"><span data-stu-id="4f8fc-164">This is more efficient than handling multiple database transactions in a chattier way.</span></span>

<span data-ttu-id="4f8fc-165">Queste varie operazioni di persistenza vengono eseguite in un secondo momento in un'unica azione quando indicato dal codice a livello dell'applicazione.</span><span class="sxs-lookup"><span data-stu-id="4f8fc-165">These multiple persistence operations are performed later in a single action when your code from the application layer commands it.</span></span> <span data-ttu-id="4f8fc-166">La decisione sull'applicazione delle modifiche in memoria all'archiviazione effettiva dei database si basa in genere sullo [schema Unit of Work](https://martinfowler.com/eaaCatalog/unitOfWork.html).</span><span class="sxs-lookup"><span data-stu-id="4f8fc-166">The decision about applying the in-memory changes to the actual database storage is typically based on the [Unit of Work pattern](https://martinfowler.com/eaaCatalog/unitOfWork.html).</span></span> <span data-ttu-id="4f8fc-167">In EF lo schema Unit of Work viene implementato come <xref:Microsoft.EntityFrameworkCore.DbContext>.</span><span class="sxs-lookup"><span data-stu-id="4f8fc-167">In EF, the Unit of Work pattern is implemented as the <xref:Microsoft.EntityFrameworkCore.DbContext>.</span></span>

<span data-ttu-id="4f8fc-168">In molti casi, questo schema o il modo di applicare le operazioni nell'archivio può migliorare le prestazioni dell'applicazione riducendo il rischio di incoerenze.</span><span class="sxs-lookup"><span data-stu-id="4f8fc-168">In many cases, this pattern or way of applying operations against the storage can increase application performance and reduce the possibility of inconsistencies.</span></span> <span data-ttu-id="4f8fc-169">Inoltre, riduce il blocco delle transazioni nelle tabelle del database, perché il commit di tutte le operazioni previste viene eseguito come parte di un'unica transazione.</span><span class="sxs-lookup"><span data-stu-id="4f8fc-169">It also reduces transaction blocking in the database tables, because all the intended operations are committed as part of one transaction.</span></span> <span data-ttu-id="4f8fc-170">Questo approccio è molto più efficiente rispetto all'esecuzione di molte operazioni isolate sul database.</span><span class="sxs-lookup"><span data-stu-id="4f8fc-170">This is more efficient in comparison to executing many isolated operations against the database.</span></span> <span data-ttu-id="4f8fc-171">Pertanto, l'ORM selezionato è in grado di ottimizzare l'esecuzione nel database raggruppando le varie azioni di aggiornamento all'interno della stessa transazione, anziché eseguire più transazioni separate di dimensioni inferiori.</span><span class="sxs-lookup"><span data-stu-id="4f8fc-171">Therefore, the selected ORM can optimize the execution against the database by grouping several update actions within the same transaction, as opposed to many small and separate transaction executions.</span></span>

### <a name="repositories-shouldnt-be-mandatory"></a><span data-ttu-id="4f8fc-172">I repository non devono essere obbligatori</span><span class="sxs-lookup"><span data-stu-id="4f8fc-172">Repositories shouldn't be mandatory</span></span>

<span data-ttu-id="4f8fc-173">I repository personalizzati sono utili per i motivi citati in precedenza e rappresentano l'approccio usato per il microservizio degli ordini in eShopOnContainers.</span><span class="sxs-lookup"><span data-stu-id="4f8fc-173">Custom repositories are useful for the reasons cited earlier, and that is the approach for the ordering microservice in eShopOnContainers.</span></span> <span data-ttu-id="4f8fc-174">Tuttavia, non è uno schema essenziale da implementare in una progettazione DDD o persino nello sviluppo generale in .NET.</span><span class="sxs-lookup"><span data-stu-id="4f8fc-174">However, it isn't an essential pattern to implement in a DDD design or even in general .NET development.</span></span>

<span data-ttu-id="4f8fc-175">Ad esempio, Jimmy Bogard, quando ha fornito un feedback diretto per questa guida, ha affermato quanto segue:</span><span class="sxs-lookup"><span data-stu-id="4f8fc-175">For instance, Jimmy Bogard, when providing direct feedback for this guide, said the following:</span></span>

> <span data-ttu-id="4f8fc-176">Questo probabilmente sarà il feedback più importante.</span><span class="sxs-lookup"><span data-stu-id="4f8fc-176">This’ll probably be my biggest feedback.</span></span> <span data-ttu-id="4f8fc-177">Non sono proprio un fan dei repository, soprattutto perché nascondono i dettagli importanti del meccanismo di persistenza sottostante.</span><span class="sxs-lookup"><span data-stu-id="4f8fc-177">I’m really not a fan of repositories, mainly because they hide the important details of the underlying persistence mechanism.</span></span> <span data-ttu-id="4f8fc-178">Questo è anche il motivo per cui usare MediatR per i comandi.</span><span class="sxs-lookup"><span data-stu-id="4f8fc-178">It’s why I go for MediatR for commands, too.</span></span> <span data-ttu-id="4f8fc-179">È possibile sfruttare tutte le potenzialità del livello di persistenza e spostare tutto il comportamento del dominio nelle radici di aggregazione.</span><span class="sxs-lookup"><span data-stu-id="4f8fc-179">I can use the full power of the persistence layer, and push all that domain behavior into my aggregate roots.</span></span> <span data-ttu-id="4f8fc-180">In genere non si vogliono simulare i repository ma avere un test di integrazione con il componente reale.</span><span class="sxs-lookup"><span data-stu-id="4f8fc-180">I don’t usually want to mock my repositories – I still need to have that integration test with the real thing.</span></span> <span data-ttu-id="4f8fc-181">Usare CQRS significa che i repository non sono più necessari.</span><span class="sxs-lookup"><span data-stu-id="4f8fc-181">Going CQRS meant that we didn’t really have a need for repositories any more.</span></span>

<span data-ttu-id="4f8fc-182">I repository sono utili ma non fondamentali per DDD come lo sono lo schema Aggregate e il modello di dominio avanzato.</span><span class="sxs-lookup"><span data-stu-id="4f8fc-182">Repositories are useful, but they aren't critical for your DDD, in the way that the Aggregate pattern and rich domain model are.</span></span> <span data-ttu-id="4f8fc-183">Pertanto, usare lo schema Repository se si ritiene opportuno.</span><span class="sxs-lookup"><span data-stu-id="4f8fc-183">Therefore, use the Repository pattern or not, as you see fit.</span></span>

## <a name="the-specification-pattern"></a><span data-ttu-id="4f8fc-184">Schema Specification</span><span class="sxs-lookup"><span data-stu-id="4f8fc-184">The Specification pattern</span></span>

<span data-ttu-id="4f8fc-185">Lo schema Specification (il cui nome completo è schema Query-specification) è un DDD concepito come punto in cui è possibile inserire la definizione di una query con logica facoltativa di ordinamento e paging.</span><span class="sxs-lookup"><span data-stu-id="4f8fc-185">The specification pattern (its full name would be Query-specification pattern) is a DDD pattern designed as the place where you can put the definition of a query with optional sorting and paging logic.</span></span>

<span data-ttu-id="4f8fc-186">Lo schema Specification consente di definire una query in un oggetto.</span><span class="sxs-lookup"><span data-stu-id="4f8fc-186">The specification pattern defines a query in an object.</span></span> <span data-ttu-id="4f8fc-187">Per poter incapsulare una query di paging che cerca alcuni prodotti, ad esempio, è possibile creare una specifica `PagedProduct` che accetta i parametri di input necessari, ad esempio `pageNumber`, `pageSize`, `filter` e così via. In questo modo, qualsiasi metodo di repository (in genere un overload List()) accetterà un elemento `ISpecification` ed eseguirà la query in base a tale specifica.</span><span class="sxs-lookup"><span data-stu-id="4f8fc-187">For example, to encapsulate a paged query that searches for some products, you can create a `PagedProduct` specification that takes the necessary input parameters, such as `pageNumber`, `pageSize`, `filter`, etc. Then, within any Repository method (usually a List() overload), it'd accept an `ISpecification` and run the expected query based on that specification.</span></span>

<span data-ttu-id="4f8fc-188">Esistono diversi vantaggi di questo approccio:</span><span class="sxs-lookup"><span data-stu-id="4f8fc-188">There are several benefits to this approach:</span></span>

- <span data-ttu-id="4f8fc-189">La specifica ha un nome (anziché solo una serie di espressioni LINQ) che è possibile usare.</span><span class="sxs-lookup"><span data-stu-id="4f8fc-189">The specification has a name (as opposed to just a bunch of LINQ expressions) that you can discuss about.</span></span>

- <span data-ttu-id="4f8fc-190">È possibile eseguire uno unit test della specifica in isolamento per assicurarsi che sia corretta.</span><span class="sxs-lookup"><span data-stu-id="4f8fc-190">The specification can be unit tested in isolation to ensure it's right.</span></span> <span data-ttu-id="4f8fc-191">La specifica può anche essere facilmente riusata se è necessario un comportamento simile.</span><span class="sxs-lookup"><span data-stu-id="4f8fc-191">It can also easily be reused if you need similar behavior.</span></span> <span data-ttu-id="4f8fc-192">Ad esempio, in un'azione di visualizzazione MVC e in un'azione di API Web, nonché in diversi servizi.</span><span class="sxs-lookup"><span data-stu-id="4f8fc-192">For example, on an MVC View action and a Web API action, as well as in various services.</span></span>

- <span data-ttu-id="4f8fc-193">Una specifica può essere usata anche per descrivere la forma dei dati da restituire, in modo che le query possano restituire solo i dati necessari.</span><span class="sxs-lookup"><span data-stu-id="4f8fc-193">A specification can also be used to describe the shape of the data to be returned, so that queries can return just the data they required.</span></span> <span data-ttu-id="4f8fc-194">In tal modo si elimina la necessità del caricamento lazy nelle applicazioni Web, che non è in genere consigliabile, consentendo di non congestionare le implementazioni dei repository con questi dettagli.</span><span class="sxs-lookup"><span data-stu-id="4f8fc-194">This eliminates the need for lazy loading in web applications, which is usually not recommended, and helps keep repository implementations from becoming cluttered with these details.</span></span>

<span data-ttu-id="4f8fc-195">Un esempio di interfaccia di specifica generica è il codice seguente tratto da [eShopOnWeb](https://github.com/dotnet-architecture/eShopOnWeb).</span><span class="sxs-lookup"><span data-stu-id="4f8fc-195">An example of a generic specification interface is the following code from [eShopOnWeb](https://github.com/dotnet-architecture/eShopOnWeb).</span></span>

```csharp
// https://github.com/dotnet-architecture/eShopOnWeb
public interface ISpecification<T>
{
    Expression<Func<T, bool>> Criteria { get; }
    List<Expression<Func<T, object>>> Includes { get; }
    List<string> IncludeStrings { get; }
}
```

<span data-ttu-id="4f8fc-196">Le sezioni successive illustrano come implementare lo schema Specification con EF Core 2.x e come usarlo da qualsiasi classe di repository.</span><span class="sxs-lookup"><span data-stu-id="4f8fc-196">The upcoming sections explain how to implement the specification pattern with EF Core 2.x and how to use it from any Repository class.</span></span>

> [!IMPORTANT]
> <span data-ttu-id="4f8fc-197">Lo schema Specification è uno schema precedente che può essere implementato in molti modi diversi, come indicato nelle risorse aggiuntive seguenti.</span><span class="sxs-lookup"><span data-stu-id="4f8fc-197">The specification pattern is an old pattern that can be implemented in many different ways, as in the following additional resources.</span></span> <span data-ttu-id="4f8fc-198">Come criterio/idea, è opportuno conoscere gli approcci precedenti ma tenere presente che le implementazioni precedenti non sfruttano le funzionalità moderne del linguaggio come Linq e le espressioni.</span><span class="sxs-lookup"><span data-stu-id="4f8fc-198">As a pattern/idea, older approaches are good to know, but beware of older implementations that are not taking advantage of modern language capabilities like Linq and expressions.</span></span>

## <a name="additional-resources"></a><span data-ttu-id="4f8fc-199">Risorse aggiuntive</span><span class="sxs-lookup"><span data-stu-id="4f8fc-199">Additional resources</span></span>

### <a name="the-repository-pattern"></a><span data-ttu-id="4f8fc-200">Schema repository</span><span class="sxs-lookup"><span data-stu-id="4f8fc-200">The Repository pattern</span></span>

- <span data-ttu-id="4f8fc-201">**Schema repository**
  [https://deviq.com/repository-pattern/](https://deviq.com/repository-pattern/)</span><span class="sxs-lookup"><span data-stu-id="4f8fc-201">**The Repository pattern**
[https://deviq.com/repository-pattern/](https://deviq.com/repository-pattern/)</span></span>

- <span data-ttu-id="4f8fc-202">**Edward Hieatt and Rob Mee. Schema repository.**
  [_https://martinfowler.com/eaaCatalog/repository.html_](https://martinfowler.com/eaaCatalog/repository.html)</span><span class="sxs-lookup"><span data-stu-id="4f8fc-202">**Edward Hieatt and Rob Mee. Repository pattern.**
[_https://martinfowler.com/eaaCatalog/repository.html_](https://martinfowler.com/eaaCatalog/repository.html)</span></span>

- <span data-ttu-id="4f8fc-203">**Schema repository**
  [_https://docs.microsoft.com/previous-versions/msp-n-p/ff649690(v=pandp.10)_](https://docs.microsoft.com/previous-versions/msp-n-p/ff649690(v=pandp.10))</span><span class="sxs-lookup"><span data-stu-id="4f8fc-203">**The Repository pattern**
[_https://docs.microsoft.com/previous-versions/msp-n-p/ff649690(v=pandp.10)_](https://docs.microsoft.com/previous-versions/msp-n-p/ff649690(v=pandp.10))</span></span>

- <span data-ttu-id="4f8fc-204">**Eric Evans. Domain-Driven Design: Tackling Complexity in the Heart of Software (Progettazione basata su domini: gestire le complessità nel software).**</span><span class="sxs-lookup"><span data-stu-id="4f8fc-204">**Eric Evans. Domain-Driven Design: Tackling Complexity in the Heart of Software.**</span></span> <span data-ttu-id="4f8fc-205">(Libro; include una discussione sullo schema repository) [_https://www.amazon.com/Domain-Driven-Design-Tackling-Complexity-Software/dp/0321125215/_](https://www.amazon.com/Domain-Driven-Design-Tackling-Complexity-Software/dp/0321125215/)</span><span class="sxs-lookup"><span data-stu-id="4f8fc-205">(Book; includes a discussion of the Repository pattern) [_https://www.amazon.com/Domain-Driven-Design-Tackling-Complexity-Software/dp/0321125215/_](https://www.amazon.com/Domain-Driven-Design-Tackling-Complexity-Software/dp/0321125215/)</span></span>

### <a name="unit-of-work-pattern"></a><span data-ttu-id="4f8fc-206">Schema Unit of Work</span><span class="sxs-lookup"><span data-stu-id="4f8fc-206">Unit of Work pattern</span></span>

- <span data-ttu-id="4f8fc-207">**Martin Fowler. Schema Unit of Work.**
  [_https://martinfowler.com/eaaCatalog/unitOfWork.html_](https://martinfowler.com/eaaCatalog/unitOfWork.html)</span><span class="sxs-lookup"><span data-stu-id="4f8fc-207">**Martin Fowler. Unit of Work pattern.**
[_https://martinfowler.com/eaaCatalog/unitOfWork.html_](https://martinfowler.com/eaaCatalog/unitOfWork.html)</span></span>

- <span data-ttu-id="4f8fc-208">**Implementazione dei modelli con repository e unità di lavoro in un'applicazione ASP.NET MVC**
  [_https://docs.microsoft.com/aspnet/mvc/overview/older-versions/getting-started-with-ef-5-using-mvc-4/implementing-the-repository-and-unit-of-work-patterns-in-an-asp-net-mvc-application_](https://docs.microsoft.com/aspnet/mvc/overview/older-versions/getting-started-with-ef-5-using-mvc-4/implementing-the-repository-and-unit-of-work-patterns-in-an-asp-net-mvc-application)</span><span class="sxs-lookup"><span data-stu-id="4f8fc-208">**Implementing the Repository and Unit of Work Patterns in an ASP.NET MVC Application**
[_https://docs.microsoft.com/aspnet/mvc/overview/older-versions/getting-started-with-ef-5-using-mvc-4/implementing-the-repository-and-unit-of-work-patterns-in-an-asp-net-mvc-application_](https://docs.microsoft.com/aspnet/mvc/overview/older-versions/getting-started-with-ef-5-using-mvc-4/implementing-the-repository-and-unit-of-work-patterns-in-an-asp-net-mvc-application)</span></span>

### <a name="the-specification-pattern"></a><span data-ttu-id="4f8fc-209">Schema Specification</span><span class="sxs-lookup"><span data-stu-id="4f8fc-209">The Specification pattern</span></span>

- <span data-ttu-id="4f8fc-210">**The Specification pattern.**
  [_https://deviq.com/specification-pattern/_](https://deviq.com/specification-pattern/) (Schema Specification)</span><span class="sxs-lookup"><span data-stu-id="4f8fc-210">**The Specification pattern.**
[_https://deviq.com/specification-pattern/_](https://deviq.com/specification-pattern/)</span></span>

- <span data-ttu-id="4f8fc-211">**Evans, Eric (2004). Domain Driven Design. Addison-Wesley. p. 224.**</span><span class="sxs-lookup"><span data-stu-id="4f8fc-211">**Evans, Eric (2004). Domain Driven Design. Addison-Wesley. p. 224.**</span></span>

- <span data-ttu-id="4f8fc-212">**Specifications. Martin Fowler**
  [_https://www.martinfowler.com/apsupp/spec.pdf/_](https://www.martinfowler.com/apsupp/spec.pdf)</span><span class="sxs-lookup"><span data-stu-id="4f8fc-212">**Specifications. Martin Fowler**
[_https://www.martinfowler.com/apsupp/spec.pdf/_](https://www.martinfowler.com/apsupp/spec.pdf)</span></span>

>[!div class="step-by-step"]
<span data-ttu-id="4f8fc-213">[Precedente](domain-events-design-implementation.md)
[Successivo](infrastructure-persistence-layer-implemenation-entity-framework-core.md)</span><span class="sxs-lookup"><span data-stu-id="4f8fc-213">[Previous](domain-events-design-implementation.md)
[Next](infrastructure-persistence-layer-implemenation-entity-framework-core.md)</span></span>
