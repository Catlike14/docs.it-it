---
title: Progettazione del livello di persistenza di infrastruttura
description: Architettura di Microservizi .NET per le applicazioni nei contenitori .NET | Progettazione del livello di persistenza di infrastruttura
keywords: Docker, microservizi, ASP.NET, contenitore
author: CESARDELATORRE
ms.author: wiwagn
ms.date: 05/26/2017
ms.prod: .net-core
ms.technology: dotnet-docker
ms.topic: article
ms.openlocfilehash: ce0f1d608eed909a7707f3c580afc5253f3eef06
ms.sourcegitcommit: bd1ef61f4bb794b25383d3d72e71041a5ced172e
ms.translationtype: HT
ms.contentlocale: it-IT
ms.lasthandoff: 10/18/2017
---
# <a name="designing-the-infrastructure-persistence-layer"></a><span data-ttu-id="c4fe2-104">Progettazione del livello di persistenza di infrastruttura</span><span class="sxs-lookup"><span data-stu-id="c4fe2-104">Designing the infrastructure persistence layer</span></span>

<span data-ttu-id="c4fe2-105">Componenti di persistenza di dati forniscono l'accesso ai dati ospitati entro i limiti di un microservizio (vale a dire, il database del microservizio un).</span><span class="sxs-lookup"><span data-stu-id="c4fe2-105">Data persistence components provide access to the data hosted within the boundaries of a microservice (that is, a microservice’s database).</span></span> <span data-ttu-id="c4fe2-106">Contengono l'implementazione effettiva di componenti come repository e [unità di lavoro](http://martinfowler.com/eaaCatalog/unitOfWork.html) classi, quali DBContexts EF personalizzato.</span><span class="sxs-lookup"><span data-stu-id="c4fe2-106">They contain the actual implementation of components such as repositories and [Unit of Work](http://martinfowler.com/eaaCatalog/unitOfWork.html) classes, like custom EF DBContexts.</span></span>

## <a name="the-repository-pattern"></a><span data-ttu-id="c4fe2-107">Il modello di Repository</span><span class="sxs-lookup"><span data-stu-id="c4fe2-107">The Repository pattern</span></span>

<span data-ttu-id="c4fe2-108">Repository sono classi o componenti che incapsulano la logica necessaria per accedere alle origini dati.</span><span class="sxs-lookup"><span data-stu-id="c4fe2-108">Repositories are classes or components that encapsulate the logic required to access data sources.</span></span> <span data-ttu-id="c4fe2-109">Essi centralizzare i dati accesso funzionalità comuni, fornendo una maggiore semplicità di gestione e il disaccoppiamento infrastruttura o la tecnologia usata per accedere ai database dal livello del modello di dominio.</span><span class="sxs-lookup"><span data-stu-id="c4fe2-109">They centralize common data access functionality, providing better maintainability and decoupling the infrastructure or technology used to access databases from the domain model layer.</span></span> <span data-ttu-id="c4fe2-110">Se si utilizza una ORM come Entity Framework, il codice che deve essere implementato è semplificato grazie a LINQ e la tipizzazione forte.</span><span class="sxs-lookup"><span data-stu-id="c4fe2-110">If you use an ORM like Entity Framework, the code that must be implemented is simplified, thanks to LINQ and strong typing.</span></span> <span data-ttu-id="c4fe2-111">Ciò consente di concentrarsi sulla logica di persistenza di dati anziché sui dati impianto di accesso.</span><span class="sxs-lookup"><span data-stu-id="c4fe2-111">This lets you focus on the data persistence logic rather than on data access plumbing.</span></span>

<span data-ttu-id="c4fe2-112">Il modello di Repository è un modo ben documentato dell'utilizzo di un'origine dati.</span><span class="sxs-lookup"><span data-stu-id="c4fe2-112">The Repository pattern is a well-documented way of working with a data source.</span></span> <span data-ttu-id="c4fe2-113">Nel libro [modelli di architettura dell'applicazione Enterprise](https://www.amazon.com/Patterns-Enterprise-Application-Architecture-Martin/dp/0321127420/), Martin Fowler descrive un repository come segue:</span><span class="sxs-lookup"><span data-stu-id="c4fe2-113">In the book [Patterns of Enterprise Application Architecture](https://www.amazon.com/Patterns-Enterprise-Application-Architecture-Martin/dp/0321127420/), Martin Fowler describes a repository as follows:</span></span>

<span data-ttu-id="c4fe2-114">Un repository esegue le attività di intermediario tra i livelli del modello di dominio e i mapping dei dati, che agisce in modo analogo a un set di oggetti di dominio in memoria.</span><span class="sxs-lookup"><span data-stu-id="c4fe2-114">A repository performs the tasks of an intermediary between the domain model layers and data mapping, acting in a similar way to a set of domain objects in memory.</span></span> <span data-ttu-id="c4fe2-115">Gli oggetti client, in modo dichiarativo, compilare query e li inviano al repository per le risposte.</span><span class="sxs-lookup"><span data-stu-id="c4fe2-115">Client objects declaratively build queries and send them to the repositories for answers.</span></span> <span data-ttu-id="c4fe2-116">Concettualmente, un repository incapsula un set di oggetti archiviati nel database e le operazioni che possono essere eseguite su di essi, offrendo un modo che più si avvicina a livello di persistenza.</span><span class="sxs-lookup"><span data-stu-id="c4fe2-116">Conceptually, a repository encapsulates a set of objects stored in the database and operations that can be performed on them, providing a way that is closer to the persistence layer.</span></span> <span data-ttu-id="c4fe2-117">Repository, inoltre, supportano lo scopo di separare chiaramente e in una direzione, la dipendenza tra il dominio di lavoro e l'allocazione di dati o di mapping.</span><span class="sxs-lookup"><span data-stu-id="c4fe2-117">Repositories, also, support the purpose of separating, clearly and in one direction, the dependency between the work domain and the data allocation or mapping.</span></span>

### <a name="define-one-repository-per-aggregate"></a><span data-ttu-id="c4fe2-118">Definire un repository per aggregazione</span><span class="sxs-lookup"><span data-stu-id="c4fe2-118">Define one repository per aggregate</span></span>

<span data-ttu-id="c4fe2-119">Per ogni radice di aggregazione o di aggregazione, è necessario creare una classe di repository.</span><span class="sxs-lookup"><span data-stu-id="c4fe2-119">For each aggregate or aggregate root, you should create one repository class.</span></span> <span data-ttu-id="c4fe2-120">In microservizio in base ai modelli di progettazione basati su dominio, l'unico canale che è necessario utilizzare per aggiornare il database deve essere il repository.</span><span class="sxs-lookup"><span data-stu-id="c4fe2-120">In a microservice based on domain-driven design patterns, the only channel you should use to update the database should be the repositories.</span></span> <span data-ttu-id="c4fe2-121">Questo avviene perché hanno una relazione uno a uno con la radice di aggregazione, che controlla l'aggregazione invarianti e coerenza transazionale.</span><span class="sxs-lookup"><span data-stu-id="c4fe2-121">This is because they have a one-to-one relationship with the aggregate root, which controls the aggregate’s invariants and transactional consistency.</span></span> <span data-ttu-id="c4fe2-122">È possibile eseguire query sul database tramite altri canali (come è possibile eseguire in seguito un approccio CQRS), poiché le query non modificano lo stato del database.</span><span class="sxs-lookup"><span data-stu-id="c4fe2-122">It is okay to query the database through other channels (as you can do following a CQRS approach), because queries do not change the state of the database.</span></span> <span data-ttu-id="c4fe2-123">Tuttavia, l'area transazionale, gli aggiornamenti, devono sempre essere controllate dal repository e le radici di aggregazione.</span><span class="sxs-lookup"><span data-stu-id="c4fe2-123">However, the transactional area—the updates—must always be controlled by the repositories and the aggregate roots.</span></span>

<span data-ttu-id="c4fe2-124">In pratica, un repository consente di popolare i dati in memoria che provenga dal database sotto forma delle entità di dominio.</span><span class="sxs-lookup"><span data-stu-id="c4fe2-124">Basically, a repository allows you to populate data in memory that comes from the database in the form of the domain entities.</span></span> <span data-ttu-id="c4fe2-125">Quando le entità sono in memoria, possono essere modificati e salvati in modo permanente nel database tramite le transazioni.</span><span class="sxs-lookup"><span data-stu-id="c4fe2-125">Once the entities are in memory, they can be changed and then persisted back to the database through transactions.</span></span>

<span data-ttu-id="c4fe2-126">Come notato in precedenza, se si utilizza il modello architetturale CQS/CQRS, le query iniziale verranno eseguite da query lato nel modello di dominio, eseguite da semplici istruzioni SQL utilizzando Dapper.</span><span class="sxs-lookup"><span data-stu-id="c4fe2-126">As noted earlier, if you are using the CQS/CQRS architectural pattern, the initial queries will be performed by side queries out of the domain model, performed by simple SQL statements using Dapper.</span></span> <span data-ttu-id="c4fe2-127">Questo approccio è molto più flessibile di repository perché è possibile eseguire una query e aggiungere tutte le tabelle è necessario, e tali query non sono limitate dalle regole dall'aggregazione.</span><span class="sxs-lookup"><span data-stu-id="c4fe2-127">This approach is much more flexible than repositories because you can query and join any tables you need, and these queries are not restricted by rules from the aggregates.</span></span> <span data-ttu-id="c4fe2-128">Tali dati verranno inviata all'app client o del livello presentazione.</span><span class="sxs-lookup"><span data-stu-id="c4fe2-128">That data will go to the presentation layer or client app.</span></span>

<span data-ttu-id="c4fe2-129">Se l'utente apporta modifiche, i dati da aggiornare proverrà dal livello di presentazione o di app client al livello di applicazione (ad esempio, un servizio Web API).</span><span class="sxs-lookup"><span data-stu-id="c4fe2-129">If the user makes changes, the data to be updated will come from the client app or presentation layer to the application layer (such as a Web API service).</span></span> <span data-ttu-id="c4fe2-130">Quando si riceve un comando (dati) in un gestore del comando, utilizzare repository per ottenere i dati desiderati per l'aggiornamento dal database.</span><span class="sxs-lookup"><span data-stu-id="c4fe2-130">When you receive a command (with data) in a command handler, you use repositories to get the data you want to update from the database.</span></span> <span data-ttu-id="c4fe2-131">È possibile aggiornarla in memoria con le informazioni passate con i comandi, e quindi aggiungere o aggiornare i dati (entità di dominio) nel database tramite una transazione.</span><span class="sxs-lookup"><span data-stu-id="c4fe2-131">You update it in memory with the information passed with the commands, and you then add or update the data (domain entities) in the database through a transaction.</span></span>

<span data-ttu-id="c4fe2-132">È necessario sottolineare nuovamente che un solo archivio deve essere definito per ogni radice di aggregazione, come illustrato nella figura 9-17.</span><span class="sxs-lookup"><span data-stu-id="c4fe2-132">We must emphasize again that only one repository should be defined for each aggregate root, as shown in Figure 9-17.</span></span> <span data-ttu-id="c4fe2-133">Per raggiungere l'obiettivo della radice dell'aggregazione per mantenere la coerenza transazionale tra tutti gli oggetti all'interno dell'aggregazione, è consigliabile non creare mai un repository per ogni tabella nel database.</span><span class="sxs-lookup"><span data-stu-id="c4fe2-133">To achieve the goal of the aggregate root to maintain transactional consistency between all the objects within the aggregate, you should never create a repository for each table in the database.</span></span>

![](./media/image18.png)

<span data-ttu-id="c4fe2-134">**Figura 9-17**.</span><span class="sxs-lookup"><span data-stu-id="c4fe2-134">**Figure 9-17**.</span></span> <span data-ttu-id="c4fe2-135">La relazione tra le tabelle del database repository e aggregazioni</span><span class="sxs-lookup"><span data-stu-id="c4fe2-135">The relationship between repositories, aggregates, and database tables</span></span>

### <a name="enforcing-one-aggregate-root-per-repository"></a><span data-ttu-id="c4fe2-136">Applicazione di una radice di aggregazione al repository</span><span class="sxs-lookup"><span data-stu-id="c4fe2-136">Enforcing one aggregate root per repository</span></span>

<span data-ttu-id="c4fe2-137">Può essere utile per implementare il repository progetto in modo che applica la regola che solo le radici di aggregazione devono disporre di repository.</span><span class="sxs-lookup"><span data-stu-id="c4fe2-137">It can be valuable to implement your repository design in such a way that it enforces the rule that only aggregate roots should have repositories.</span></span> <span data-ttu-id="c4fe2-138">È possibile creare un tipo generico o di base del repository che vincola il tipo di entità per garantire che dispongano di interfaccia di marcatore IAggregateRoot funziona con.</span><span class="sxs-lookup"><span data-stu-id="c4fe2-138">You can create a generic or base repository type that constrains the type of entities it works with to ensure they have the IAggregateRoot marker interface.</span></span>

<span data-ttu-id="c4fe2-139">Di conseguenza, ogni classe di repository implementata a livello di infrastruttura implementa il proprio contratto o un'interfaccia, come illustrato nel codice seguente:</span><span class="sxs-lookup"><span data-stu-id="c4fe2-139">Thus, each repository class implemented at the infrastructure layer implements its own contract or interface, as shown in the following code:</span></span>

```csharp
namespace Microsoft.eShopOnContainers.Services.Ordering.Infrastructure.Repositories
{
    public class OrderRepository : IOrderRepository
    {
```

<span data-ttu-id="c4fe2-140">Ogni interfaccia del repository specifico implementa l'interfaccia IRepository generica:</span><span class="sxs-lookup"><span data-stu-id="c4fe2-140">Each specific repository interface implements the generic IRepository interface:</span></span>

```csharp
public interface IOrderRepository : IRepository<Order>
{
    Order Add(Order order);
    // ...
}
```

<span data-ttu-id="c4fe2-141">Tuttavia, un modo migliore per avere il codice di applicare la convenzione che ogni repository deve essere correlato a una singola funzione di aggregazione, è possibile implementare un tipo di repository generica in modo che si usa un repository di destinazione di una funzione di aggregazione specifica esplicita.</span><span class="sxs-lookup"><span data-stu-id="c4fe2-141">However, a better way to have the code enforce the convention that each repository should be related to a single aggregate would be to implement a generic repository type so it is explicit that you are using a repository to target a specific aggregate.</span></span> <span data-ttu-id="c4fe2-142">Che può essere facilmente eseguita mediante l'implementazione di tale definizione nell'interfaccia di base IRepository, come illustrato nel codice seguente:</span><span class="sxs-lookup"><span data-stu-id="c4fe2-142">That can be easily done by implementing that generic in the IRepository base interface, as in the following code:</span></span>

```csharp
  public interface IRepository<T> where T : IAggregateRoot
```

### <a name="the-repository-pattern-makes-it-easier-to-test-your-application-logic"></a><span data-ttu-id="c4fe2-143">Il modello di Repository rende più semplice testare la logica dell'applicazione</span><span class="sxs-lookup"><span data-stu-id="c4fe2-143">The Repository pattern makes it easier to test your application logic</span></span>

<span data-ttu-id="c4fe2-144">Il modello di Repository consente di testare facilmente l'applicazione con unit test.</span><span class="sxs-lookup"><span data-stu-id="c4fe2-144">The Repository pattern allows you to easily test your application with unit tests.</span></span> <span data-ttu-id="c4fe2-145">Tenere presente che gli unit test solo test del codice, non dell'infrastruttura, in modo che le astrazioni di repository più facile da raggiungere tale obiettivo.</span><span class="sxs-lookup"><span data-stu-id="c4fe2-145">Remember that unit tests only test your code, not infrastructure, so the repository abstractions make it easier to achieve that goal.</span></span>

<span data-ttu-id="c4fe2-146">Come indicato in una sezione precedente, si consiglia di definire e inserire le interfacce di repository nel livello del modello di dominio al livello dell'applicazione (ad esempio, microservizio l'API Web) non dipendono direttamente il livello di infrastruttura in cui è necessario implementato le classi di archivio effettivi.</span><span class="sxs-lookup"><span data-stu-id="c4fe2-146">As noted in an earlier section, it is recommended that you define and place the repository interfaces in the domain model layer so the application layer (for instance, your Web API microservice) does not depend directly on the infrastructure layer where you have implemented the actual repository classes.</span></span> <span data-ttu-id="c4fe2-147">In questo modo e mediante l'inserimento di dipendenza nel controller dell'API Web, è possibile implementare repository fittizio che restituiscono dati falsi anziché i dati dal database.</span><span class="sxs-lookup"><span data-stu-id="c4fe2-147">By doing this and using Dependency Injection in the controllers of your Web API, you can implement mock repositories that return fake data instead of data from the database.</span></span> <span data-ttu-id="c4fe2-148">Che approccio separato consente di creare e l'esecuzione di unit test che è possibile testare solo la logica dell'applicazione senza richiedere la connettività al database.</span><span class="sxs-lookup"><span data-stu-id="c4fe2-148">That decoupled approach allows you to create and run unit tests that can test just the logic of your application without requiring connectivity to the database.</span></span>

<span data-ttu-id="c4fe2-149">Le connessioni ai database possono non riuscire e, ancora più importante, che eseguono centinaia di test in un database è non valido per due motivi.</span><span class="sxs-lookup"><span data-stu-id="c4fe2-149">Connections to databases can fail and, more importantly, running hundreds of tests against a database is bad for two reasons.</span></span> <span data-ttu-id="c4fe2-150">In primo luogo, può richiedere molto tempo a causa dell'elevato numero di test.</span><span class="sxs-lookup"><span data-stu-id="c4fe2-150">First, it can take a lot of time because of the large number of tests.</span></span> <span data-ttu-id="c4fe2-151">In secondo luogo, i record del database potrebbero modificare e influire sui risultati dei test, in modo che potrebbe non essere coerente.</span><span class="sxs-lookup"><span data-stu-id="c4fe2-151">Second, the database records might change and impact the results of your tests, so that they might not be consistent.</span></span> <span data-ttu-id="c4fe2-152">Test nel database non è un tipo di unit test, ma un'integrazione test.</span><span class="sxs-lookup"><span data-stu-id="c4fe2-152">Testing against the database is not a unit tests but an integration test.</span></span> <span data-ttu-id="c4fe2-153">È molti unit test, esecuzione veloce, ma un numero inferiore di integrazione verifica per i database.</span><span class="sxs-lookup"><span data-stu-id="c4fe2-153">You should have many unit tests running fast, but fewer integration tests against the databases.</span></span>

<span data-ttu-id="c4fe2-154">In termini di separazione delle problematiche per gli unit test, la logica opera sulle entità di dominio in memoria.</span><span class="sxs-lookup"><span data-stu-id="c4fe2-154">In terms of separation of concerns for unit tests, your logic operates on domain entities in memory.</span></span> <span data-ttu-id="c4fe2-155">Si presuppone che la classe repository ha recapitato quelli.</span><span class="sxs-lookup"><span data-stu-id="c4fe2-155">It assumes the repository class has delivered those.</span></span> <span data-ttu-id="c4fe2-156">Una volta la logica di modifica le entità di dominio, si presuppone che la classe repository verrà archiviarli in modo corretto.</span><span class="sxs-lookup"><span data-stu-id="c4fe2-156">Once your logic modifies the domain entities, it assumes the repository class will store them correctly.</span></span> <span data-ttu-id="c4fe2-157">Il punto importante consiste nel creare unit test con il modello di dominio e la logica di dominio.</span><span class="sxs-lookup"><span data-stu-id="c4fe2-157">The important point here is to create unit tests against your domain model and its domain logic.</span></span> <span data-ttu-id="c4fe2-158">Radici di aggregazione sono i limiti della coerenza principale DDD.</span><span class="sxs-lookup"><span data-stu-id="c4fe2-158">Aggregate roots are the main consistency boundaries in DDD.</span></span>

### <a name="the-difference-between-the-repository-pattern-and-the-legacy-data-access-class-dal-class-pattern"></a><span data-ttu-id="c4fe2-159">La differenza tra il modello di Repository e il modello di classe (classe DAL) di accesso ai dati legacy</span><span class="sxs-lookup"><span data-stu-id="c4fe2-159">The difference between the Repository pattern and the legacy Data Access class (DAL class) pattern</span></span>

<span data-ttu-id="c4fe2-160">Un oggetto di accesso ai dati direttamente esegue operazioni di accesso e la persistenza dei dati nel servizio di archiviazione.</span><span class="sxs-lookup"><span data-stu-id="c4fe2-160">A data access object directly performs data access and persistence operations against storage.</span></span> <span data-ttu-id="c4fe2-161">Contrassegni di repository dei dati con le operazioni da eseguire nella memoria di un'unità di lavoro oggetto (ad esempio Entity Framework quando si utilizza l'elemento DbContext), ma questi aggiornamenti non verranno eseguiti immediatamente.</span><span class="sxs-lookup"><span data-stu-id="c4fe2-161">A repository marks the data with the operations you want to perform in the memory of a unit of work object (as in EF when using the DbContext), but these updates will not be performed immediately.</span></span>

<span data-ttu-id="c4fe2-162">Un'unità di lavoro è noto come una singola transazione che coinvolge più inserimento, aggiornamento o eliminazione di operazioni.</span><span class="sxs-lookup"><span data-stu-id="c4fe2-162">A unit of work is referred to as a single transaction that involves multiple insert, update, or delete operations.</span></span> <span data-ttu-id="c4fe2-163">In altre parole, significa che per un'azione utente specifico (ad esempio, la registrazione in un sito Web), insert, update e delete transazioni vengono gestite in un'unica transazione.</span><span class="sxs-lookup"><span data-stu-id="c4fe2-163">In simple terms, it means that for a specific user action (for example, registration on a website), all the insert, update, and delete transactions are handled in a single transaction.</span></span> <span data-ttu-id="c4fe2-164">Questo è più efficiente rispetto alla gestione di più transazioni di database in modo chattier.</span><span class="sxs-lookup"><span data-stu-id="c4fe2-164">This is more efficient than handling multiple database transactions in a chattier way.</span></span>

<span data-ttu-id="c4fe2-165">Quando i comandi del codice dal livello dell'applicazione verranno eseguite queste operazioni di persistenza più più avanti in una singola azione.</span><span class="sxs-lookup"><span data-stu-id="c4fe2-165">These multiple persistence operations will be performed later in a single action when your code from the application layer commands it.</span></span> <span data-ttu-id="c4fe2-166">La decisione sull'applicazione delle modifiche in memoria per l'archiviazione del database effettivo dipende in genere il [modello Unit of Work](http://martinfowler.com/eaaCatalog/unitOfWork.html).</span><span class="sxs-lookup"><span data-stu-id="c4fe2-166">The decision about applying the in-memory changes to the actual database storage is typically based on the [Unit of Work pattern](http://martinfowler.com/eaaCatalog/unitOfWork.html).</span></span> <span data-ttu-id="c4fe2-167">In Entity Framework, il modello di unità di lavoro viene implementato come DBContext.</span><span class="sxs-lookup"><span data-stu-id="c4fe2-167">In EF, the Unit of Work pattern is implemented as the DBContext.</span></span>

<span data-ttu-id="c4fe2-168">In molti casi, questo modello o in modalità di applicazione di operazioni di archiviazione può migliorare le prestazioni dell'applicazione e ridurre il rischio di incoerenze.</span><span class="sxs-lookup"><span data-stu-id="c4fe2-168">In many cases, this pattern or way of applying operations against the storage can increase application performance and reduce the possibility of inconsistencies.</span></span> <span data-ttu-id="c4fe2-169">Inoltre, riduce delle transazioni di blocco nelle tabelle del database, poiché tutte le operazioni previste sono il commit come parte di una transazione.</span><span class="sxs-lookup"><span data-stu-id="c4fe2-169">Also, it reduces transaction blocking in the database tables, because all the intended operations are committed as part of one transaction.</span></span> <span data-ttu-id="c4fe2-170">Questo è più efficiente rispetto all'esecuzione di molte operazioni di tipo isolate sul database.</span><span class="sxs-lookup"><span data-stu-id="c4fe2-170">This is more efficient in comparison to executing many isolated operations against the database.</span></span> <span data-ttu-id="c4fe2-171">Pertanto, di ORM selezionata sarà in grado di ottimizzare l'esecuzione nel database mediante il raggruppamento delle azioni di aggiornamento diversi all'interno della stessa transazione, anziché più esecuzioni di transazione di piccole e separato.</span><span class="sxs-lookup"><span data-stu-id="c4fe2-171">Therefore, the selected ORM will be able to optimize the execution against the database by grouping several update actions within the same transaction, as opposed to many small and separate transaction executions.</span></span>

### <a name="repositories-should-not-be-mandatory"></a><span data-ttu-id="c4fe2-172">Repository non devono essere obbligatori</span><span class="sxs-lookup"><span data-stu-id="c4fe2-172">Repositories should not be mandatory</span></span>

<span data-ttu-id="c4fe2-173">I repository personalizzati sono utili per i motivi citati in precedenza e che è l'approccio per l'ordinamento microservizio in eShopOnContainers.</span><span class="sxs-lookup"><span data-stu-id="c4fe2-173">Custom repositories are useful for the reasons cited earlier, and that is the approach for the ordering microservice in eShopOnContainers.</span></span> <span data-ttu-id="c4fe2-174">Tuttavia, non è un modello essenziale per implementare un design DDD o persino in genere lo sviluppo in .NET.</span><span class="sxs-lookup"><span data-stu-id="c4fe2-174">However, it is not an essential pattern to implement in a DDD design or even in general development in .NET.</span></span>

<span data-ttu-id="c4fe2-175">Ad esempio, Jimmy Bogard, quando si fornisce feedback diretto in questa Guida, ha il seguente:</span><span class="sxs-lookup"><span data-stu-id="c4fe2-175">For instance, Jimmy Bogard, when providing direct feedback for this guide, said the following:</span></span>

<span data-ttu-id="c4fe2-176">Questo sarà probabilmente maggiore feedback.</span><span class="sxs-lookup"><span data-stu-id="c4fe2-176">This’ll probably be my biggest feedback.</span></span> <span data-ttu-id="c4fe2-177">Non sono effettivamente una ventola dei repository, soprattutto perché nascondono i dettagli importanti del meccanismo di persistenza sottostante.</span><span class="sxs-lookup"><span data-stu-id="c4fe2-177">I’m really not a fan of repositories, mainly because they hide the important details of the underlying persistence mechanism.</span></span> <span data-ttu-id="c4fe2-178">Il motivo per cui rivolgersi per MediatR per i comandi, troppo.</span><span class="sxs-lookup"><span data-stu-id="c4fe2-178">It’s why I go for MediatR for commands, too.</span></span> <span data-ttu-id="c4fe2-179">È possibile utilizzare le potenzialità del livello di persistenza e push tutti il comportamento di dominio nel mio radici di aggregazione.</span><span class="sxs-lookup"><span data-stu-id="c4fe2-179">I can use the full power of the persistence layer, and push all that domain behavior into my aggregate roots.</span></span> <span data-ttu-id="c4fe2-180">In genere non si desidera simulare il repository: è necessario disporre di tale integrazione test con il componente reale.</span><span class="sxs-lookup"><span data-stu-id="c4fe2-180">I don’t usually want to mock my repositories – I still need to have that integration test with the real thing.</span></span> <span data-ttu-id="c4fe2-181">Passare CQRS concepite che è non è stata effettivamente necessario per i repository più.</span><span class="sxs-lookup"><span data-stu-id="c4fe2-181">Going CQRS meant that we didn’t really have a need for repositories any more.</span></span>

<span data-ttu-id="c4fe2-182">È utile repository, ma si conferma che non sono critiche per le DDD, in modo che il modello di aggregazione e il modello di dominio completo.</span><span class="sxs-lookup"><span data-stu-id="c4fe2-182">We find repositories useful, but we acknowledge that they are not critical for your DDD, in the way that the Aggregate pattern and rich domain model are.</span></span> <span data-ttu-id="c4fe2-183">Pertanto, utilizzare il modello di Repository o meno, come può vedere adatta.</span><span class="sxs-lookup"><span data-stu-id="c4fe2-183">Therefore, use the Repository pattern or not, as you see fit.</span></span>

#### <a name="additional-resources"></a><span data-ttu-id="c4fe2-184">Risorse aggiuntive</span><span class="sxs-lookup"><span data-stu-id="c4fe2-184">Additional resources</span></span>

##### <a name="the-repository-pattern"></a><span data-ttu-id="c4fe2-185">Il modello di Repository</span><span class="sxs-lookup"><span data-stu-id="c4fe2-185">The Repository pattern</span></span>

-   <span data-ttu-id="c4fe2-186">**Edward Hieatt e Rob me. Modello di repository. ** 
     [ *http://martinfowler.com/eaaCatalog/repository.html*](http://martinfowler.com/eaaCatalog/repository.html)</span><span class="sxs-lookup"><span data-stu-id="c4fe2-186">**Edward Hieatt and Rob Mee. Repository pattern.**
[*http://martinfowler.com/eaaCatalog/repository.html*](http://martinfowler.com/eaaCatalog/repository.html)</span></span>

-   <span data-ttu-id="c4fe2-187">**Il modello di Repository**
    [*https://msdn.microsoft.com/en-us/library/ff649690.aspx*](https://msdn.microsoft.com/en-us/library/ff649690.aspx)</span><span class="sxs-lookup"><span data-stu-id="c4fe2-187">**The Repository pattern**
[*https://msdn.microsoft.com/en-us/library/ff649690.aspx*](https://msdn.microsoft.com/en-us/library/ff649690.aspx)</span></span>

-   <span data-ttu-id="c4fe2-188">**Modello di repository: Un'astrazione dei dati persistenza**
    [*http://deviq.com/repository-pattern/*](http://deviq.com/repository-pattern/)</span><span class="sxs-lookup"><span data-stu-id="c4fe2-188">**Repository Pattern: A data persistence abstraction**
[*http://deviq.com/repository-pattern/*](http://deviq.com/repository-pattern/)</span></span>

-   <span data-ttu-id="c4fe2-189">**Eric Evans. Progettazione basati su dominio: Affrontare complessità il cuore del Software.**</span><span class="sxs-lookup"><span data-stu-id="c4fe2-189">**Eric Evans. Domain-Driven Design: Tackling Complexity in the Heart of Software.**</span></span> <span data-ttu-id="c4fe2-190">(Una cartella di lavoro e include una descrizione del modello di Repository) [ *https://www.amazon.com/Domain-Driven-Design-Tackling-Complexity-Software/dp/0321125215/*](https://www.amazon.com/Domain-Driven-Design-Tackling-Complexity-Software/dp/0321125215/)</span><span class="sxs-lookup"><span data-stu-id="c4fe2-190">(Book; includes a discussion of the Repository pattern) [*https://www.amazon.com/Domain-Driven-Design-Tackling-Complexity-Software/dp/0321125215/*](https://www.amazon.com/Domain-Driven-Design-Tackling-Complexity-Software/dp/0321125215/)</span></span>

##### <a name="unit-of-work-pattern"></a><span data-ttu-id="c4fe2-191">Unità di modello di lavoro</span><span class="sxs-lookup"><span data-stu-id="c4fe2-191">Unit of Work pattern</span></span>

-   <span data-ttu-id="c4fe2-192">**Martin Fowler. Unità di modello di lavoro. ** 
     [ *http://martinfowler.com/eaaCatalog/unitOfWork.html*](http://martinfowler.com/eaaCatalog/unitOfWork.html)</span><span class="sxs-lookup"><span data-stu-id="c4fe2-192">**Martin Fowler. Unit of Work pattern.**
[*http://martinfowler.com/eaaCatalog/unitOfWork.html*](http://martinfowler.com/eaaCatalog/unitOfWork.html)</span></span>

<!-- -->

-   <span data-ttu-id="c4fe2-193">**Implementare il Repository e l'unità di lavoro modelli in un'applicazione MVC ASP.NET**
    [*https://www.asp.net/mvc/overview/older-versions/getting-started-with-ef-5-using-mvc-4/ Implementing-the-repository-and-unit-of-Work-Patterns-in-an-ASP-NET-MVC-Application*](https://www.asp.net/mvc/overview/older-versions/getting-started-with-ef-5-using-mvc-4/implementing-the-repository-and-unit-of-work-patterns-in-an-asp-net-mvc-application)</span><span class="sxs-lookup"><span data-stu-id="c4fe2-193">**Implementing the Repository and Unit of Work Patterns in an ASP.NET MVC Application**
[*https://www.asp.net/mvc/overview/older-versions/getting-started-with-ef-5-using-mvc-4/implementing-the-repository-and-unit-of-work-patterns-in-an-asp-net-mvc-application*](https://www.asp.net/mvc/overview/older-versions/getting-started-with-ef-5-using-mvc-4/implementing-the-repository-and-unit-of-work-patterns-in-an-asp-net-mvc-application)</span></span>


>[!div class="step-by-step"]
<span data-ttu-id="c4fe2-194">[Precedente] (dominio-eventi-struttura-implementation.md) [Avanti] (infrastructure-persistence-layer-implemenation-entity-framework-core.md)</span><span class="sxs-lookup"><span data-stu-id="c4fe2-194">[Previous] (domain-events-design-implementation.md) [Next] (infrastructure-persistence-layer-implemenation-entity-framework-core.md)</span></span>
