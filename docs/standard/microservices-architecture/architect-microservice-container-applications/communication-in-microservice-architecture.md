---
title: Comunicazione in un'architettura di microservizi
description: Architettura di microservizi .NET per applicazioni .NET in contenitori | Comunicazione in un'architettura di microservizi
keywords: Docker, microservizi, ASP.NET, contenitore
author: CESARDELATORRE
ms.author: wiwagn
ms.date: 10/18/2017
ms.prod: .net-core
ms.technology: dotnet-docker
ms.topic: article
ms.workload:
- dotnet
- dotnetcore
ms.openlocfilehash: 3c80ce8e3c4ccdc7e53634f54dd998581758ab07
ms.sourcegitcommit: cec0525b2121c36198379525e69aa5388266db5b
ms.translationtype: HT
ms.contentlocale: it-IT
ms.lasthandoff: 02/23/2018
---
# <a name="communication-in-a-microservice-architecture"></a><span data-ttu-id="3b2cf-104">Comunicazione in un'architettura di microservizi</span><span class="sxs-lookup"><span data-stu-id="3b2cf-104">Communication in a microservice architecture</span></span>

<span data-ttu-id="3b2cf-105">In un'applicazione monolitica in esecuzione in un singolo processo, i componenti si richiamano a vicenda tramite chiamate a metodi o funzioni a livello di linguaggio.</span><span class="sxs-lookup"><span data-stu-id="3b2cf-105">In a monolithic application running on a single process, components invoke one another using language-level method or function calls.</span></span> <span data-ttu-id="3b2cf-106">Questi componenti possono essere strettamente accoppiati se si creano oggetti con il codice, ad esempio `new ClassName()`, o possono essere richiamati in modo disaccoppiato, se si usa la funzionalità di inserimento delle dipendenze facendo riferimento ad astrazioni anziché a istanze di oggetti concrete.</span><span class="sxs-lookup"><span data-stu-id="3b2cf-106">These can be strongly coupled if you are creating objects with code (for example, `new ClassName()`), or can be invoked in a decoupled way if you are using Dependency Injection by referencing abstractions rather than concrete object instances.</span></span> <span data-ttu-id="3b2cf-107">In entrambi i casi, gli oggetti vengono eseguiti all'interno del processo stesso.</span><span class="sxs-lookup"><span data-stu-id="3b2cf-107">Either way, the objects are running within the same process.</span></span> <span data-ttu-id="3b2cf-108">La sfida maggiore quando si passa da un'applicazione monolitica a un'applicazione basata su microservizi è rappresentata dalla modifica del meccanismo di comunicazione.</span><span class="sxs-lookup"><span data-stu-id="3b2cf-108">The biggest challenge when changing from a monolithic application to a microservices-based application lies in changing the communication mechanism.</span></span> <span data-ttu-id="3b2cf-109">Una conversione diretta dalle chiamate ai metodi in-process alle chiamate RPC nei servizi produrrà una comunicazione frammentata e non efficiente che non funzionerà correttamente negli ambienti distribuiti.</span><span class="sxs-lookup"><span data-stu-id="3b2cf-109">A direct conversion from in-process method calls into RPC calls to services will cause a chatty and not efficient communication that will not perform well in distributed environments.</span></span> <span data-ttu-id="3b2cf-110">Le problematiche legate alla corretta progettazione di un sistema distribuito sono così ben note che sono state stilate in un articolo relativo ai [luoghi comuni sull'elaborazione distribuita](https://en.wikipedia.org/wiki/Fallacies_of_distributed_computing) che elenca i presupposti su cui gli sviluppatori spesso si basano quando passano dalla progettazione monolitica a quella distribuita.</span><span class="sxs-lookup"><span data-stu-id="3b2cf-110">The challenges of designing distributed system properly are well enough known that there is even a canon known as the [Fallacies of distributed computing](https://en.wikipedia.org/wiki/Fallacies_of_distributed_computing) that lists assumptions that developers often make when moving from monolithic to distributed designs.</span></span>

<span data-ttu-id="3b2cf-111">Non c'è un'unica soluzione ma ce ne sono diverse.</span><span class="sxs-lookup"><span data-stu-id="3b2cf-111">There is not one solution, but several.</span></span> <span data-ttu-id="3b2cf-112">Una soluzione prevede per quanto possibile l'isolamento dei microservizi aziendali.</span><span class="sxs-lookup"><span data-stu-id="3b2cf-112">One solution involves isolating the business microservices as much as possible.</span></span> <span data-ttu-id="3b2cf-113">Viene quindi usata una comunicazione asincrona tra i microservizi interni e si sostituisce la comunicazione con granularità fine tipica della comunicazione tra gli oggetti all'interno di un processo con una comunicazione con granularità grossolana.</span><span class="sxs-lookup"><span data-stu-id="3b2cf-113">You then use asynchronous communication between the internal microservices and replace fine-grained communication that is typical in intra-process communication between objects with coarser-grained communication.</span></span> <span data-ttu-id="3b2cf-114">A tale scopo è possibile raggruppare le chiamate e restituire al client i dati che aggregano i risultati di più chiamate interne.</span><span class="sxs-lookup"><span data-stu-id="3b2cf-114">You can do this by grouping calls, and by returning data that aggregates the results of multiple internal calls, to the client.</span></span>

<span data-ttu-id="3b2cf-115">Un'applicazione basata su microservizi è un sistema distribuito in esecuzione in più processi o servizi, in genere anche in più server o host.</span><span class="sxs-lookup"><span data-stu-id="3b2cf-115">A microservices-based application is a distributed system running on multiple processes or services, usually even across multiple servers or hosts.</span></span> <span data-ttu-id="3b2cf-116">Ogni istanza del servizio è in genere un processo.</span><span class="sxs-lookup"><span data-stu-id="3b2cf-116">Each service instance is typically a process.</span></span> <span data-ttu-id="3b2cf-117">Di conseguenza, i servizi devono interagire usando un protocollo di comunicazione tra più processi, ad esempio HTTP, AMQP o un protocollo binario come TCP, a seconda della natura di ogni servizio.</span><span class="sxs-lookup"><span data-stu-id="3b2cf-117">Therefore, services must interact using an inter-process communication protocol such as HTTP, AMQP, or a binary protocol like TCP, depending on the nature of each service.</span></span>

<span data-ttu-id="3b2cf-118">La community dei microservizi promuove la filosofia di "[endpoint intelligenti e tubi porta-dati (smart endpoints and dumb pipes)](http://simplicable.com/new/smart-endpoints-and-dumb-pipes)".</span><span class="sxs-lookup"><span data-stu-id="3b2cf-118">The microservice community promotes the philosophy of “[smart endpoints and dumb pipes](http://simplicable.com/new/smart-endpoints-and-dumb-pipes).”</span></span> <span data-ttu-id="3b2cf-119">Questo slogan incoraggia una progettazione che sia quanto più disaccoppiata possibile tra i microservizi e quanto più coesa possibile all'interno di un singolo microservizio.</span><span class="sxs-lookup"><span data-stu-id="3b2cf-119">This slogan encourages a design that is as decoupled as possible between microservices, and as cohesive as possible within a single microservice.</span></span> <span data-ttu-id="3b2cf-120">Come spiegato in precedenza, ogni microservizio possiede i propri dati e la propria logica di dominio.</span><span class="sxs-lookup"><span data-stu-id="3b2cf-120">As explained earlier, each microservice owns its own data and its own domain logic.</span></span> <span data-ttu-id="3b2cf-121">Ma i microservizi che compongono un'applicazione end-to-end sono in genere semplicemente coreografati mediante le comunicazioni REST anziché i protocolli complessi come WS-\* e le comunicazioni flessibili basate sugli eventi anziché gli agenti di orchestrazione di processi aziendali centralizzati.</span><span class="sxs-lookup"><span data-stu-id="3b2cf-121">But the microservices composing an end-to-end application are usually simply choreographed by using REST communications rather than complex protocols such as WS-\* and flexible event-driven communications instead of centralized business-process-orchestrators.</span></span>

<span data-ttu-id="3b2cf-122">I due protocolli comunemente usati sono richiesta/risposta HTTP con API delle risorse (soprattutto per l'esecuzione di query) e messaggistica asincrona lightweight per l'aggiornamento della comunicazione tra più microservizi.</span><span class="sxs-lookup"><span data-stu-id="3b2cf-122">The two commonly used protocols are HTTP request/response with resource APIs (when querying most of all), and lightweight asynchronous messaging when communicating updates across multiple microservices.</span></span> <span data-ttu-id="3b2cf-123">Questi protocolli vengono descritti più dettagliatamente nelle sezioni seguenti.</span><span class="sxs-lookup"><span data-stu-id="3b2cf-123">These are explained in more detail in the following sections.</span></span>

## <a name="communication-types"></a><span data-ttu-id="3b2cf-124">Tipi di comunicazione</span><span class="sxs-lookup"><span data-stu-id="3b2cf-124">Communication types</span></span>

<span data-ttu-id="3b2cf-125">Il client e i servizi possono comunicare attraverso molti tipi di comunicazione diversi, ciascuno dei quali destinato a uno scenario e obiettivi diversi.</span><span class="sxs-lookup"><span data-stu-id="3b2cf-125">Client and services can communicate through many different types of communication, each one targeting a different scenario and goals.</span></span> <span data-ttu-id="3b2cf-126">Inizialmente, questi tipi di comunicazione possono essere classificati in due assi.</span><span class="sxs-lookup"><span data-stu-id="3b2cf-126">Initially, those types of communications can be classified in two axes.</span></span>

<span data-ttu-id="3b2cf-127">Il primo asse definisce se il protocollo è sincrono o asincrono:</span><span class="sxs-lookup"><span data-stu-id="3b2cf-127">The first axis is defining if the protocol is synchronous or asynchronous:</span></span>

-   <span data-ttu-id="3b2cf-128">Protocollo sincrono.</span><span class="sxs-lookup"><span data-stu-id="3b2cf-128">Synchronous protocol.</span></span> <span data-ttu-id="3b2cf-129">HTTP è un protocollo sincrono.</span><span class="sxs-lookup"><span data-stu-id="3b2cf-129">HTTP is a synchronous protocol.</span></span> <span data-ttu-id="3b2cf-130">Il client invia una richiesta e attende una risposta dal servizio.</span><span class="sxs-lookup"><span data-stu-id="3b2cf-130">The client sends a request and waits for a response from the service.</span></span> <span data-ttu-id="3b2cf-131">Tale processo è indipendente dall'esecuzione del codice client che può essere sincrono (thread bloccato) o asincrono (thread non bloccato e la risposta raggiunge infine un callback).</span><span class="sxs-lookup"><span data-stu-id="3b2cf-131">That is independent of the client code execution that could be synchronous (thread is blocked) or asynchronous (thread is not blocked, and the response will reach a callback eventually).</span></span> <span data-ttu-id="3b2cf-132">L'aspetto importante è che il protocollo (HTTP/HTTPS) è sincrono e il codice client può continuare l'attività solo quando riceve la risposta del server HTTP.</span><span class="sxs-lookup"><span data-stu-id="3b2cf-132">The important point here is that the protocol (HTTP/HTTPS) is synchronous and the client code can only continue its task when it receives the HTTP server response.</span></span>

-   <span data-ttu-id="3b2cf-133">Protocollo asincrono.</span><span class="sxs-lookup"><span data-stu-id="3b2cf-133">Asynchronous protocol.</span></span> <span data-ttu-id="3b2cf-134">Altri protocolli quali AMQP (un protocollo supportato da molti sistemi operativi e ambienti cloud) usano messaggi asincroni.</span><span class="sxs-lookup"><span data-stu-id="3b2cf-134">Other protocols like AMQP (a protocol supported by many operating systems and cloud environments) use asynchronous messages.</span></span> <span data-ttu-id="3b2cf-135">Il codice client o il mittente del messaggio non attende in genere una risposta.</span><span class="sxs-lookup"><span data-stu-id="3b2cf-135">The client code or message sender usually does not wait for a response.</span></span> <span data-ttu-id="3b2cf-136">Invia semplicemente il messaggio analogamente all'invio di un messaggio a una coda RabbitMQ o a un qualsiasi altro broker di messaggi.</span><span class="sxs-lookup"><span data-stu-id="3b2cf-136">It just sends the message as when sending a message to a RabbitMQ queue or any other message broker.</span></span>

<span data-ttu-id="3b2cf-137">Il secondo asse definisce se la comunicazione ha un singolo destinatario o più destinatari:</span><span class="sxs-lookup"><span data-stu-id="3b2cf-137">The second axis is defining if the communication has a single receiver or multiple receivers:</span></span>

-   <span data-ttu-id="3b2cf-138">Singolo destinatario.</span><span class="sxs-lookup"><span data-stu-id="3b2cf-138">Single receiver.</span></span> <span data-ttu-id="3b2cf-139">Ogni richiesta deve essere elaborata da esattamente un destinatario o servizio.</span><span class="sxs-lookup"><span data-stu-id="3b2cf-139">Each request must be processed by exactly one receiver or service.</span></span> <span data-ttu-id="3b2cf-140">Un esempio di questo tipo di comunicazione è il [Command pattern](https://en.wikipedia.org/wiki/Command_pattern).</span><span class="sxs-lookup"><span data-stu-id="3b2cf-140">An example of this communication is the [Command pattern](https://en.wikipedia.org/wiki/Command_pattern).</span></span>

-   <span data-ttu-id="3b2cf-141">Più destinatari.</span><span class="sxs-lookup"><span data-stu-id="3b2cf-141">Multiple receivers.</span></span> <span data-ttu-id="3b2cf-142">Ogni richiesta può essere elaborata da zero a più destinatari.</span><span class="sxs-lookup"><span data-stu-id="3b2cf-142">Each request can be processed by zero to multiple receivers.</span></span> <span data-ttu-id="3b2cf-143">Questo tipo di comunicazione deve essere asincrono.</span><span class="sxs-lookup"><span data-stu-id="3b2cf-143">This type of communication must be asynchronous.</span></span> <span data-ttu-id="3b2cf-144">Un esempio è il meccanismo di [pubblicazione/sottoscrizione](https://en.wikipedia.org/wiki/Publish%E2%80%93subscribe_pattern) usato in schemi come l'[architettura basata su eventi](http://microservices.io/patterns/data/event-driven-architecture.html).</span><span class="sxs-lookup"><span data-stu-id="3b2cf-144">An example is the [publish/subscribe](https://en.wikipedia.org/wiki/Publish%E2%80%93subscribe_pattern) mechanism used in patterns like [Event-driven architecture](http://microservices.io/patterns/data/event-driven-architecture.html).</span></span> <span data-ttu-id="3b2cf-145">Questo meccanismo si basa su un'interfaccia del bus di eventi o su un broker di messaggi per la propagazione degli aggiornamenti dei dati tra più microservizi tramite eventi; viene in genere implementato tramite un bus di servizio o un elemento simile come il [bus di servizio di Azure](https://azure.microsoft.com/services/service-bus/) mediante [argomenti e sottoscrizioni](https://docs.microsoft.com/azure/service-bus-messaging/service-bus-dotnet-how-to-use-topics-subscriptions).</span><span class="sxs-lookup"><span data-stu-id="3b2cf-145">This is based on an event-bus interface or message broker when propagating data updates between multiple microservices through events; it is usually implemented through a service bus or similar artifact like [Azure Service Bus](https://azure.microsoft.com/services/service-bus/) by using [topics and subscriptions](https://docs.microsoft.com/azure/service-bus-messaging/service-bus-dotnet-how-to-use-topics-subscriptions).</span></span>

<span data-ttu-id="3b2cf-146">Un'applicazione basata su microservizi userà spesso una combinazione di questi stili di comunicazione.</span><span class="sxs-lookup"><span data-stu-id="3b2cf-146">A microservice-based application will often use a combination of these communication styles.</span></span> <span data-ttu-id="3b2cf-147">Il tipo più comune è la comunicazione con singolo destinatario con un protocollo sincrono come HTTP/HTTPS quando si richiama un servizio HTTP API Web normale.</span><span class="sxs-lookup"><span data-stu-id="3b2cf-147">The most common type is single-receiver communication with a synchronous protocol like HTTP/HTTPS when invoking a regular Web API HTTP service.</span></span> <span data-ttu-id="3b2cf-148">I microservizi usano in genere anche i protocolli di messaggistica per la comunicazione asincrona tra microservizi.</span><span class="sxs-lookup"><span data-stu-id="3b2cf-148">Microservices also typically use messaging protocols for asynchronous communication between microservices.</span></span>

<span data-ttu-id="3b2cf-149">È opportuno conoscere questi assi in modo che ci sia chiarezza sui possibili meccanismi di comunicazione, ma non sono aspetti importanti da prendere in considerazione per la creazione di microservizi.</span><span class="sxs-lookup"><span data-stu-id="3b2cf-149">These axes are good to know so you have clarity on the possible communication mechanisms, but they are not the important concerns when building microservices.</span></span> <span data-ttu-id="3b2cf-150">Per l'integrazione dei microservizi non serve prendere in considerazione né la natura asincrona dell'esecuzione dei thread del client né la natura asincrona del protocollo selezionato.</span><span class="sxs-lookup"><span data-stu-id="3b2cf-150">Neither the asynchronous nature of client thread execution nor the asynchronous nature of the selected protocol are the important points when integrating microservices.</span></span> <span data-ttu-id="3b2cf-151">L'aspetto che *è* importante è la possibilità di integrare in modo asincrono i microservizi mantenendone al contempo l'indipendenza, come illustrato nella sezione seguente.</span><span class="sxs-lookup"><span data-stu-id="3b2cf-151">What *is* important is being able to integrate your microservices asynchronously while maintaining the independence of microservices, as explained in the following section.</span></span>

## <a name="asynchronous-microservice-integration-enforces-microservices-autonomy"></a><span data-ttu-id="3b2cf-152">L'integrazione di microservizi asincroni impone l'autonomia del microservizio</span><span class="sxs-lookup"><span data-stu-id="3b2cf-152">Asynchronous microservice integration enforces microservice’s autonomy</span></span>

<span data-ttu-id="3b2cf-153">Come illustrato in precedenza, l'aspetto importante per la creazione di un'applicazione basata su microservizi è il modo in cui vengono integrati i microservizi.</span><span class="sxs-lookup"><span data-stu-id="3b2cf-153">As mentioned, the important point when building a microservices-based application is the way you integrate your microservices.</span></span> <span data-ttu-id="3b2cf-154">L'ideale sarebbe provare a ridurre al minimo la comunicazione tra i microservizi interni.</span><span class="sxs-lookup"><span data-stu-id="3b2cf-154">Ideally, you should try to minimize the communication between the internal microservices.</span></span> <span data-ttu-id="3b2cf-155">È preferibile che le comunicazioni tra i microservizi siano minime.</span><span class="sxs-lookup"><span data-stu-id="3b2cf-155">The less communications between microservices, the better.</span></span> <span data-ttu-id="3b2cf-156">Ma ovviamente in molti casi è necessario integrare in qualche modo i microservizi.</span><span class="sxs-lookup"><span data-stu-id="3b2cf-156">But of course, in many cases you will have to somehow integrate the microservices.</span></span> <span data-ttu-id="3b2cf-157">In tal caso, la regola essenziale è che la comunicazione tra i microservizi sia asincrona.</span><span class="sxs-lookup"><span data-stu-id="3b2cf-157">When you need to do that, the critical rule here is that the communication between the microservices should be asynchronous.</span></span> <span data-ttu-id="3b2cf-158">Ciò non significa che sia necessario usare un protocollo specifico (ad esempio, messaggistica asincrona rispetto a HTTP sincrono).</span><span class="sxs-lookup"><span data-stu-id="3b2cf-158">That does not mean that you have to use a specific protocol (for example, asynchronous messaging versus synchronous HTTP).</span></span> <span data-ttu-id="3b2cf-159">Significa semplicemente che la comunicazione tra i microservizi deve essere eseguita solo propagando i dati in modo asincrono, ma è preferibile non dipendere da altri microservizi interni come parte dell'operazione di richiesta/risposta HTTP del servizio iniziale.</span><span class="sxs-lookup"><span data-stu-id="3b2cf-159">It just means that the communication between microservices should be done only by propagating data asynchronously, but try not to depend on other internal microservices as part of the initial service’s HTTP request/response operation.</span></span>

<span data-ttu-id="3b2cf-160">Se possibile, non dipendere mai dalla comunicazione sincrona (richiesta/risposta) tra più microservizi, neanche per le query.</span><span class="sxs-lookup"><span data-stu-id="3b2cf-160">If possible, never depend on synchronous communication (request/response) between multiple microservices, not even for queries.</span></span> <span data-ttu-id="3b2cf-161">L'obiettivo di ogni microservizio è quello di essere autonomo e disponibile per il consumer client, anche se gli altri servizi che fanno parte dell'applicazione end-to-end sono inattivi o non integri.</span><span class="sxs-lookup"><span data-stu-id="3b2cf-161">The goal of each microservice is to be autonomous and available to the client consumer, even if the other services that are part of the end-to-end application are down or unhealthy.</span></span> <span data-ttu-id="3b2cf-162">Se si ritiene che sia necessario effettuare una chiamata da un microservizio ad altri microservizi (ad esempio, per eseguire una richiesta HTTP per una query di dati) per poter fornire una risposta a un'applicazione client, si avrà un'architettura che non sarà resiliente quando alcuni microservizi avranno esito negativo.</span><span class="sxs-lookup"><span data-stu-id="3b2cf-162">If you think you need to make a call from one microservice to other microservices (like performing an HTTP request for a data query) in order to be able to provide a response to a client application, you have an architecture that will not be resilient when some microservices fail.</span></span>

<span data-ttu-id="3b2cf-163">Inoltre, se si hanno dipendenze HTTP tra microservizi, come per la creazione di lunghi cicli di richieste/risposte HTTP con catene di richieste HTTP, come illustrato nella prima parte della figura 4-15, non solo si avranno microservizi non autonomi ma si avranno anche ripercussioni sulle prestazioni non appena uno dei servizi della catena non viene eseguito correttamente.</span><span class="sxs-lookup"><span data-stu-id="3b2cf-163">Moreover, having HTTP dependencies between microservices, like when creating long request/response cycles with HTTP request chains, as shown in the first part of the Figure 4-15, not only makes your microservices not autonomous but also their performance is impacted as soon as one of the services in that chain is not performing well.</span></span> 

<span data-ttu-id="3b2cf-164">Più si aggiungono dipendenze sincrone tra i microservizi, come per le richieste di query e peggiore sarà il tempo di risposta complessivo necessario per le app client.</span><span class="sxs-lookup"><span data-stu-id="3b2cf-164">The more you add synchronous dependencies between microservices, such as query requests, the worse the overall response time gets for the client apps.</span></span>

![](./media/image15.png)

<span data-ttu-id="3b2cf-165">**Figura 4-15**.</span><span class="sxs-lookup"><span data-stu-id="3b2cf-165">**Figure 4-15**.</span></span> <span data-ttu-id="3b2cf-166">Schemi e antipattern nella comunicazione tra microservizi</span><span class="sxs-lookup"><span data-stu-id="3b2cf-166">Anti-patterns and patterns in communication between microservices</span></span>

<span data-ttu-id="3b2cf-167">Se un microservizio deve generare un'azione aggiuntiva in un altro microservizio, se possibile non eseguire tale azione in modo sincrono e come parte dell'operazione di richiesta e risposta originale del microservizio.</span><span class="sxs-lookup"><span data-stu-id="3b2cf-167">If your microservice needs to raise an additional action in another microservice, if possible, do not perform that action synchronously and as part of the original microservice request and reply operation.</span></span> <span data-ttu-id="3b2cf-168">Eseguire invece l'azione in modo asincrono (usando la messaggistica asincrona o eventi di integrazione, code e così via).</span><span class="sxs-lookup"><span data-stu-id="3b2cf-168">Instead, do it asynchronously (using asynchronous messaging or integration events, queues, etc.).</span></span> <span data-ttu-id="3b2cf-169">Tuttavia, per quanto possibile, non richiamare l'azione in modo sincrono come parte dell'operazione di richiesta e risposta sincrona originale.</span><span class="sxs-lookup"><span data-stu-id="3b2cf-169">But, as much as possible, do not invoke the action synchronously as part of the original synchronous request and reply operation.</span></span>

<span data-ttu-id="3b2cf-170">Infine (e questo è il punto in cui si verificano la maggior parte dei problemi quando si creano i microservizi), se il microservizio iniziale necessita di dati originariamente di proprietà di altri microservizi, evitare di effettuare richieste sincrone per tali dati</span><span class="sxs-lookup"><span data-stu-id="3b2cf-170">And finally (and this is where most of the issues arise when building microservices), if your initial microservice needs data that is originally owned by other microservices, do not rely on making synchronous requests for that data.</span></span> <span data-ttu-id="3b2cf-171">ma replicare o propagare tali dati (solo gli attributi necessari) nel database del servizio iniziale usando la coerenza finale (in genere mediante gli eventi di integrazione, come illustrato nelle sezioni successive).</span><span class="sxs-lookup"><span data-stu-id="3b2cf-171">Instead, replicate or propagate that data (only the attributes you need) into the initial service’s database by using eventual consistency (typically by using integration events, as explained in upcoming sections).</span></span>

<span data-ttu-id="3b2cf-172">Come indicato in precedenza nella sezione [Identificazione dei limiti del modello di dominio per ogni microservizio](#identifying-domain-model-boundaries-for-each-microservice), la duplicazione di alcuni dati tra diversi microservizi non è una progettazione non corretta, ma al contrario, se si adotta questo metodo, è possibile convertire i dati nel linguaggio specifico o secondo le condizioni del dominio aggiuntivo o del contesto delimitato.</span><span class="sxs-lookup"><span data-stu-id="3b2cf-172">As noted earlier in the section [Identifying domain-model boundaries for each microservice](#identifying-domain-model-boundaries-for-each-microservice), duplicating some data across several microservices is not an incorrect design—on the contrary, when doing that you can translate the data into the specific language or terms of that additional domain or Bounded Context.</span></span> <span data-ttu-id="3b2cf-173">Ad esempio, nell'applicazione [eShopOnContainers](http://aka.ms/MicroservicesArchitecture) si ha un microservizio denominato identity.api che è responsabile della maggior parte dei dati dell'utente con un'entità denominata User.</span><span class="sxs-lookup"><span data-stu-id="3b2cf-173">For instance, in the [eShopOnContainers](http://aka.ms/MicroservicesArchitecture) application you have a microservice named identity.api that is in charge of most of the user’s data with an entity named User.</span></span> <span data-ttu-id="3b2cf-174">Tuttavia, quando è necessario archiviare i dati relativi all'utente all'interno del microservizio degli ordini, è possibile archiviarli come entità diversa denominata Buyer.</span><span class="sxs-lookup"><span data-stu-id="3b2cf-174">However, when you need to store data about the user within the Ordering microservice, you store it as a different entity named Buyer.</span></span> <span data-ttu-id="3b2cf-175">L'entità Buyer condivide la stessa identità con l'entità User originale, ma potrebbe contenere solo alcuni attributi richiesti dal dominio degli ordini e non l'intero profilo utente.</span><span class="sxs-lookup"><span data-stu-id="3b2cf-175">The Buyer entity shares the same identity with the original User entity, but it might have only the few attributes needed by the Ordering domain, and not the whole user profile.</span></span>

<span data-ttu-id="3b2cf-176">È possibile usare qualsiasi protocollo per comunicare e propagare i dati in modo asincrono tra i microservizi per avere la coerenza finale.</span><span class="sxs-lookup"><span data-stu-id="3b2cf-176">You might use any protocol to communicate and propagate data asynchronously across microservices in order to have eventual consistency.</span></span> <span data-ttu-id="3b2cf-177">Come illustrato in precedenza, è possibile usare gli eventi di integrazione mediante un bus di eventi o un broker di messaggi oppure è anche possibile usare HTTP eseguendo il polling degli altri servizi.</span><span class="sxs-lookup"><span data-stu-id="3b2cf-177">As mentioned, you could use integration events using an event bus or message broker or you could even use HTTP by polling the other services instead.</span></span> <span data-ttu-id="3b2cf-178">Non ha importanza.</span><span class="sxs-lookup"><span data-stu-id="3b2cf-178">It does not matter.</span></span> <span data-ttu-id="3b2cf-179">La regola importante consiste nel non creare dipendenze sincrone tra i microservizi.</span><span class="sxs-lookup"><span data-stu-id="3b2cf-179">The important rule is to not create synchronous dependencies between your microservices.</span></span>

<span data-ttu-id="3b2cf-180">Le sezioni seguenti illustrano i diversi stili di comunicazione che è possibile usare in un'applicazione basata su microservizi.</span><span class="sxs-lookup"><span data-stu-id="3b2cf-180">The following sections explain the multiple communication styles you can consider using in a microservice-based application.</span></span>

## <a name="communication-styles"></a><span data-ttu-id="3b2cf-181">Stili di comunicazione</span><span class="sxs-lookup"><span data-stu-id="3b2cf-181">Communication styles</span></span>

<span data-ttu-id="3b2cf-182">Esistono molti protocolli e opzioni che è possibile adottare per la comunicazione, a seconda del tipo di comunicazione che si vuole usare.</span><span class="sxs-lookup"><span data-stu-id="3b2cf-182">There are many protocols and choices you can use for communication, depending on the communication type you want to use.</span></span> <span data-ttu-id="3b2cf-183">Se si usa un meccanismo di comunicazione basato su richiesta/risposta sincrona, i protocolli come HTTP e REST sono i più comuni, soprattutto se si pubblicano i servizi all'esterno del cluster del microservizio o dell'host Docker.</span><span class="sxs-lookup"><span data-stu-id="3b2cf-183">If you are using a synchronous request/response-based communication mechanism, protocols such as HTTP and REST approaches are the most common, especially if you are publishing your services outside the Docker host or microservice cluster.</span></span> <span data-ttu-id="3b2cf-184">Se la comunicazione tra i servizi avviene internamente, ovvero all'interno del cluster del microservizio o dell'host Docker, è anche possibile usare i meccanismi di comunicazione in formato binario come la comunicazione remota di Service Fabric o WCF con TCP e formato binario.</span><span class="sxs-lookup"><span data-stu-id="3b2cf-184">If you are communicating between services internally (within your Docker host or microservices cluster) you might also want to use binary format communication mechanisms (like Service Fabric remoting or WCF using TCP and binary format).</span></span> <span data-ttu-id="3b2cf-185">In alternativa, è possibile usare i meccanismi di comunicazione asincrona basata su messaggi come AMQP.</span><span class="sxs-lookup"><span data-stu-id="3b2cf-185">Alternatively, you can use asynchronous, message-based communication mechanisms such as AMQP.</span></span>

<span data-ttu-id="3b2cf-186">Esistono inoltre diversi formati di messaggio come JSON o XML o anche formati binari che possono essere più efficienti.</span><span class="sxs-lookup"><span data-stu-id="3b2cf-186">There are also multiple message formats like JSON or XML, or even binary formats, which can be more efficient.</span></span> <span data-ttu-id="3b2cf-187">Se il formato binario scelto non è un formato standard, probabilmente non è una buona idea pubblicare pubblicamente i servizi mediante tale formato.</span><span class="sxs-lookup"><span data-stu-id="3b2cf-187">If your chosen binary format is not a standard, it is probably not a good idea to publicly publish your services using that format.</span></span> <span data-ttu-id="3b2cf-188">È possibile usare un formato non standard per la comunicazione interna tra microservizi,</span><span class="sxs-lookup"><span data-stu-id="3b2cf-188">You could use a non-standard format for internal communication between your microservices.</span></span> <span data-ttu-id="3b2cf-189">ad esempio per la comunicazione tra microservizi all'interno del cluster del microservizio o dell'host Docker (agenti di orchestrazione Docker o Azure Service Fabric) oppure per le applicazioni client proprietarie che comunicano con i microservizi.</span><span class="sxs-lookup"><span data-stu-id="3b2cf-189">You might do this when communicating between microservices within your Docker host or microservice cluster (Docker orchestrators or Azure Service Fabric), or for proprietary client applications that talk to the microservices.</span></span>

### <a name="requestresponse-communication-with-http-and-rest"></a><span data-ttu-id="3b2cf-190">Comunicazione di tipo richiesta/risposta con HTTP e REST</span><span class="sxs-lookup"><span data-stu-id="3b2cf-190">Request/response communication with HTTP and REST</span></span> 

<span data-ttu-id="3b2cf-191">Quando un client usa la comunicazione di tipo richiesta/risposta, invia una richiesta a un servizio, quindi il servizio elabora la richiesta e restituisce una risposta.</span><span class="sxs-lookup"><span data-stu-id="3b2cf-191">When a client uses request/response communication, it sends a request to a service, then the service processes the request and sends back a response.</span></span> <span data-ttu-id="3b2cf-192">La comunicazione di tipo richiesta/risposta è particolarmente indicata per eseguire query sui dati per un'interfaccia utente in tempo reale dalle app client.</span><span class="sxs-lookup"><span data-stu-id="3b2cf-192">Request/response communication is especially well suited for querying data for a real-time UI (a live user interface) from client apps.</span></span> <span data-ttu-id="3b2cf-193">Pertanto, in un'architettura di microservizi è probabilmente che si userà questo meccanismo di comunicazione per la maggior parte delle query, come illustrato nella figura 4-16.</span><span class="sxs-lookup"><span data-stu-id="3b2cf-193">Therefore, in a microservice architecture you will probably use this communication mechanism for most queries, as shown in Figure 4-16.</span></span>

![](./media/image16.png)

<span data-ttu-id="3b2cf-194">**Figura 4-16**.</span><span class="sxs-lookup"><span data-stu-id="3b2cf-194">**Figure 4-16**.</span></span> <span data-ttu-id="3b2cf-195">Uso della comunicazione di tipo richiesta/risposta HTTP (sincrona o asincrona)</span><span class="sxs-lookup"><span data-stu-id="3b2cf-195">Using HTTP request/response communication (synchronous or asynchronous)</span></span>

<span data-ttu-id="3b2cf-196">Quando un client usa la comunicazione di tipo richiesta/risposta, si presuppone che la risposta venga recapitata in breve tempo, in genere meno di un secondo o al massimo alcuni secondi.</span><span class="sxs-lookup"><span data-stu-id="3b2cf-196">When a client uses request/response communication, it assumes that the response will arrive in a short time, typically less than a second, or a few seconds at most.</span></span> <span data-ttu-id="3b2cf-197">Per le risposte ritardate, è necessario implementare la comunicazione asincrona in base a [schemi di messaggistica](https://docs.microsoft.com/azure/architecture/patterns/category/messaging) e [tecnologie di messaggistica](https://en.wikipedia.org/wiki/Message-oriented_middleware), che rappresenta un approccio diverso illustrato nella sezione successiva.</span><span class="sxs-lookup"><span data-stu-id="3b2cf-197">For delayed responses, you need to implement asynchronous communication based on [messaging patterns](https://docs.microsoft.com/azure/architecture/patterns/category/messaging) and [messaging technologies](https://en.wikipedia.org/wiki/Message-oriented_middleware), which is a different approach that we explain in the next section.</span></span>

<span data-ttu-id="3b2cf-198">Uno stile architetturale diffuso per la comunicazione di tipo richiesta/risposta è [REST](https://en.wikipedia.org/wiki/Representational_state_transfer).</span><span class="sxs-lookup"><span data-stu-id="3b2cf-198">A popular architectural style for request/response communication is [REST](https://en.wikipedia.org/wiki/Representational_state_transfer).</span></span> <span data-ttu-id="3b2cf-199">Questo approccio è basato sul protocollo [HTTP](https://en.wikipedia.org/wiki/Hypertext_Transfer_Protocol) a cui è strettamente collegato adottando verbi HTTP come GET, POST e PUT.</span><span class="sxs-lookup"><span data-stu-id="3b2cf-199">This approach is based on, and tightly coupled to, the [HTTP](https://en.wikipedia.org/wiki/Hypertext_Transfer_Protocol) protocol, embracing HTTP verbs like GET, POST, and PUT.</span></span> <span data-ttu-id="3b2cf-200">REST è l'approccio di comunicazione architetturale usato più di frequente quando si creano i servizi.</span><span class="sxs-lookup"><span data-stu-id="3b2cf-200">REST is the most commonly used architectural communication approach when creating services.</span></span> <span data-ttu-id="3b2cf-201">È possibile implementare i servizi REST quando si sviluppano i servizi API Web ASP.NET Core.</span><span class="sxs-lookup"><span data-stu-id="3b2cf-201">You can implement REST services when you develop ASP.NET Core Web API services.</span></span>

<span data-ttu-id="3b2cf-202">L'uso di servizi REST HTTP come linguaggio di definizione dell'interfaccia offre un valore aggiunto.</span><span class="sxs-lookup"><span data-stu-id="3b2cf-202">There is additional value when using HTTP REST services as your interface definition language.</span></span> <span data-ttu-id="3b2cf-203">Ad esempio, se si usano i [metadati Swagger](http://swagger.io/) per descrivere l'API del servizio, è possibile usare gli strumenti che generano gli stub client in grado di individuare e usare direttamente i servizi.</span><span class="sxs-lookup"><span data-stu-id="3b2cf-203">For instance, if you use [Swagger metadata](http://swagger.io/) to describe your service API, you can use tools that generate client stubs that can directly discover and consume your services.</span></span>

### <a name="additional-resources"></a><span data-ttu-id="3b2cf-204">Risorse aggiuntive</span><span class="sxs-lookup"><span data-stu-id="3b2cf-204">Additional resources</span></span>

-   <span data-ttu-id="3b2cf-205">**Martin Fowler. Richardson Maturity Model.**</span><span class="sxs-lookup"><span data-stu-id="3b2cf-205">**Martin Fowler. Richardson Maturity Model.**</span></span> <span data-ttu-id="3b2cf-206">Una descrizione del modello REST.</span><span class="sxs-lookup"><span data-stu-id="3b2cf-206">A description of the REST model.</span></span>
    [<span data-ttu-id="3b2cf-207">*http://martinfowler.com/articles/richardsonMaturityModel.html*</span><span class="sxs-lookup"><span data-stu-id="3b2cf-207">*http://martinfowler.com/articles/richardsonMaturityModel.html*</span></span>](http://martinfowler.com/articles/richardsonMaturityModel.html)

-   <span data-ttu-id="3b2cf-208">**Swagger.**</span><span class="sxs-lookup"><span data-stu-id="3b2cf-208">**Swagger.**</span></span> <span data-ttu-id="3b2cf-209">Il sito ufficiale.</span><span class="sxs-lookup"><span data-stu-id="3b2cf-209">The official site.</span></span>
    [<span data-ttu-id="3b2cf-210">*http://swagger.io/*</span><span class="sxs-lookup"><span data-stu-id="3b2cf-210">*http://swagger.io/*</span></span>](http://swagger.io/)

### <a name="push-and-real-time-communication-based-on-http"></a><span data-ttu-id="3b2cf-211">Comunicazione push e in tempo reale basata su HTTP</span><span class="sxs-lookup"><span data-stu-id="3b2cf-211">Push and real-time communication based on HTTP</span></span>

<span data-ttu-id="3b2cf-212">Un'altra possibilità (in genere per scopi diversi rispetto a REST) è una comunicazione in tempo reale e uno-a-molti con framework di livello superiore quali [ASP.NET SignalR](https://www.asp.net/signalr) e protocolli come [WebSocket](https://en.wikipedia.org/wiki/WebSocket).</span><span class="sxs-lookup"><span data-stu-id="3b2cf-212">Another possibility (usually for different purposes than REST) is a real-time and one-to-many communication with higher-level frameworks such as [ASP.NET SignalR](https://www.asp.net/signalr) and protocols such as [WebSockets](https://en.wikipedia.org/wiki/WebSocket).</span></span>

<span data-ttu-id="3b2cf-213">Come mostrato nella figura 4-17, la comunicazione HTTP in tempo reale significa che il server può eseguire il push del contenuto ai client connessi man mano che i dati diventano disponibili, anziché dover attendere che un client richieda nuovi dati.</span><span class="sxs-lookup"><span data-stu-id="3b2cf-213">As Figure 4-17 shows, real-time HTTP communication means that you can have server code pushing content to connected clients as the data becomes available, rather than having the server wait for a client to request new data.</span></span>

![](./media/image17.png)

<span data-ttu-id="3b2cf-214">**Figura 4-17**.</span><span class="sxs-lookup"><span data-stu-id="3b2cf-214">**Figure 4-17**.</span></span> <span data-ttu-id="3b2cf-215">Comunicazione asincrona di messaggi in tempo reale uno-a-uno</span><span class="sxs-lookup"><span data-stu-id="3b2cf-215">One-to-one real-time asynchronous message communication</span></span>

<span data-ttu-id="3b2cf-216">Poiché la comunicazione è in tempo reale, le app client mostrano le modifiche quasi immediatamente.</span><span class="sxs-lookup"><span data-stu-id="3b2cf-216">Since communication is in real time, client apps show the changes almost instantly.</span></span> <span data-ttu-id="3b2cf-217">Questa operazione viene in genere gestita da un protocollo, ad esempio WebSocket, usando molte connessioni WebSocket (una per ogni client).</span><span class="sxs-lookup"><span data-stu-id="3b2cf-217">This is usually handled by a protocol such as WebSockets, using many WebSockets connections (one per client).</span></span> <span data-ttu-id="3b2cf-218">Un esempio tipico è quando un servizio comunica contemporaneamente una modifica del punteggio di un gioco sportivo alle app Web di molti client.</span><span class="sxs-lookup"><span data-stu-id="3b2cf-218">A typical example is when a service communicates a change in the score of a sports game to many client web apps simultaneously.</span></span>


>[!div class="step-by-step"]
<span data-ttu-id="3b2cf-219">[Indietro] (direct-client-to-microservice-communication-versus-the-api-gateway-pattern.md) [Avanti] (asynchronous-message-based-communication.md)</span><span class="sxs-lookup"><span data-stu-id="3b2cf-219">[Previous] (direct-client-to-microservice-communication-versus-the-api-gateway-pattern.md) [Next] (asynchronous-message-based-communication.md)</span></span>
