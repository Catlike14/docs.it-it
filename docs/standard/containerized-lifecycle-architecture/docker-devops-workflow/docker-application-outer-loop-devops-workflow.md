---
title: Passaggi nel flusso di lavoro DevOps ciclo esterno per un'applicazione di Docker
description: Ciclo di vita delle applicazioni Docker in contenitori con piattaforma e strumenti Microsoft
author: CESARDELATORRE
ms.author: wiwagn
ms.date: 09/22/2017
ms.openlocfilehash: b88eb5637bf266ab2e0a6d255f2e83f6aadc8af2
ms.sourcegitcommit: 979597cd8055534b63d2c6ee8322938a27d0c87b
ms.translationtype: MT
ms.contentlocale: it-IT
ms.lasthandoff: 06/29/2018
ms.locfileid: "37106162"
---
# <a name="steps-in-the-outer-loop-devops-workflow-for-a-docker-application"></a><span data-ttu-id="6ae7c-103">Passaggi nel flusso di lavoro DevOps ciclo esterno per un'applicazione di Docker</span><span class="sxs-lookup"><span data-stu-id="6ae7c-103">Steps in the outer-loop DevOps workflow for a Docker application</span></span>

<span data-ttu-id="6ae7c-104">Figura 5-1 presenta un'immagine di end-to-end dei passaggi che costituiscono il flusso di lavoro ciclo esterno DevOps.</span><span class="sxs-lookup"><span data-stu-id="6ae7c-104">Figure 5-1 presents an end-to-end depiction of the steps comprising the DevOps outer-loop workflow.</span></span>

![](./media/image1.png)

<span data-ttu-id="6ae7c-105">Figura 5-1: DevOps ciclo esterno flusso di lavoro per le applicazioni di Docker con gli strumenti di Microsoft</span><span class="sxs-lookup"><span data-stu-id="6ae7c-105">Figure 5-1: DevOps outer-loop workflow for Docker applications with Microsoft tools</span></span>

<span data-ttu-id="6ae7c-106">A questo punto, si esamineranno ognuno di questi passaggi in maggiore dettaglio.</span><span class="sxs-lookup"><span data-stu-id="6ae7c-106">Now, let's examine each of these steps in greater detail.</span></span>

## <a name="step-1-inner-loop-development-workflow"></a><span data-ttu-id="6ae7c-107">Passaggio 1: Il lavoro di sviluppo ciclo interno</span><span class="sxs-lookup"><span data-stu-id="6ae7c-107">Step 1: Inner-loop development workflow</span></span>

<span data-ttu-id="6ae7c-108">Questo passaggio è illustrato in dettaglio nel capitolo 4, ma, per ricapitolare, ecco in cui inizia il ciclo esterno, dal momento in cui uno sviluppatore inserisce codice per il sistema di gestione del controllo origine (ad esempio Git) di inizializzazione di azioni di pipeline CI.</span><span class="sxs-lookup"><span data-stu-id="6ae7c-108">This step is explained in detail in Chapter 4, but, to recap, here is where the outer-loop begins, the moment at which a developer pushes code to the source control management system (like Git) initiating CI pipeline actions.</span></span>

## <a name="step-2-source-code-control-integration-and-management-with-visual-studio-team-services-and-git"></a><span data-ttu-id="6ae7c-109">Passaggio 2: Integrazione di controllo del codice sorgente e la gestione con Visual Studio Team Services e Git</span><span class="sxs-lookup"><span data-stu-id="6ae7c-109">Step 2: Source-Code Control integration and management with Visual Studio Team Services and Git</span></span>

<span data-ttu-id="6ae7c-110">In questo passaggio, è necessario disporre di un sistema di controllo della versione per raccogliere una versione consolidata di tutto il codice proveniente da sviluppatori diversi del team.</span><span class="sxs-lookup"><span data-stu-id="6ae7c-110">At this step, you need to have a version-control system to gather a consolidated version of all the code coming from the different developers in the team.</span></span>

<span data-ttu-id="6ae7c-111">Anche se può sembrare natura secondo ciclo alla maggior parte degli sviluppatori, quando si creano applicazioni di Docker in una vita di DevOps di controllo del codice sorgente (SCC) e la gestione del codice sorgente, è importante sottolineare che non è necessario inviare le immagini Docker con l'applicazione direttamente al globale Docker Registro di sistema (ad esempio del Registro di sistema contenitore di Azure o Hub Docker) dal computer dello sviluppatore.</span><span class="sxs-lookup"><span data-stu-id="6ae7c-111">Even though source-code control (SCC) and source-code management might seem second-nature to most developers, when creating Docker applications in a DevOps life cycle, it is critical to emphasize that you must not submit the Docker images with the application directly to the global Docker Registry (like Azure Container Registry or Docker Hub) from the developer's machine.</span></span> <span data-ttu-id="6ae7c-112">Al contrario, le immagini Docker per essere rilasciata e distribuiti in ambienti di produzione devono essere create esclusivamente sul codice sorgente che viene integrato nella compilazione globale o nella pipeline CI in base al repository di codice sorgente (ad esempio Git).</span><span class="sxs-lookup"><span data-stu-id="6ae7c-112">On the contrary, the Docker images to be released and deployed to production environments must be created solely on the source code that is being integrated in your global build or CI pipeline based on your source-code repository (like Git).</span></span>

<span data-ttu-id="6ae7c-113">Le immagini locali create dagli sviluppatori stessi consigliabile utilizzarlo solo per gli sviluppatori durante il test nelle proprie macchine.</span><span class="sxs-lookup"><span data-stu-id="6ae7c-113">The local images generated by the developers themselves should be used just by the developers when testing within their own machines.</span></span> <span data-ttu-id="6ae7c-114">Ecco perché è essenziale per la pipeline DevOps attivata dal codice di controllo del codice sorgente.</span><span class="sxs-lookup"><span data-stu-id="6ae7c-114">This is why it is critical to have the DevOps pipeline activated from the SCC code.</span></span>

<span data-ttu-id="6ae7c-115">Visual Studio Team Services e Team Foundation Server supporta Git e Team Foundation Version Control.</span><span class="sxs-lookup"><span data-stu-id="6ae7c-115">Visual Studio Team Services and Team Foundation Server support Git and Team Foundation Version Control.</span></span> <span data-ttu-id="6ae7c-116">È possibile scegliere tra di essi e usarlo per un'esperienza di Microsoft end-to-end.</span><span class="sxs-lookup"><span data-stu-id="6ae7c-116">You can choose between them and use it for an end-to-end Microsoft experience.</span></span> <span data-ttu-id="6ae7c-117">Tuttavia, è anche possibile gestire il codice in un repository esterno (ad esempio GitHub, repository Git locale o Subversion) e ancora essere in grado di connettersi ad esso e ottenere il codice come punto di partenza per la pipeline CI DevOps.</span><span class="sxs-lookup"><span data-stu-id="6ae7c-117">However, you also can manage your code in external repositories (like GitHub, on-premises Git repositories, or Subversion) and still be able to connect to it and get the code as the starting point for your DevOps CI pipeline.</span></span>

## <a name="step-3-build-ci-integrate-and-test-with-visual-studio-team-services-and-docker"></a><span data-ttu-id="6ae7c-118">Passaggio 3: Compilazione CI, integrare e testare con Visual Studio Team Services e Docker</span><span class="sxs-lookup"><span data-stu-id="6ae7c-118">Step 3: Build, CI, Integrate, and Test with Visual Studio Team Services and Docker</span></span>

<span data-ttu-id="6ae7c-119">CI è apparsa come standard per il testing di software moderno e recapito.</span><span class="sxs-lookup"><span data-stu-id="6ae7c-119">CI has emerged as a standard for modern software testing and delivery.</span></span> <span data-ttu-id="6ae7c-120">La soluzione di Docker mantiene una netta separazione delle problematiche tra i team di sviluppo e le operazioni.</span><span class="sxs-lookup"><span data-stu-id="6ae7c-120">The Docker solution maintains a clear separation of concerns between the development and operations teams.</span></span> <span data-ttu-id="6ae7c-121">Immutabilità delle immagini Docker garantisce una distribuzione ripetibile tra ciò che ha sviluppato, testato mediante CI ed eseguire nell'ambiente di produzione.</span><span class="sxs-lookup"><span data-stu-id="6ae7c-121">The immutability of Docker images ensures a repeatable deployment between what's developed, tested through CI, and run in production.</span></span> <span data-ttu-id="6ae7c-122">Motore docker distribuite tra più portatili sviluppatore e dell'infrastruttura di test rende i contenitori portabile tra gli ambienti.</span><span class="sxs-lookup"><span data-stu-id="6ae7c-122">Docker Engine deployed across the developer laptops and test infrastructure makes the containers portable across environments.</span></span>

<span data-ttu-id="6ae7c-123">A questo punto, dopo aver creato un sistema di controllo della versione con il codice corretto inviato, è necessario un *servizio di compilazione* per prelevare il codice ed eseguire i test e alla build globale.</span><span class="sxs-lookup"><span data-stu-id="6ae7c-123">At this point, after you have a version-control system with the correct code submitted, you need a *build service* to pick up the code and run the global build and tests.</span></span>

<span data-ttu-id="6ae7c-124">Il flusso di lavoro interno per questo passaggio (elemento di configurazione, compilazione, test) riguarda la costruzione di una pipeline CI costituito il repository di codice (Git, e così via), il server di compilazione (Visual Studio Team Services), il motore Docker e un registro di sistema di Docker.</span><span class="sxs-lookup"><span data-stu-id="6ae7c-124">The internal workflow for this step (CI, build, test) is about the construction of a CI pipeline consisting of your code repository (Git, etc.), your build server (Visual Studio Team Services), Docker Engine, and a Docker Registry.</span></span>

<span data-ttu-id="6ae7c-125">È possibile utilizzare Visual Studio Team Services come base per la compilazione di applicazioni e l'impostazione di pipeline dell'elemento di configurazione e per la pubblicazione compilati "elementi" per un "repository di artefatti," descritta nel passaggio successivo.</span><span class="sxs-lookup"><span data-stu-id="6ae7c-125">You can use Visual Studio Team Services as the foundation for building your applications and setting your CI pipeline, and for publishing the built "artifacts" to an "artifacts repository," which is explained in the next step.</span></span>

<span data-ttu-id="6ae7c-126">Quando si usa Docker per la distribuzione, gli elementi"finale" da distribuire immagini Docker con l'applicazione o servizi incorporate all'interno di essi.</span><span class="sxs-lookup"><span data-stu-id="6ae7c-126">When using Docker for the deployment, the "final artifacts" to be deployed are Docker images with your application or services embedded within them.</span></span> <span data-ttu-id="6ae7c-127">Queste immagini sono push o pubblicate in un *Registro di sistema di Docker* (vale a dire un archivio privato, ad esempio quelli a cui è possibile che nel Registro di sistema contenitore di Azure o di una pubblica, ad esempio del Registro di sistema dell'Hub Docker, che viene usato comunemente per le immagini di base ufficiale).</span><span class="sxs-lookup"><span data-stu-id="6ae7c-127">Those images are pushed or published to a *Docker Registry* (a private repository like the ones you can have in Azure Container Registry, or a public one like Docker Hub Registry, which is commonly used for official base images).</span></span>

<span data-ttu-id="6ae7c-128">Ecco il concetto di base: CI la pipeline verrà interrotto utilizzato da un commit a un repository di controllo del codice sorgente come Git.</span><span class="sxs-lookup"><span data-stu-id="6ae7c-128">Here is the basic concept: The CI pipeline will be kicked-off by a commit to an SCC repository like Git.</span></span> <span data-ttu-id="6ae7c-129">Il commit causerà Visual Studio Team Services eseguire un processo di compilazione all'interno di un contenitore Docker e, al completamento di tale processo, eseguire il push un'immagine Docker nel Registro di sistema di Docker, come illustrato nella figura 5-2.</span><span class="sxs-lookup"><span data-stu-id="6ae7c-129">The commit will cause Visual Studio Team Services to run a build job within a Docker container and, upon successful completion of that job, push a Docker image to the Docker Registry, as illustrated in Figure 5-2.</span></span>

![](./media/image2.png)

<span data-ttu-id="6ae7c-130">Figura 5-2: I passaggi coinvolti in CI</span><span class="sxs-lookup"><span data-stu-id="6ae7c-130">Figure 5-2: The steps involved in CI</span></span>

<span data-ttu-id="6ae7c-131">Ecco i passaggi di base degli elementi di configurazione del flusso di lavoro con Docker e Visual Studio Team Services:</span><span class="sxs-lookup"><span data-stu-id="6ae7c-131">Here are the basic CI workflow steps with Docker and Visual Studio Team Services:</span></span>

1.  <span data-ttu-id="6ae7c-132">Lo sviluppatore inserisce un commit a un repository di controllo del codice sorgente (Git/Visual Studio Team Services, GitHub e così via).</span><span class="sxs-lookup"><span data-stu-id="6ae7c-132">The developer pushes a commit to an SCC repository (Git/Visual Studio Team Services, GitHub, etc.).</span></span>

2.  <span data-ttu-id="6ae7c-133">Se si usa Visual Studio Team Services o Git, CI è incorporata, che significa che è sufficiente selezionare una casella di controllo in Visual Studio Team Services.</span><span class="sxs-lookup"><span data-stu-id="6ae7c-133">If you're using Visual Studio Team Services or Git, CI is built in, which means that it is as simple as selecting a check box in Visual Studio Team Services.</span></span> <span data-ttu-id="6ae7c-134">Se si usa un controllo del codice sorgente esterno (ad esempio GitHub), un *webhook* verrà avvisare Visual Studio Team Services dell'aggiornamento o eseguire il push in GitHub/Git.</span><span class="sxs-lookup"><span data-stu-id="6ae7c-134">If you're using an external SCC (like GitHub), a *webhook* will notify Visual Studio Team Services of the update or push to Git/GitHub.</span></span>

3.  <span data-ttu-id="6ae7c-135">Visual Studio Team Services estrae il repository SCC, inclusi il DockerFile che descrivono l'immagine, nonché il codice dell'applicazione e di test.</span><span class="sxs-lookup"><span data-stu-id="6ae7c-135">Visual Studio Team Services pulls the SCC repository, including the DockerFile describing the image as well as the application and test code.</span></span>

4.  <span data-ttu-id="6ae7c-136">Visual Studio Team Services crea un'immagine Docker e l'etichetta con un numero di build.</span><span class="sxs-lookup"><span data-stu-id="6ae7c-136">Visual Studio Team Services builds a Docker image and labels it with a build number.</span></span>

5.  <span data-ttu-id="6ae7c-137">Visual Studio Team Services crea un'istanza del contenitore Docker all'interno dell'Host Docker sottoposto a provisioning e vengono eseguiti i test appropriati.</span><span class="sxs-lookup"><span data-stu-id="6ae7c-137">Visual Studio Team Services instantiates the Docker container within the provisioned Docker Host, and runs the appropriate tests.</span></span>

6.  <span data-ttu-id="6ae7c-138">Se i test hanno esito positivo, l'immagine viene innanzitutto cui per un nome significativo, in modo da sapere è una build"documento" (ad esempio "/ 1.0.0" o qualsiasi altra etichetta) e quindi inseriti nel Registro di sistema Docker (Hub Docker, del Registro di sistema di Azure contenitore, DTR e così via)</span><span class="sxs-lookup"><span data-stu-id="6ae7c-138">If the tests are successful, the image is first relabeled to a meaningful name so that you know it is a "blessed build" (like "/1.0.0" or any other label), and then pushed up to your Docker Registry (Docker Hub, Azure Container Registry, DTR, etc.)</span></span>

### <a name="implementing-the-ci-pipeline-with-visual-studio-team-services-and-the-docker-extension-for-visual-studio-team-services"></a><span data-ttu-id="6ae7c-139">Implementazione della pipeline CI con Visual Studio Team Services e l'estensione Docker per Visual Studio Team Services</span><span class="sxs-lookup"><span data-stu-id="6ae7c-139">Implementing the CI pipeline with Visual Studio Team Services and the Docker extension for Visual Studio Team Services</span></span>

<span data-ttu-id="6ae7c-140">Il [estensione di Visual Studio Team Services Docker](https://aka.ms/vstsdockerextension) aggiunge un'attività alla pipeline dell'elemento di configurazione con cui è possibile costruire immagini Docker, push immagini Docker in un registro Docker autenticato, eseguire le immagini Docker o eseguire altre operazioni offerti dal Docker CLI.</span><span class="sxs-lookup"><span data-stu-id="6ae7c-140">The [Visual Studio Team Services Docker extension](https://aka.ms/vstsdockerextension) adds a task to your CI pipeline with which you can build Docker images, push Docker images to an authenticated Docker registry, run Docker images, or run other operations offered by the Docker CLI.</span></span> <span data-ttu-id="6ae7c-141">Aggiunge anche un'attività Docker Compose che è possibile utilizzare per compilare, eseguire il push ed eseguire multicontainer Docker applicazioni o eseguire altre operazioni offerti l'interfaccia CLI comporre Docker, come illustrato nella figura 5-3.</span><span class="sxs-lookup"><span data-stu-id="6ae7c-141">It also adds a Docker Compose task that you can use to build, push, and run multicontainer Docker applications, or run other operations offered by the Docker Compose CLI, as shown in Figure 5-3.</span></span>

![](./media/image3.png)

<span data-ttu-id="6ae7c-142">Figura 5-3: la pipeline di elementi di configurazione di Docker in Visual Studio Team Services</span><span class="sxs-lookup"><span data-stu-id="6ae7c-142">Figure 5-3: The Docker CI pipeline in Visual Studio Team Services</span></span>

<span data-ttu-id="6ae7c-143">L'estensione Docker è possibile utilizzare gli endpoint del servizio per gli host Docker e del contenitore o i registri di immagine.</span><span class="sxs-lookup"><span data-stu-id="6ae7c-143">The Docker extension can use service endpoints for Docker hosts and for container or image registries.</span></span> <span data-ttu-id="6ae7c-144">Il valore predefinito di attività per l'utilizzo di un host Docker locale, se disponibile (attualmente è necessario un agente di Visual Studio Team Services personalizzato); in caso contrario, è necessario fornire una connessione all'host Docker.</span><span class="sxs-lookup"><span data-stu-id="6ae7c-144">The tasks default to using a local Docker host if available (this currently requires a custom Visual Studio Team Services agent); otherwise, they require that you provide a Docker host connection.</span></span> <span data-ttu-id="6ae7c-145">Le azioni che dipendono l'autenticazione con un Docker del Registro di sistema, ad esempio il push di un'immagine, è necessario che venga fornito una Docker connessione del Registro di sistema.</span><span class="sxs-lookup"><span data-stu-id="6ae7c-145">Actions that depend on being authenticated with a Docker registry, such as pushing an image, require that you provide a Docker registry connection.</span></span>

<span data-ttu-id="6ae7c-146">L'estensione di Visual Studio Team Services Docker vengono installati i componenti seguenti nell'account di Visual Studio Team Services:</span><span class="sxs-lookup"><span data-stu-id="6ae7c-146">The Visual Studio Team Services Docker extension installs the following components in your Visual Studio Team Services account:</span></span>

-   <span data-ttu-id="6ae7c-147">Un endpoint del servizio per la connessione a un registro di sistema di Docker</span><span class="sxs-lookup"><span data-stu-id="6ae7c-147">A service endpoint for connecting to a Docker registry</span></span>

-   <span data-ttu-id="6ae7c-148">Un endpoint del servizio per la connessione a un Host del contenitore Docker</span><span class="sxs-lookup"><span data-stu-id="6ae7c-148">A service endpoint for connecting to a Docker Container Host</span></span>

-   <span data-ttu-id="6ae7c-149">Un'attività di Docker per le operazioni seguenti:</span><span class="sxs-lookup"><span data-stu-id="6ae7c-149">A Docker task to do the following:</span></span>

-   <span data-ttu-id="6ae7c-150">Compilare un'immagine</span><span class="sxs-lookup"><span data-stu-id="6ae7c-150">Build an image</span></span>

-   <span data-ttu-id="6ae7c-151">Push un'immagine o un repository di un registro di sistema</span><span class="sxs-lookup"><span data-stu-id="6ae7c-151">Push an image or a repository to a registry</span></span>

-   <span data-ttu-id="6ae7c-152">Eseguire un'immagine in un contenitore</span><span class="sxs-lookup"><span data-stu-id="6ae7c-152">Run an image in a container</span></span>

-   <span data-ttu-id="6ae7c-153">Eseguire un comando di Docker</span><span class="sxs-lookup"><span data-stu-id="6ae7c-153">Run a Docker command</span></span>

-   <span data-ttu-id="6ae7c-154">Un'attività per eseguire un comando di Docker Compose Docker Compose</span><span class="sxs-lookup"><span data-stu-id="6ae7c-154">A Docker Compose task to run a Docker Compose command</span></span>

<span data-ttu-id="6ae7c-155">Con queste attività di Visual Studio Team Services, una generazione macchina virtuale Host Docker Linux/provisioning in Azure e preferito Docker Registro di sistema (del Registro di sistema di Azure contenitore, Hub Docker, DTR Docker privato o qualsiasi altro Docker del Registro di sistema) è possibile assemblare le pipeline CI Docker in un molto coerente.</span><span class="sxs-lookup"><span data-stu-id="6ae7c-155">With these Visual Studio Team Services tasks, a build Linux-Docker Host/VM provisioned in Azure and your preferred Docker registry (Azure Container Registry, Docker Hub, private Docker DTR, or any other Docker registry) you can assemble your Docker CI pipeline in a very consistent way.</span></span>

<span data-ttu-id="6ae7c-156">***Requisiti:***</span><span class="sxs-lookup"><span data-stu-id="6ae7c-156">***Requirements:***</span></span>

-   <span data-ttu-id="6ae7c-157">Visual Studio Team Services o per le installazioni locali, Team Foundation Server 2015 Update 3 o versione successiva.</span><span class="sxs-lookup"><span data-stu-id="6ae7c-157">Visual Studio Team Services, or for on-premises installations, Team Foundation Server 2015 Update 3 or later.</span></span>

-   <span data-ttu-id="6ae7c-158">Un agente di Visual Studio Team Services con i file binari di Docker.</span><span class="sxs-lookup"><span data-stu-id="6ae7c-158">A Visual Studio Team Services agent that has the Docker binaries.</span></span>

<span data-ttu-id="6ae7c-159">Un modo semplice per creare uno di questi consiste nell'utilizzare Docker per eseguire un contenitore in base all'immagine di Docker dell'agente di Visual Studio Team Services.</span><span class="sxs-lookup"><span data-stu-id="6ae7c-159">An easy way to create one of these is to use Docker to run a container based on the Visual Studio Team Services agent Docker image.</span></span>

<span data-ttu-id="6ae7c-160">**Altre informazioni** leggere approfondire le proprie assemblaggio un Visual Studio Team Services Docker degli elementi di configurazione di pipeline e per visualizzare procedure dettagliate, visitare i siti seguenti:</span><span class="sxs-lookup"><span data-stu-id="6ae7c-160">**More info** To read more about assembling a Visual Studio Team Services Docker CI pipeline and to view walkthroughs, visit the following sites:</span></span>

<span data-ttu-id="6ae7c-161">In esecuzione un agente di Visual Studio Team Services come un contenitore Docker: [ https://hub.docker.com/r/\ -agente di vsts di microsoft / /](https://hub.docker.com/r/microsoft/vsts-agent/)</span><span class="sxs-lookup"><span data-stu-id="6ae7c-161">Running a Visual Studio Team Services agent as a Docker container: [https://hub.docker.com/r/\ microsoft/vsts-agent/](https://hub.docker.com/r/microsoft/vsts-agent/)</span></span>

<span data-ttu-id="6ae7c-162">Estensione Docker di Visual Studio Team Services: <https://aka.ms/vstsdockerextension></span><span class="sxs-lookup"><span data-stu-id="6ae7c-162">VSTS Docker extension: <https://aka.ms/vstsdockerextension></span></span>

<span data-ttu-id="6ae7c-163">La creazione di immagini di .NET Core Linux Docker con Visual Studio Team Services: <https://blogs.msdn.microsoft.com/stevelasker/2016/06/13/building-net-core-linux-docker-images-with-visual-studio-team-services/></span><span class="sxs-lookup"><span data-stu-id="6ae7c-163">Building .NET Core Linux Docker images with Visual Studio Team Services: <https://blogs.msdn.microsoft.com/stevelasker/2016/06/13/building-net-core-linux-docker-images-with-visual-studio-team-services/></span></span>

<span data-ttu-id="6ae7c-164">La creazione di un computer di compilazione del servizio Visual Studio Team basati su Linux con il supporto di Docker: <http://donovanbrown.com/post/2016/06/03/Building-a-Linux-Based-Visual-Studio-Team-Service-Build-Machine-with-Docker-Support></span><span class="sxs-lookup"><span data-stu-id="6ae7c-164">Building a Linux-based Visual Studio Team Service build machine with Docker support: <http://donovanbrown.com/post/2016/06/03/Building-a-Linux-Based-Visual-Studio-Team-Service-Build-Machine-with-Docker-Support></span></span>

### <a name="integrate-test-and-validate-multicontainer-docker-applications"></a><span data-ttu-id="6ae7c-165">Integrare, testare e convalidare multicontainer applicazioni di Docker</span><span class="sxs-lookup"><span data-stu-id="6ae7c-165">Integrate, test, and validate multicontainer Docker applications</span></span>

<span data-ttu-id="6ae7c-166">In genere, la maggior parte delle applicazioni di Docker sono composti da più contenitori anziché un singolo contenitore.</span><span class="sxs-lookup"><span data-stu-id="6ae7c-166">Typically, most Docker applications are composed of multiple containers rather than a single container.</span></span> <span data-ttu-id="6ae7c-167">Un buon esempio è un'applicazione orientata ai servizi microservizi per i quali è un contenitore per ogni microservizio.</span><span class="sxs-lookup"><span data-stu-id="6ae7c-167">A good example is a microservices-oriented application for which you would have one container per microservice.</span></span> <span data-ttu-id="6ae7c-168">Ma, anche senza criteri approccio microservizi rigorosamente seguenti, è molto probabile che l'applicazione di Docker potrebbe essere composti da più servizi o i contenitori.</span><span class="sxs-lookup"><span data-stu-id="6ae7c-168">But, even without strictly following the microservices approach patterns, it is very probable that your Docker application would be composed of multiple containers or services.</span></span>

<span data-ttu-id="6ae7c-169">Pertanto, dopo la creazione dei contenitori di applicazioni nella pipeline di elementi di configurazione, è necessario distribuire, integrare e testare l'applicazione nel suo complesso con tutti i relativi contenitori all'interno di un host Docker integrazione o persino in un cluster di test al quale sono limitate ai contenitori distribuito.</span><span class="sxs-lookup"><span data-stu-id="6ae7c-169">Therefore, after building the application containers in the CI pipeline, you also need to deploy, integrate, and test the application as a whole with all of its containers within an integration Docker host or even into a test cluster to which your containers are distributed.</span></span>

<span data-ttu-id="6ae7c-170">Se si usa un singolo host, è possibile utilizzare i comandi di Docker, ad esempio docker-comporre per compilare e distribuire i contenitori correlati per testare e convalidare l'ambiente di Docker in una singola macchina virtuale.</span><span class="sxs-lookup"><span data-stu-id="6ae7c-170">If you're using a single host, you can use Docker commands such as docker-compose to build and deploy related containers to test and validate the Docker environment in a single VM.</span></span> <span data-ttu-id="6ae7c-171">Tuttavia, se si lavora con un cluster di orchestrator come controller di dominio/OS, Kubernetes o Docker Swarm, è necessario distribuire i contenitori tramite un meccanismo diverso o un agente di orchestrazione, in base alla propria selezionato cluster/utilità di pianificazione.</span><span class="sxs-lookup"><span data-stu-id="6ae7c-171">But, if you are working with an orchestrator cluster like DC/OS, Kubernetes, or Docker Swarm, you need to deploy your containers through a different mechanism or orchestrator, depending on your selected cluster/scheduler.</span></span>

<span data-ttu-id="6ae7c-172">Di seguito sono diversi tipi di test che è possibile eseguire in contenitori Docker:</span><span class="sxs-lookup"><span data-stu-id="6ae7c-172">Following are several types of tests that you can run against Docker containers:</span></span>

-   <span data-ttu-id="6ae7c-173">Unit test per i contenitori di Docker</span><span class="sxs-lookup"><span data-stu-id="6ae7c-173">Unit tests for Docker containers</span></span>

-   <span data-ttu-id="6ae7c-174">Gruppi di test di applicazioni correlate o microservizi</span><span class="sxs-lookup"><span data-stu-id="6ae7c-174">Testing groups of interrelated applications or microservices</span></span>

-   <span data-ttu-id="6ae7c-175">Nelle versioni di produzione e "Canarie" di test</span><span class="sxs-lookup"><span data-stu-id="6ae7c-175">Test in production and "canary" releases</span></span>

<span data-ttu-id="6ae7c-176">L'aspetto importante è che, durante l'esecuzione di test funzionali e integrazione, è necessario eseguire tali test di fuori dei contenitori.</span><span class="sxs-lookup"><span data-stu-id="6ae7c-176">The important point is that when running integration and functional tests, you must run those tests from outside of the containers.</span></span> <span data-ttu-id="6ae7c-177">Test è necessario non essere definite ed eseguite all'interno di contenitori che si desidera distribuire, poiché i contenitori sono basati sulle immagini statiche che devono essere simili a quelli che verranno distribuiti nell'ambiente di produzione.</span><span class="sxs-lookup"><span data-stu-id="6ae7c-177">Tests must not be defined and run within the containers that you are deploying, because the containers are based on static images that should be exactly like those that you will be deploying into production.</span></span>

<span data-ttu-id="6ae7c-178">Una soluzione molto attuabile durante il test di scenari più avanzati, ad esempio test diversi cluster (test cluster, gestione temporanea del cluster e cluster in produzione) consiste nel pubblicare le immagini a un registro di sistema per eseguire il test nei cluster diversi.</span><span class="sxs-lookup"><span data-stu-id="6ae7c-178">A very feasible option when testing more advanced scenarios like testing several clusters (test cluster, staging cluster, and production cluster) is to publish the images to a registry to test in various clusters.</span></span>

### <a name="push-the-custom-application-docker-image-into-your-global-docker-registry"></a><span data-ttu-id="6ae7c-179">Eseguire il push l'immagine di Docker applicazione personalizzata nel Registro di sistema globale di Docker</span><span class="sxs-lookup"><span data-stu-id="6ae7c-179">Push the custom application Docker image into your global Docker Registry</span></span>

<span data-ttu-id="6ae7c-180">Dopo avranno testate e convalidate le immagini Docker, è opportuno assegnare contrassegni e pubblicarli nel Registro di sistema Docker.</span><span class="sxs-lookup"><span data-stu-id="6ae7c-180">After the Docker images have been tested and validated, you'll want to tag and publish them to your Docker registry.</span></span> <span data-ttu-id="6ae7c-181">Il Registro di sistema di Docker è un'informazione fondamentale nel ciclo di vita dell'applicazione Docker perché è la posizione centrale in cui si archiviano i test personalizzati (noto anche come "documento immagini") da distribuire in ambienti QA e produzione.</span><span class="sxs-lookup"><span data-stu-id="6ae7c-181">The Docker registry is a critical piece in the Docker application life cycle because it is the central place where you store your custom test (aka "blessed images") to be deployed into QA and production environments.</span></span>

<span data-ttu-id="6ae7c-182">Simile al modo in cui il codice dell'applicazione archiviato nel repository del controllo del codice sorgente (Git, e così via) è il "origine di dati reali", il Registro di sistema di Docker è "origine di dati reali" per l'applicazione binario o bit da distribuire in ambienti di produzione o di conferma del controllo.</span><span class="sxs-lookup"><span data-stu-id="6ae7c-182">Similar to how the application code stored in your SCC repository (Git, etc.) is your "source of truth," the Docker registry is your "source of truth" for your binary application or bits to be deployed to the QA or production environments.</span></span>

<span data-ttu-id="6ae7c-183">In genere, si potrebbe voler essere il repository privati per le immagini personalizzate in un repository privato nel Registro di sistema contenitore di Azure o in un registro di sistema locale, ad esempio registro attendibile Docker o nel Registro di sistema di cloud pubblico con accesso limitato (ad esempio Hub docker), anche se in quest'ultimo caso, se il codice non è open source, deve considerare attendibile la sicurezza del fornitore.</span><span class="sxs-lookup"><span data-stu-id="6ae7c-183">Typically, you might want to have your private repositories for your custom images either in a private repository in Azure Container Registry or in an on-premises registry like Docker Trusted Registry, or in a public-cloud registry with restricted access (like Docker Hub), although in this last case if your code is not open source, you must trust the vendor's security.</span></span> <span data-ttu-id="6ae7c-184">In entrambi i casi, il metodo mediante il quale si esegue questa operazione è piuttosto simile ed è in definitiva basato sul comando docker push, come illustrato nella figura 5-4.</span><span class="sxs-lookup"><span data-stu-id="6ae7c-184">Either way, the method by which you do this is pretty similar and ultimately based on the docker push command, as depicted in Figure 5-4.</span></span>

![](./media/image4.png)

<span data-ttu-id="6ae7c-185">Figura 5-4: pubblicazione di immagini personalizzate al Registro di sistema di Docker</span><span class="sxs-lookup"><span data-stu-id="6ae7c-185">Figure 5-4: Publishing custom images to Docker Registry</span></span>

<span data-ttu-id="6ae7c-186">Ci sono più offerte di registri Docker da fornitori di cloud, ad esempio del Registro di sistema di Azure contenitore del Registro di sistema di Amazon Web Services contenitore, del Registro di sistema di Google contenitore, Quay del Registro di sistema e così via.</span><span class="sxs-lookup"><span data-stu-id="6ae7c-186">There are multiple offerings of Docker registries from cloud vendors like Azure Container Registry, Amazon Web Services Container Registry, Google Container Registry, Quay Registry, and so on.</span></span>

<span data-ttu-id="6ae7c-187">Utilizza l'estensione di Visual Studio Team Services Docker, è possibile distribuire un set di immagini di servizio definiti da un file docker compose.yml, con più tag, a un autenticato Docker del Registro di sistema (ad esempio Azure contenitore del Registro di sistema), come illustrato nella figura 5-5.</span><span class="sxs-lookup"><span data-stu-id="6ae7c-187">Using the Visual Studio Team Services Docker extension, you can push a set of service images defined by a docker-compose.yml file, with multiple tags, to an authenticated Docker registry (like Azure Container Registry), as shown in Figure 5-5.</span></span>

![](./media/image5.png)

<span data-ttu-id="6ae7c-188">Figura 5-5: utilizzo di Visual Studio Team Services per pubblicazione immagini personalizzate a un registro di sistema di Docker</span><span class="sxs-lookup"><span data-stu-id="6ae7c-188">Figure 5-5: Using Visual Studio Team Services to publishing custom images to a Docker Registry</span></span>

<span data-ttu-id="6ae7c-189">**Altre informazioni** per altre informazioni sull'estensione Docker per Visual Studio Team Services, passare a <https://aka.ms/vstsdockerextension>.</span><span class="sxs-lookup"><span data-stu-id="6ae7c-189">**More info** To read more about the Docker extension for Visual Studio Team Services, go to <https://aka.ms/vstsdockerextension>.</span></span> <span data-ttu-id="6ae7c-190">Per ulteriori informazioni sul Registro di sistema contenitore di Azure, passare a <https://aka.ms/azurecontainerregistry>.</span><span class="sxs-lookup"><span data-stu-id="6ae7c-190">To learn more about Azure Container Registry, go to <https://aka.ms/azurecontainerregistry>.</span></span>

## <a name="step-4-cd-deploy"></a><span data-ttu-id="6ae7c-191">Passaggio 4: CD, distribuzione</span><span class="sxs-lookup"><span data-stu-id="6ae7c-191">Step 4: CD, Deploy</span></span>

<span data-ttu-id="6ae7c-192">Immutabilità delle immagini Docker garantisce una distribuzione ripetibile con ciò che ha sviluppato, testato mediante CI ed eseguire nell'ambiente di produzione.</span><span class="sxs-lookup"><span data-stu-id="6ae7c-192">The immutability of Docker images ensures a repeatable deployment with what's developed, tested through CI, and run in production.</span></span> <span data-ttu-id="6ae7c-193">Dopo aver creato le immagini Docker applicazione pubblicate nel Registro di sistema Docker (pubblico o privato), è possibile distribuirli agli ambienti diversi che possono verificarsi (ambiente di produzione, controllo di qualità, gestione temporanea, e così via) da pipeline CD utilizzando Visual Studio Team Services le attività della pipeline o gestione del rilascio di Visual Studio Team Services.</span><span class="sxs-lookup"><span data-stu-id="6ae7c-193">After you have the application Docker images published in your Docker registry (either private or public), you can deploy them to the several environments that you might have (production, QA, staging, etc.) from your CD pipeline by using Visual Studio Team Services pipeline tasks or Visual Studio Team Services Release Management.</span></span>

<span data-ttu-id="6ae7c-194">Tuttavia, a questo punto dipende dal tipo di applicazione di Docker si sta distribuendo.</span><span class="sxs-lookup"><span data-stu-id="6ae7c-194">However, at this point it depends on what kind of Docker application you are deploying.</span></span> <span data-ttu-id="6ae7c-195">Distribuzione di un'applicazione semplice (da una composizione e distribuzione punto di vista), ad esempio un monolitico dell'applicazione che comprende alcuni contenitori o i servizi e distribuita su alcuni server o le macchine virtuali è molto diversa dalla distribuzione di un'applicazione più complessa, ad esempio un applicazione orientata ai servizi microservizi con la funzionalità iperscalabile.</span><span class="sxs-lookup"><span data-stu-id="6ae7c-195">Deploying a simple application (from a composition and deployment point of view) like a monolithic application comprising a few containers or services and deployed to a few servers or VMs is very different from deploying a more complex application like a microservices-oriented application with hyperscale capabilities.</span></span> <span data-ttu-id="6ae7c-196">Questi due scenari sono illustrati nelle sezioni seguenti.</span><span class="sxs-lookup"><span data-stu-id="6ae7c-196">These two scenarios are explained in the following sections.</span></span>

### <a name="deploying-composed-docker-applications-to-multiple-docker-environments"></a><span data-ttu-id="6ae7c-197">Distribuzione composto da applicazioni di Docker in più ambienti di Docker</span><span class="sxs-lookup"><span data-stu-id="6ae7c-197">Deploying composed Docker applications to multiple Docker environments</span></span>

<span data-ttu-id="6ae7c-198">Verrà ora esaminato il primo scenario il meno complesso: la distribuzione agli semplice Docker host (macchine virtuali o i server) in un unico ambiente o in più ambienti (QA, gestione temporanea e produzione).</span><span class="sxs-lookup"><span data-stu-id="6ae7c-198">Let's look first at the less-complex scenario: deploying to simple Docker hosts (VMs or servers) in a single environment or multiple environments (QA, staging, and production).</span></span> <span data-ttu-id="6ae7c-199">In questo scenario, la pipeline CD può essere utilizzata internamente docker-comporre (delle attività di distribuzione di Visual Studio Team Services) per distribuire le applicazioni di Docker con il relativo set correlato di contenitori o servizi, come illustrato nella figura 5-6.</span><span class="sxs-lookup"><span data-stu-id="6ae7c-199">In this scenario, internally your CD pipeline can use docker-compose (from your Visual Studio Team Services deployment tasks) to deploy the Docker applications with its related set of containers or services, as illustrated in Figure 5-6.</span></span>

![](./media/image6.png)

<span data-ttu-id="6ae7c-200">Figura 5-6: distribuzione dei contenitori di applicazioni semplici Docker host ambienti Registro di sistema</span><span class="sxs-lookup"><span data-stu-id="6ae7c-200">Figure 5-6: Deploying application containers to simple Docker host environments registry</span></span>

<span data-ttu-id="6ae7c-201">Figura 5-7 evidenzia come connettersi l'elemento di configurazione di compilazione agli ambienti QA/test tramite Visual Studio Team Services facendo clic su Docker Compose nella finestra di dialogo Aggiungi attività.</span><span class="sxs-lookup"><span data-stu-id="6ae7c-201">Figure 5-7 highlights how you can connect your build CI to QA/test environments via Visual Studio Team Services by clicking Docker Compose in the Add Task dialog box.</span></span> <span data-ttu-id="6ae7c-202">Tuttavia, quando si distribuisce agli ambienti di produzione o gestione temporanea, in genere utilizzare le funzionalità di gestione del rilascio gestisce più ambienti (ad esempio QA, gestione temporanea e produzione).</span><span class="sxs-lookup"><span data-stu-id="6ae7c-202">However, when deploying to staging or production environments, you would usually use Release Management features handling multiple environments (like QA, staging, and production).</span></span> <span data-ttu-id="6ae7c-203">Se si distribuisce per singolo host Docker, è usando Visual Studio Team Services attività "Docker Compose" (che consiste nel richiamare docker-comporre il comando dietro le quinte).</span><span class="sxs-lookup"><span data-stu-id="6ae7c-203">If you're deploying to single Docker hosts, it is using the Visual Studio Team Services "Docker Compose" task (which is invoking the docker-compose up command under the hood).</span></span> <span data-ttu-id="6ae7c-204">Se si distribuisce il servizio di contenitore di Azure, Usa l'attività di distribuzione di Docker, come illustrato nella sezione che segue.</span><span class="sxs-lookup"><span data-stu-id="6ae7c-204">If you're deploying to Azure Container Service, it uses the Docker Deployment task, as explained in the section that follows.</span></span>

![](./media/image7.png)

<span data-ttu-id="6ae7c-205">Figura 5-7: aggiunta di un'attività Docker Compose in una pipeline di Visual Studio Team Services</span><span class="sxs-lookup"><span data-stu-id="6ae7c-205">Figure 5-7: Adding a Docker Compose task in a Visual Studio Team Services pipeline</span></span>

<span data-ttu-id="6ae7c-206">Quando si crea una versione in Visual Studio Team Services, richiede un set di elementi di input.</span><span class="sxs-lookup"><span data-stu-id="6ae7c-206">When you create a release in Visual Studio Team Services, it takes a set of input artifacts.</span></span> <span data-ttu-id="6ae7c-207">Questi sono destinati a essere modificabile per tutta la durata della versione in ambienti diversi.</span><span class="sxs-lookup"><span data-stu-id="6ae7c-207">These are intended to be immutable throughout the lifetime of the release across multiple environments.</span></span> <span data-ttu-id="6ae7c-208">Quando si introducono i contenitori, gli elementi di input identificano le immagini in un registro di sistema per la distribuzione.</span><span class="sxs-lookup"><span data-stu-id="6ae7c-208">When you introduce containers, the input artifacts identify images in a registry to deploy.</span></span> <span data-ttu-id="6ae7c-209">A seconda del modo in cui questi vengono identificati, essi non sono garantiti come rimangono invariati per tutta la durata della versione, il caso più evidente quando si fa riferimento a "myimage:latest" da un file docker-compose.</span><span class="sxs-lookup"><span data-stu-id="6ae7c-209">Depending on how these are identified, they are not guaranteed to remain the same throughout the duration of the release, the most obvious case being when you reference "myimage:latest" from a docker-compose file.</span></span>

<span data-ttu-id="6ae7c-210">L'estensione Docker per Visual Studio Team Services offre la possibilità di generare gli artefatti di compilazione che contengono l'immagine del Registro di sistema un digest garantiti per identificare in modo univoco la stessa immagine binaria.</span><span class="sxs-lookup"><span data-stu-id="6ae7c-210">The Docker extension for Visual Studio Team Services gives you the ability to generate build artifacts that contain specific registry image digests that are guaranteed to uniquely identify the same image binary.</span></span> <span data-ttu-id="6ae7c-211">Si tratta ciò che si vuole poter usare come input a una versione.</span><span class="sxs-lookup"><span data-stu-id="6ae7c-211">These are what you really want to use as input to a release.</span></span>

### <a name="managing-releases-to-docker-environments-by-using-visual-studio-team-services-release-management"></a><span data-ttu-id="6ae7c-212">Gestione dei rilasci in ambienti di Docker con gestione del rilascio di Visual Studio Team Services</span><span class="sxs-lookup"><span data-stu-id="6ae7c-212">Managing releases to Docker environments by using Visual Studio Team Services Release Management</span></span>

<span data-ttu-id="6ae7c-213">Tramite le estensioni di Visual Studio Team Services, è possibile compilare una nuova immagine, pubblicarla in un registro di sistema di Docker, eseguirlo in Linux o Windows host e utilizzare i comandi, ad esempio docker-comporre per distribuire più contenitori come un'intera applicazione, intera l'oggetto visivo Funzionalità di Team Services Release Management Studio destinate a più ambienti, come illustrato nella figura 5-8.</span><span class="sxs-lookup"><span data-stu-id="6ae7c-213">Through the Visual Studio Team Services extensions, you can build a new image, publish it to a Docker registry, run it on Linux or Windows hosts, and use commands such as docker-compose to deploy multiple containers as an entire application, all through the Visual Studio Team Services Release Management capabilities intended for multiple environments, as shown in Figure 5-8.</span></span>

![](./media/image8.png)

<span data-ttu-id="6ae7c-214">Figura 5-8: configurazione di Visual Studio Team Services Docker Compose attività da Visual Studio Team Services Release Management</span><span class="sxs-lookup"><span data-stu-id="6ae7c-214">Figure 5-8: Configuring Visual Studio Team Services Docker Compose tasks from Visual Studio Team Services Release Management</span></span>

<span data-ttu-id="6ae7c-215">Tuttavia, tenere presente che lo scenario illustrato nella figura 5-6 e implementato in figura 5-8 è piuttosto semplice (consiste nel distribuire in macchine virtuali e host Docker semplice, e sarà presente un singolo contenitore o un'istanza per ogni immagine) e probabilmente deve essere utilizzato solo per lo sviluppo o test sc con.</span><span class="sxs-lookup"><span data-stu-id="6ae7c-215">However, keep in mind that the scenario shown in Figure 5-6 and implemented in Figure 5-8 is pretty basic (it is deploying to simple Docker hosts and VMs, and there will be a single container or instance per image) and probably should be used only for development or test scenarios.</span></span> <span data-ttu-id="6ae7c-216">Nella maggior parte degli scenari di produzione dell'organizzazione, si desidera avere la disponibilità elevata e scalabilità per gestire dal bilanciamento del carico tra più nodi, i server e le macchine virtuali, oltre "i failover intelligenti" in modo che se un server o un nodo ha esito negativo, i servizi e i contenitori verranno spostati in un altro server host o VM.</span><span class="sxs-lookup"><span data-stu-id="6ae7c-216">In most enterprise production scenarios, you would want to have High Availability (HA) and easy-to-manage scalability by load balancing across multiple nodes, servers, and VMs, plus "intelligent failovers" so that if a server or node fails, its services and containers will be moved to another host server or VM.</span></span> <span data-ttu-id="6ae7c-217">In tal caso, è necessario tecnologie più avanzate quali i cluster di contenitore, orchestrators e le utilità di pianificazione.</span><span class="sxs-lookup"><span data-stu-id="6ae7c-217">In that case, you need more advanced technologies like container clusters, orchestrators, and schedulers.</span></span> <span data-ttu-id="6ae7c-218">Pertanto, il modo per distribuire tali cluster è precisamente tramite gli scenari avanzati illustrati nella sezione successiva.</span><span class="sxs-lookup"><span data-stu-id="6ae7c-218">Thus, the way to deploy to those clusters is precisely through the advanced scenarios explained in the next section.</span></span>

### <a name="deploying-complex-docker-applications-to-docker-clusters-dcos-kubernetes-and-docker-swarm"></a><span data-ttu-id="6ae7c-219">Distribuzione di applicazioni complesse di Docker ai cluster Docker (controller di dominio/OS Kubernetes e Docker Swarm)</span><span class="sxs-lookup"><span data-stu-id="6ae7c-219">Deploying complex Docker applications to Docker clusters (DC/OS, Kubernetes, and Docker Swarm)</span></span>

<span data-ttu-id="6ae7c-220">La natura delle applicazioni distribuite richiede risorse di calcolo che sono inoltre distribuite.</span><span class="sxs-lookup"><span data-stu-id="6ae7c-220">The nature of distributed applications requires compute resources that are also distributed.</span></span> <span data-ttu-id="6ae7c-221">Per le funzionalità di scala di produzione, è necessario che le funzionalità che forniscono la scalabilità elevate di clustering e disponibilità elevata in base alle risorse in pool.</span><span class="sxs-lookup"><span data-stu-id="6ae7c-221">To have production-scale capabilities, you need to have clustering capabilities that provide high scalability and HA based on pooled resources.</span></span>

<span data-ttu-id="6ae7c-222">È possibile distribuire manualmente i contenitori per tali cluster da uno strumento di interfaccia CLI, ad esempio Docker Swarm (come l'uso [creare servizio docker](https://docs.docker.com/engine/swarm/swarm-tutorial/deploy-service/)) o un'interfaccia utente web, ad esempio [Mesosphere Marathon](https://mesosphere.github.io/marathon/docs/marathon-ui.html) per controller di dominio/OS cluster, ma è necessario riservare che solo per i test della distribuzione punctual o per scopi di gestione, ad esempio la scalabilità orizzontale o a scopo di monitoraggio.</span><span class="sxs-lookup"><span data-stu-id="6ae7c-222">You could deploy containers manually to those clusters from a CLI tool such as Docker Swarm (like using [docker service create](https://docs.docker.com/engine/swarm/swarm-tutorial/deploy-service/)) or a web UI such as [Mesosphere Marathon](https://mesosphere.github.io/marathon/docs/marathon-ui.html) for DC/OS clusters, but you should reserve that only for punctual deployment testing or for management purposes like scaling-out or monitoring purposes.</span></span>

<span data-ttu-id="6ae7c-223">Da un CD punto di vista e Visual Studio Team Services in particolare, è possibile eseguire attività di distribuzione in modo speciale effettuata da ambienti di gestione del rilascio di Visual Studio Team Services che verranno distribuire le applicazioni nei contenitori in cluster distribuite in Servizio di contenitore, come illustrato nella figura 5 a 9.</span><span class="sxs-lookup"><span data-stu-id="6ae7c-223">From a CD point of view, and Visual Studio Team Services specifically, you can run specially made deployment tasks from your Visual Studio Team Services Release Management environments which will deploy your containerized applications to distributed clusters in Container Service, as illustrated in Figure 5-9.</span></span>

![](./media/image9.png)

<span data-ttu-id="6ae7c-224">Figura 5-9: distribuzione di applicazioni distribuite per il servizio contenitore</span><span class="sxs-lookup"><span data-stu-id="6ae7c-224">Figure 5-9: Deploying distributed applications to Container Service</span></span>

<span data-ttu-id="6ae7c-225">Inizialmente, quando si distribuisce a determinati cluster o orchestrators, in genere utilizzare meccanismi per ogni orchestrator (vale a dire, controller di dominio/OS Mesosphere o Kubernetes dispongono di meccanismi di distribuzione diversi rispetto a Docker e Docker e gli script di distribuzione specifico Swarm) anziché il più semplice e facile da usare docker-comporre strumento in base al file di definizione compose.yml docker.</span><span class="sxs-lookup"><span data-stu-id="6ae7c-225">Initially, when deploying to certain clusters or orchestrators, you would traditionally use specific deployment scripts and mechanisms per each orchestrator (that is, Mesosphere DC/OS or Kubernetes have different deployment mechanisms than Docker and Docker Swarm) instead of the simpler and easy-to-use docker-compose tool based on the docker-compose.yml definition file.</span></span> <span data-ttu-id="6ae7c-226">Tuttavia, ringraziamenti l'attività di Microsoft Visual Studio Team Services Docker distribuire, illustrato nella figura 5-10, ora anche distribuire al controller di dominio o sistema operativo utilizzando solo il file docker-compose.yml familiare perché Microsoft esegue tale "traduzione" per l'utente (dal docker compose.yml file in altri formati necessari dal controller di dominio/OS).</span><span class="sxs-lookup"><span data-stu-id="6ae7c-226">However, thanks to the Microsoft Visual Studio Team Services Docker Deploy task, shown in Figure 5-10, you now also can deploy to DC/OS by just using your familiar docker-compose.yml file because Microsoft performs that "translation" for you (from your docker-compose.yml file to other formats needed by DC/OS).</span></span>

![](./media/image10.png)

<span data-ttu-id="6ae7c-227">Figura 5 a 10: aggiunta dell'attività distribuire Docker per l'ambiente di RM</span><span class="sxs-lookup"><span data-stu-id="6ae7c-227">Figure 5-10: Adding the Docker Deploy task to your Environment RM</span></span>

<span data-ttu-id="6ae7c-228">Figura 5-11 viene illustrato come è possibile modificare l'attività di distribuzione di Docker e specificare il tipo di destinazione (contenitore del servizio controller di dominio/sistema operativo Azure, in questo caso), il File di comporre Docker e la connessione Docker del Registro di sistema (ad esempio del Registro di sistema contenitore di Azure o Hub Docker).</span><span class="sxs-lookup"><span data-stu-id="6ae7c-228">Figure 5-11 demonstrates how you can edit the Docker Deploy task and specify the Target Type (Azure Container Service DC/OS, in this case), your Docker Compose File, and the Docker Registry connection (like Azure Container Registry or Docker Hub).</span></span> <span data-ttu-id="6ae7c-229">Si tratta in cui l'attività recupererà le immagini Docker personalizzate pronto all'uso deve essere distribuito come i contenitori inclusi nel cluster di controller di dominio/OS.</span><span class="sxs-lookup"><span data-stu-id="6ae7c-229">This is where the task will retrieve your ready-to-use custom Docker images to be deployed as containers in the DC/OS cluster.</span></span>

![](./media/image11.png)

<span data-ttu-id="6ae7c-230">Figura 5-11: Docker Distribuisci attività definizione distribuzione al contenitore del servizio controller di dominio/sistema operativo Azure</span><span class="sxs-lookup"><span data-stu-id="6ae7c-230">Figure 5-11: Docker Deploy task definition deploying to Azure Container Service DC/OS</span></span>

<span data-ttu-id="6ae7c-231">**Altre informazioni** per altre informazioni sulla pipeline CD con Visual Studio Team Services e Docker, visitare i siti seguenti:</span><span class="sxs-lookup"><span data-stu-id="6ae7c-231">**More info** To read more about the CD pipeline with Visual Studio Team Services and Docker, visit the following sites:</span></span>

<span data-ttu-id="6ae7c-232">Estensione di Visual Studio Team Services per Docker e il servizio contenitore di Azure: [ https://aka.ms/\ vstsdockerextension](https://aka.ms/vstsdockerextension)</span><span class="sxs-lookup"><span data-stu-id="6ae7c-232">Visual Studio Team Services extension for Docker and Azure Container Service: [https://aka.ms/\ vstsdockerextension](https://aka.ms/vstsdockerextension)</span></span>

<span data-ttu-id="6ae7c-233">Servizio di contenitore di Azure: <https://aka.ms/azurecontainerservice></span><span class="sxs-lookup"><span data-stu-id="6ae7c-233">Azure Container Service: <https://aka.ms/azurecontainerservice></span></span>

<span data-ttu-id="6ae7c-234">Controller di dominio mesosphere/OS: <https://mesosphere.com/product/></span><span class="sxs-lookup"><span data-stu-id="6ae7c-234">Mesosphere DC/OS: <https://mesosphere.com/product/></span></span>

## <a name="step-5-run-and-manage"></a><span data-ttu-id="6ae7c-235">Passaggio 5: Eseguire e gestire</span><span class="sxs-lookup"><span data-stu-id="6ae7c-235">Step 5: Run and manage</span></span>

<span data-ttu-id="6ae7c-236">Poiché in esecuzione e la gestione delle applicazioni in fase di produzione enterprise livello è un oggetto principale in di se stesso e a causa del tipo di operazioni e persone lavorano a tale livello (operatori IT), nonché l'ambito di grandi dimensioni di quest'area, è stata dedicato dell'intero accanto capitolo di descriverlo.</span><span class="sxs-lookup"><span data-stu-id="6ae7c-236">Because running and managing applications at enterprise-production level is a major subject in and of itself, and due to the type of operations and people working at that level (IT operations) as well as the large scope of this area, we have devoted the entire next chapter to explaining it.</span></span>

## <a name="step-6-monitor-and-diagnose"></a><span data-ttu-id="6ae7c-237">Passaggio 6: Monitoraggio e diagnosi</span><span class="sxs-lookup"><span data-stu-id="6ae7c-237">Step 6: Monitor and diagnose</span></span>

<span data-ttu-id="6ae7c-238">In questo argomento anche viene illustrato nel capitolo successivo come parte delle attività che esegue le operazioni IT in sistemi di produzione. Tuttavia, è importante per evidenziare che le informazioni ottenute in questo passaggio necessario inserire nuovamente al team di sviluppo in modo che l'applicazione verrà costantemente migliorata.</span><span class="sxs-lookup"><span data-stu-id="6ae7c-238">This topic also is covered in the next chapter as part of the tasks that IT operations performs in production systems; however, is important to highlight that the insights obtained in this step must feed back to the development team so that the application is constantly improved.</span></span> <span data-ttu-id="6ae7c-239">Da tale punto di vista fa anche parte di DevOps, anche se le attività e le operazioni vengono in genere eseguite da IT.</span><span class="sxs-lookup"><span data-stu-id="6ae7c-239">From that point of view, it is also part of DevOps, although the tasks and operations are usually performed by IT.</span></span>

<span data-ttu-id="6ae7c-240">Solo quando il monitoraggio e diagnostica è piene al 100% all'interno dell'area di autenticazione di DevOps sono i processi di monitoraggio e analitica eseguita dal team di sviluppo in ambienti di test o beta.</span><span class="sxs-lookup"><span data-stu-id="6ae7c-240">Only when monitoring and diagnostics are 100 percent within the realm of DevOps are the monitoring processes and analytics performed by the development team against testing or beta environments.</span></span> <span data-ttu-id="6ae7c-241">Questa operazione viene eseguita mediante l'esecuzione di test di carico o semplicemente monitorando beta o ambienti di conferma del controllo, in cui beta tester sta cercando le nuove versioni.</span><span class="sxs-lookup"><span data-stu-id="6ae7c-241">This is done either by performing load testing or simply by monitoring beta or QA environments, where beta testers are trying the new versions.</span></span>

>[!div class="step-by-step"]
<span data-ttu-id="6ae7c-242">[Precedente](index.md)
[Successivo](../run-manage-monitor-docker-environments/index.md)</span><span class="sxs-lookup"><span data-stu-id="6ae7c-242">[Previous](index.md)
[Next](../run-manage-monitor-docker-environments/index.md)</span></span>
