---
title: Informazioni sul codice gestito
description: Informazioni che spiegano che il codice gestito è codice la cui esecuzione è gestita da un runtime, ovvero CRL (Common Language Runtime).
keywords: .NET, .NET Core
author: blackdwarf
ms.author: mairaw
ms.date: 06/20/2016
ms.topic: article
ms.prod: .net
ms.technology: dotnet-standard
ms.devlang: dotnet
ms.assetid: 20bb7ea8-192e-4a96-8ef3-e10e1950fd3d
ms.workload:
- dotnet
- dotnetcore
ms.openlocfilehash: 46bbe30f216ba9b0a3bc7f88267c428ec56de614
ms.sourcegitcommit: 2e8acae16ae802f2d6d04e3ce0a6dbf04e476513
ms.translationtype: HT
ms.contentlocale: it-IT
ms.lasthandoff: 04/18/2018
---
# <a name="what-is-managed-code"></a><span data-ttu-id="8ffc3-104">Informazioni sul codice gestito</span><span class="sxs-lookup"><span data-stu-id="8ffc3-104">What is "managed code"?</span></span>

<span data-ttu-id="8ffc3-105">Quando si lavora con .NET Framework, viene spesso usato il termine "codice gestito".</span><span class="sxs-lookup"><span data-stu-id="8ffc3-105">When working with .NET Framework, you will often encounter the term "managed code".</span></span> <span data-ttu-id="8ffc3-106">Questo documento illustra il significato di questo termine e fornisce informazioni aggiuntive.</span><span class="sxs-lookup"><span data-stu-id="8ffc3-106">This document will explain what this term means and additional information around it.</span></span>

<span data-ttu-id="8ffc3-107">Detto in parole povere, il codice gestito è un codice la cui esecuzione è gestita da un runtime.</span><span class="sxs-lookup"><span data-stu-id="8ffc3-107">To put it very simply, managed code is just that: code whose execution is managed by a runtime.</span></span> <span data-ttu-id="8ffc3-108">In questo caso il runtime in questione è denominato **CLR (Common Language Runtime)** indipendentemente dall'implementazione ([Mono](https://www.mono-project.com/), .NET Framework o .NET Core).</span><span class="sxs-lookup"><span data-stu-id="8ffc3-108">In this case, the runtime in question is called the **Common Language Runtime** or CLR, regardless of the implementation ([Mono](https://www.mono-project.com/) or .NET Framework or .NET Core).</span></span> <span data-ttu-id="8ffc3-109">Il CLR è responsabile dell'acquisizione del codice gestito, della compilazione dello stesso in codice macchina e quindi della sua esecuzione.</span><span class="sxs-lookup"><span data-stu-id="8ffc3-109">CLR is in charge of taking the managed code, compiling it into machine code and then executing it.</span></span> <span data-ttu-id="8ffc3-110">Aspetto ancora più importante, il runtime offre diversi servizi importanti, ad esempio la gestione automatica della memoria, i limiti di sicurezza, l'indipendenza dai tipi e così via.</span><span class="sxs-lookup"><span data-stu-id="8ffc3-110">On top of that, runtime provides several important services such as automatic memory management, security boundaries, type safety etc.</span></span>

<span data-ttu-id="8ffc3-111">Il modo in cui viene eseguito un programma C/C++, denominato anche "codice non gestito", è opposto a quanto sopra esposto.</span><span class="sxs-lookup"><span data-stu-id="8ffc3-111">Contrast this to the way you would run a C/C++ program, also called "unmanaged code".</span></span> <span data-ttu-id="8ffc3-112">Nel "mondo non gestito", il programmatore è responsabile di tutte le attività relative al codice.</span><span class="sxs-lookup"><span data-stu-id="8ffc3-112">In the unmanaged world, the programmer is in charge of pretty much everything.</span></span> <span data-ttu-id="8ffc3-113">Il programma effettivo è essenzialmente un file binario che il sistema operativo carica in memoria e avvia.</span><span class="sxs-lookup"><span data-stu-id="8ffc3-113">The actual program is, essentially, a binary that the operating system (OS) loads into memory and starts.</span></span> <span data-ttu-id="8ffc3-114">Tutti gli altri aspetti, dalla gestione della memoria alle considerazioni sulla sicurezza, sono a carico del programmatore.</span><span class="sxs-lookup"><span data-stu-id="8ffc3-114">Everything else, from memory management to security considerations are a burden of the programmer.</span></span>

<span data-ttu-id="8ffc3-115">Il codice gestito è scritto in uno dei linguaggi di alto livello eseguibili in .NET, ad esempio C#, Visual Basic, F# e altri.</span><span class="sxs-lookup"><span data-stu-id="8ffc3-115">Managed code is written in one of the high-level languages that can be run on top of .NET, such as C#, Visual Basic, F# and others.</span></span> <span data-ttu-id="8ffc3-116">Quando si compila codice scritto in uno di questi linguaggi con il relativo compilatore, non si ottiene codice macchina.</span><span class="sxs-lookup"><span data-stu-id="8ffc3-116">When you compile code written in those languages with their respective compiler, you don’t get machine code.</span></span> <span data-ttu-id="8ffc3-117">Si ottiene invece codice in **linguaggio intermedio**  che il runtime provvede a compilare ed eseguire.</span><span class="sxs-lookup"><span data-stu-id="8ffc3-117">You get **Intermediate Language** code which the runtime then compiles and executes.</span></span> <span data-ttu-id="8ffc3-118">C++ è l'unica eccezione a questa regola, poiché può generare alche file binari nativi non gestiti eseguibili in Windows.</span><span class="sxs-lookup"><span data-stu-id="8ffc3-118">C++ is the one exception to this rule, as it can also produce native, unmanaged binaries that run on Windows.</span></span>

## <a name="intermediate-language--execution"></a><span data-ttu-id="8ffc3-119">Linguaggio intermedio ed esecuzione</span><span class="sxs-lookup"><span data-stu-id="8ffc3-119">Intermediate Language & execution</span></span>

<span data-ttu-id="8ffc3-120">Informazioni sul "linguaggio intermedio"</span><span class="sxs-lookup"><span data-stu-id="8ffc3-120">What is "Intermediate Language" (or IL for short)?</span></span> <span data-ttu-id="8ffc3-121">Il linguaggio intermedio è un prodotto della compilazione di codice scritto in linguaggi .NET di alto livello.</span><span class="sxs-lookup"><span data-stu-id="8ffc3-121">It is a product of compilation of code written in high-level .NET languages.</span></span> <span data-ttu-id="8ffc3-122">Dopo la compilazione del codice scritto in uno di questi linguaggi, si ottiene un file binario in linguaggio intermedio.</span><span class="sxs-lookup"><span data-stu-id="8ffc3-122">Once you compile your code written in one of these languages, you will get a binary that is made out of IL.</span></span> <span data-ttu-id="8ffc3-123">È importante notare che il linguaggio intermedio è indipendente da qualsiasi linguaggio specifico eseguito a un livello superiore rispetto al runtime. Esiste una specifica separata che è possibile consultare per maggiori informazioni.</span><span class="sxs-lookup"><span data-stu-id="8ffc3-123">It is important to note that the IL is independent from any specific language that runs on top of the runtime; there is even a separate specification for it that you can read if you’re so inclined.</span></span>

<span data-ttu-id="8ffc3-124">Una volta generato il linguaggio intermedio dal codice di alto livello, è probabile che si voglia eseguirlo.</span><span class="sxs-lookup"><span data-stu-id="8ffc3-124">Once you produce IL from your high-level code, you will most likely want to run it.</span></span> <span data-ttu-id="8ffc3-125">A questo punto il CLR assume il controllo e avvia il processo di compilazione **Just-In-Time**, o **JIT**, del codice dal linguaggio intermedio al codice macchina che può essere effettivamente eseguito su una CPU.</span><span class="sxs-lookup"><span data-stu-id="8ffc3-125">This is where the CLR takes over and starts the process of **Just-In-Time** compiling, or **JIT-ing** your code from IL to machine code that can actually be run on a CPU.</span></span> <span data-ttu-id="8ffc3-126">In questo modo, il CLR conosce esattamente le finalità del codice e può _gestirlo_.</span><span class="sxs-lookup"><span data-stu-id="8ffc3-126">In this way, the CLR knows exactly what your code is doing and can effectively _manage_ it.</span></span>

<span data-ttu-id="8ffc3-127">Talvolta il linguaggio intermedio viene chiamato anche CIL (Common Intermediate Language) o MSIL (Microsoft Intermediate Language).</span><span class="sxs-lookup"><span data-stu-id="8ffc3-127">Intermediate Language is sometimes also called Common Intermediate Language (CIL) or Microsoft Intermediate Language (MSIL).</span></span>

## <a name="unmanaged-code-interoperability"></a><span data-ttu-id="8ffc3-128">Interoperabilità con codice non gestito</span><span class="sxs-lookup"><span data-stu-id="8ffc3-128">Unmanaged code interoperability</span></span>

<span data-ttu-id="8ffc3-129">Il CLR consente naturalmente il superamento dei confini tra "mondo gestito" e "mondo non gestito". È disponibile molto codice in grado di eseguire tale operazione, anche nelle [librerie di classi base](framework-libraries.md).</span><span class="sxs-lookup"><span data-stu-id="8ffc3-129">Of course, the CLR allows passing the boundaries between managed and unmanaged world, and there is a lot of code that does that, even in the [Base Class Libraries](framework-libraries.md).</span></span> <span data-ttu-id="8ffc3-130">Questa attività è denominata **interoperabilità**, abbreviata in **interop**.</span><span class="sxs-lookup"><span data-stu-id="8ffc3-130">This is called **interoperability** or just **interop** for short.</span></span> <span data-ttu-id="8ffc3-131">Queste condizioni consentono, ad esempio, di eseguire il wrapping di una libreria non gestita e di chiamarla.</span><span class="sxs-lookup"><span data-stu-id="8ffc3-131">These provisions would allow you to, for example, wrap up an unmanaged library and call into it.</span></span> <span data-ttu-id="8ffc3-132">È tuttavia importante notare che, una volta eseguita questa operazione, quando il codice oltrepassa i confini del runtime, la gestione effettiva dell'esecuzione è di nuovo responsabilità del codice non gestito e di conseguenza è soggetta alle stesse limitazioni.</span><span class="sxs-lookup"><span data-stu-id="8ffc3-132">However, it is important to note that once you do this, when the code passes the boundaries of the runtime, the actual management of the execution is again in the hand of unmanaged code, and thus falls under the same restrictions.</span></span>

<span data-ttu-id="8ffc3-133">Analogamente a quanto sopra esposto, C# è un linguaggio che consente di usare costrutti non gestiti, ad esempio i puntatori, direttamente nel codice usando il cosiddetto **contesto non sicuro**. Questo termine indica una porzione di codice la cui esecuzione non è gestita dal CLR.</span><span class="sxs-lookup"><span data-stu-id="8ffc3-133">Similar to this, C# is one language that allows you to use unmanaged constructs such as pointers directly in code by utilizing what is known as **unsafe context** which designates a piece of code for which the execution is not managed by the CLR.</span></span>

## <a name="more-resources"></a><span data-ttu-id="8ffc3-134">Altre risorse</span><span class="sxs-lookup"><span data-stu-id="8ffc3-134">More resources</span></span>

*   [<span data-ttu-id="8ffc3-135">Cenni preliminari su .NET Framework</span><span class="sxs-lookup"><span data-stu-id="8ffc3-135">.NET Framework Conceptual Overview</span></span>](https://msdn.microsoft.com/library/zw4w595w.aspx)
*   [<span data-ttu-id="8ffc3-136">Codice unsafe e puntatori</span><span class="sxs-lookup"><span data-stu-id="8ffc3-136">Unsafe Code and Pointers</span></span>](../../docs/csharp/programming-guide/unsafe-code-pointers/index.md)
*   [<span data-ttu-id="8ffc3-137">Interoperabilità (Guida per programmatori C#)</span><span class="sxs-lookup"><span data-stu-id="8ffc3-137">Interoperability (C# Programming guide)</span></span>](https://msdn.microsoft.com/library/ms173184.aspx)
