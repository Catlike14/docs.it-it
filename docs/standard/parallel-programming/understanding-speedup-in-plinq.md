---
title: "Informazioni sull'aumento di velocità in PLINQ"
ms.custom: 
ms.date: 03/30/2017
ms.prod: .net
ms.reviewer: 
ms.suite: 
ms.technology: dotnet-standard
ms.tgt_pltfrm: 
ms.topic: article
dev_langs:
- csharp
- vb
helpviewer_keywords: PLINQ queries, performance tuning
ms.assetid: 53706c7e-397d-467a-98cd-c0d1fd63ba5e
caps.latest.revision: "14"
author: rpetrusha
ms.author: ronpet
manager: wpickett
ms.openlocfilehash: c3373cb6a2c535bd7d42eb062e1f9727952f7cfb
ms.sourcegitcommit: bd1ef61f4bb794b25383d3d72e71041a5ced172e
ms.translationtype: HT
ms.contentlocale: it-IT
ms.lasthandoff: 10/18/2017
---
# <a name="understanding-speedup-in-plinq"></a><span data-ttu-id="c1232-102">Informazioni sull'aumento di velocità in PLINQ</span><span class="sxs-lookup"><span data-stu-id="c1232-102">Understanding Speedup in PLINQ</span></span>
<span data-ttu-id="c1232-103">Lo scopo principale di PLINQ consiste nel velocizzare l'esecuzione di LINQ per le query di oggetti tramite l'esecuzione di delegati di query in parallelo nei computer multicore.</span><span class="sxs-lookup"><span data-stu-id="c1232-103">The primary purpose of PLINQ is to speed up the execution of LINQ to Objects queries by executing the query delegates in parallel on multi-core computers.</span></span> <span data-ttu-id="c1232-104">PLINQ offre le prestazioni migliori quando l'elaborazione di ogni elemento in una raccolta di origine è indipendente e non condiviso alcuno stato singoli delegati.</span><span class="sxs-lookup"><span data-stu-id="c1232-104">PLINQ performs best when the processing of each element in a source collection is independent, with no shared state involved among the individual delegates.</span></span> <span data-ttu-id="c1232-105">Tali operazioni sono comuni in LINQ to Objects e PLINQ e spesso vengono denominate "*deliziosamente parallele*" perché si prestano facilmente alla pianificazione su più thread.</span><span class="sxs-lookup"><span data-stu-id="c1232-105">Such operations are common in LINQ to Objects and PLINQ, and are often called "*delightfully parallel*" because they lend themselves easily to scheduling on multiple threads.</span></span> <span data-ttu-id="c1232-106">Tuttavia, non tutte le query costituite interamente operazioni deliziosamente parallele. Nella maggior parte dei casi, una query implica alcuni operatori che non possono essere eseguiti o che rallentano l'esecuzione parallela.</span><span class="sxs-lookup"><span data-stu-id="c1232-106">However, not all queries consist entirely of delightfully parallel operations; in most cases, a query involves some operators that either cannot be parallelized, or that slow down parallel execution.</span></span> <span data-ttu-id="c1232-107">E anche le query sono interamente deliziosamente parallele, PLINQ deve comunque suddividere l'origine dati e pianificare il lavoro sul thread e in genere il merge dei risultati al termine della query.</span><span class="sxs-lookup"><span data-stu-id="c1232-107">And even with queries that are entirely delightfully parallel, PLINQ must still partition the data source and schedule the work on the threads, and usually merge the results when the query completes.</span></span> <span data-ttu-id="c1232-108">Tutte queste operazioni di aggiungono al costo computazionale della parallelizzazione. i costi di aggiunta di parallelizzazione vengono chiamati *overhead*.</span><span class="sxs-lookup"><span data-stu-id="c1232-108">All these operations add to the computational cost of parallelization; these costs of adding parallelization are called *overhead*.</span></span> <span data-ttu-id="c1232-109">Per ottenere prestazioni ottimali in una query PLINQ, l'obiettivo è ottimizzare le parti deliziosamente parallele e ridurre al minimo le parti che comportano un sovraccarico.</span><span class="sxs-lookup"><span data-stu-id="c1232-109">To achieve optimum performance in a PLINQ query, the goal is to maximize the parts that are delightfully parallel and minimize the parts that require overhead.</span></span> <span data-ttu-id="c1232-110">Questo articolo fornisce informazioni che consentono di scrivere query PLINQ che sono più efficaci possibile producano comunque risultati corretti.</span><span class="sxs-lookup"><span data-stu-id="c1232-110">This article provides information that will help you write PLINQ queries that are as efficient as possible while still yielding correct results.</span></span>  
  
## <a name="factors-that-impact-plinq-query-performance"></a><span data-ttu-id="c1232-111">Fattori che influiscono sulle prestazioni delle Query PLINQ</span><span class="sxs-lookup"><span data-stu-id="c1232-111">Factors that Impact PLINQ Query Performance</span></span>  
 <span data-ttu-id="c1232-112">Nelle sezioni seguenti sono elencati alcuni dei fattori più importanti che influiscono sulle prestazioni di query parallele.</span><span class="sxs-lookup"><span data-stu-id="c1232-112">The following sections lists some of the most important factors that impact parallel query performance.</span></span> <span data-ttu-id="c1232-113">Si tratta di istruzioni generali che da soli non sono sufficienti per stimare le prestazioni delle query in tutti i casi.</span><span class="sxs-lookup"><span data-stu-id="c1232-113">These are general statements that by themselves are not sufficient to predict query performance in all cases.</span></span> <span data-ttu-id="c1232-114">Come sempre, è importante misurare le prestazioni effettive di query specifiche in computer con una gamma di configurazioni e carichi rappresentativi.</span><span class="sxs-lookup"><span data-stu-id="c1232-114">As always, it is important to measure actual performance of specific queries on computers with a range of representative configurations and loads.</span></span>  
  
1.  <span data-ttu-id="c1232-115">Calcolo dei costi di lavoro complessivo.</span><span class="sxs-lookup"><span data-stu-id="c1232-115">Computational cost of the overall work.</span></span>  
  
     <span data-ttu-id="c1232-116">Per ottenere un aumento di velocità, una query PLINQ deve avere sufficiente lavoro deliziosamente parallelo per compensare l'overhead.</span><span class="sxs-lookup"><span data-stu-id="c1232-116">To achieve speedup, a PLINQ query must have enough delightfully parallel work to offset the overhead.</span></span> <span data-ttu-id="c1232-117">Il lavoro può essere espresso come il costo di calcolo di ogni delegato moltiplicato per il numero di elementi nella raccolta di origine.</span><span class="sxs-lookup"><span data-stu-id="c1232-117">The work can be expressed as the computational cost of each delegate multiplied by the number of elements in the source collection.</span></span> <span data-ttu-id="c1232-118">Supponendo che un'operazione può essere eseguito in parallelo, calcoli più complessi costosa è, maggiore la possibilità di aumento della velocità.</span><span class="sxs-lookup"><span data-stu-id="c1232-118">Assuming that an operation can be parallelized, the more computationally expensive it is, the greater the opportunity for speedup.</span></span> <span data-ttu-id="c1232-119">Ad esempio, se una funzione accetta un millisecondo, per eseguire una query sequenza oltre 1000 elementi sarà necessario un secondo per eseguire tale operazione, mentre una query parallela su un computer con quattro core potrebbe richiedere solo 250 millisecondi.</span><span class="sxs-lookup"><span data-stu-id="c1232-119">For example, if a function takes one millisecond to execute, a sequential query over 1000 elements will take one second to perform that operation, whereas a parallel query on a computer with four cores might take only 250 milliseconds.</span></span> <span data-ttu-id="c1232-120">Ciò produce un aumento di velocità di 750 millisecondi.</span><span class="sxs-lookup"><span data-stu-id="c1232-120">This yields a speedup of 750 milliseconds.</span></span> <span data-ttu-id="c1232-121">Se la funzione è necessario un secondo per l'esecuzione per ogni elemento, l'aumento di velocità sarebbe 750 secondi.</span><span class="sxs-lookup"><span data-stu-id="c1232-121">If the function required one second to execute for each element, then the speedup would be 750 seconds.</span></span> <span data-ttu-id="c1232-122">Se il delegato è molto costoso, PLINQ può offrire un aumento di velocità significativo con solo alcuni elementi nella raccolta di origine.</span><span class="sxs-lookup"><span data-stu-id="c1232-122">If the delegate is very expensive, then PLINQ might offer significant speedup with only a few items in the source collection.</span></span> <span data-ttu-id="c1232-123">Al contrario, le raccolte di origine di dimensioni ridotte con semplici delegati non sono in genere candidati validi per PLINQ.</span><span class="sxs-lookup"><span data-stu-id="c1232-123">Conversely, small source collections with trivial delegates are generally not good candidates for PLINQ.</span></span>  
  
     <span data-ttu-id="c1232-124">Nell'esempio seguente, queryA è probabilmente un buon candidato per PLINQ, presupponendo che la funzione di selezione implica molto lavoro.</span><span class="sxs-lookup"><span data-stu-id="c1232-124">In the following example, queryA is probably a good candidate for PLINQ, assuming that its Select function involves a lot of work.</span></span> <span data-ttu-id="c1232-125">queryB probabilmente non è un buon candidato perché non è sufficiente lavoro nell'istruzione Select, e l'overhead di parallelizzazione compensate gran parte o tutto l'aumento di velocità.</span><span class="sxs-lookup"><span data-stu-id="c1232-125">queryB is probably not a good candidate because there is not enough work in the Select statement, and the overhead of parallelization will offset most or all of the speedup.</span></span>  
  
    ```vb  
    Dim queryA = From num In numberList.AsParallel()  
                 Select ExpensiveFunction(num); 'good for PLINQ  
  
    Dim queryB = From num In numberList.AsParallel()  
                 Where num Mod 2 > 0  
                 Select num; 'not as good for PLINQ  
    ```  
  
    ```csharp  
    var queryA = from num in numberList.AsParallel()  
                 select ExpensiveFunction(num); //good for PLINQ  
  
    var queryB = from num in numberList.AsParallel()  
                 where num % 2 > 0  
                 select num; //not as good for PLINQ  
    ```  
  
2.  <span data-ttu-id="c1232-126">Il numero di core logici nel sistema (grado di parallelismo).</span><span class="sxs-lookup"><span data-stu-id="c1232-126">The number of logical cores on the system (degree of parallelism).</span></span>  
  
     <span data-ttu-id="c1232-127">Questo punto è un ovvio corollario della sezione precedente, le query deliziosamente parallele vengono eseguite più velocemente nei computer con più core perché il lavoro può essere suddiviso tra più thread simultanei.</span><span class="sxs-lookup"><span data-stu-id="c1232-127">This point is an obvious corollary to the previous section, queries that are delightfully parallel run faster on machines with more cores because the work can be divided among more concurrent threads.</span></span> <span data-ttu-id="c1232-128">La quantità totale di aumento di velocità dipende la percentuale di lavoro complessivo della query eseguibili in parallelo.</span><span class="sxs-lookup"><span data-stu-id="c1232-128">The overall amount of speedup depends on what percentage of the overall work of the query is parallelizable.</span></span> <span data-ttu-id="c1232-129">Tuttavia, si presuppone che tutte le query verranno eseguito due volte come fast su un computer con otto core come un computer di quattro core.</span><span class="sxs-lookup"><span data-stu-id="c1232-129">However, do not assume that all queries will run twice as fast on an eight core computer as a four core computer.</span></span> <span data-ttu-id="c1232-130">Durante l'ottimizzazione di query per ottenere prestazioni ottimali, è importante misurare i risultati effettivi nei computer con un numero di core.</span><span class="sxs-lookup"><span data-stu-id="c1232-130">When tuning queries for optimal performance, it is important to measure actual results on computers with various numbers of cores.</span></span> <span data-ttu-id="c1232-131">Questo punto è correlato al punto #1: set di dati più grande sono necessarie per sfruttare le risorse di elaborazione.</span><span class="sxs-lookup"><span data-stu-id="c1232-131">This point is related to point #1: larger datasets are required to take advantage of greater computing resources.</span></span>  
  
3.  <span data-ttu-id="c1232-132">Il numero e tipo di operazioni.</span><span class="sxs-lookup"><span data-stu-id="c1232-132">The number and kind of operations.</span></span>  
  
     <span data-ttu-id="c1232-133">PLINQ fornisce l'operatore AsOrdered per situazioni in cui è necessario mantenere l'ordine degli elementi nella sequenza di origine.</span><span class="sxs-lookup"><span data-stu-id="c1232-133">PLINQ provides the AsOrdered operator for situations in which it is necessary to maintain the order of elements in the source sequence.</span></span> <span data-ttu-id="c1232-134">È un costo associato con l'ordine, ma questo costo è in genere limitato.</span><span class="sxs-lookup"><span data-stu-id="c1232-134">There is a cost associated with ordering, but this cost is usually modest.</span></span> <span data-ttu-id="c1232-135">Le operazioni di Join e GroupBy allo stesso modo sovraccarico di lavoro.</span><span class="sxs-lookup"><span data-stu-id="c1232-135">GroupBy and Join operations likewise incur overhead.</span></span> <span data-ttu-id="c1232-136">PLINQ offre le prestazioni migliori quando è consentita per elaborare gli elementi della raccolta di origine in qualsiasi ordine e passare al successivo operatore non appena sono pronti.</span><span class="sxs-lookup"><span data-stu-id="c1232-136">PLINQ performs best when it is allowed to process elements in the source collection in any order, and pass them to the next operator as soon as they are ready.</span></span> <span data-ttu-id="c1232-137">Per altre informazioni, vedere [Conservazione dell'ordine in PLINQ](../../../docs/standard/parallel-programming/order-preservation-in-plinq.md).</span><span class="sxs-lookup"><span data-stu-id="c1232-137">For more information, see [Order Preservation in PLINQ](../../../docs/standard/parallel-programming/order-preservation-in-plinq.md).</span></span>  
  
4.  <span data-ttu-id="c1232-138">Il modulo di esecuzione di query.</span><span class="sxs-lookup"><span data-stu-id="c1232-138">The form of query execution.</span></span>  
  
     <span data-ttu-id="c1232-139">Se si archiviano i risultati di una query chiamando ToArray o ToList, i risultati di tutti i thread paralleli devono essere uniti in unica struttura di dati.</span><span class="sxs-lookup"><span data-stu-id="c1232-139">If you are storing the results of a query by calling ToArray or ToList, then the results from all parallel threads must be merged into the single data structure.</span></span> <span data-ttu-id="c1232-140">Ciò comporta un costo computazionale inevitabile.</span><span class="sxs-lookup"><span data-stu-id="c1232-140">This involves an unavoidable computational cost.</span></span> <span data-ttu-id="c1232-141">Analogamente, se si esegue un'iterazione dei risultati utilizzando un ciclo foreach (For Each in Visual Basic), i risultati dei thread di lavoro devono essere serializzati sul thread dell'enumeratore.</span><span class="sxs-lookup"><span data-stu-id="c1232-141">Likewise, if you iterate the results by using a foreach (For Each in Visual Basic) loop, the results from the worker threads need to be serialized onto the enumerator thread.</span></span> <span data-ttu-id="c1232-142">Ma se si desidera eseguire un'azione in base al risultato da ogni thread, è possibile utilizzare il metodo ForAll per eseguire questa operazione su più thread.</span><span class="sxs-lookup"><span data-stu-id="c1232-142">But if you just want to perform some action based on the result from each thread, you can use the ForAll method to perform this work on multiple threads.</span></span>  
  
5.  <span data-ttu-id="c1232-143">Il tipo di opzioni di unione.</span><span class="sxs-lookup"><span data-stu-id="c1232-143">The type of merge options.</span></span>  
  
     <span data-ttu-id="c1232-144">PLINQ può essere configurato per il relativo output nel buffer e produrre, in blocchi o in una sola volta dopo l'intero set di risultati viene prodotta, oppure per i singoli risultati flusso non appena vengono prodotti.</span><span class="sxs-lookup"><span data-stu-id="c1232-144">PLINQ can be configured to either buffer its output, and produce it in chunks or all at once after the entire result set is produced, or else to stream individual results as they are produced.</span></span> <span data-ttu-id="c1232-145">Il risultato precedente è ridotti i tempi di esecuzione complessivi e i risultati di quest'ultimi una riduzione della latenza tra gli elementi prodotti.</span><span class="sxs-lookup"><span data-stu-id="c1232-145">The former result is decreased overall execution time and the latter results in decreased latency between yielded elements.</span></span>  <span data-ttu-id="c1232-146">Mentre le opzioni di unione non presentano sempre un impatto significativo sulle prestazioni delle query complessive, possono avere un impatto sulle prestazioni percepite in quanto controllano per quanto tempo un utente deve attendere per verificare i risultati.</span><span class="sxs-lookup"><span data-stu-id="c1232-146">While the merge options do not always have a major impact on overall query performance, they can impact perceived performance because they control how long a user must wait to see results.</span></span> <span data-ttu-id="c1232-147">Per altre informazioni, vedere [Opzioni di unione in PLINQ](../../../docs/standard/parallel-programming/merge-options-in-plinq.md).</span><span class="sxs-lookup"><span data-stu-id="c1232-147">For more information, see [Merge Options in PLINQ](../../../docs/standard/parallel-programming/merge-options-in-plinq.md).</span></span>  
  
6.  <span data-ttu-id="c1232-148">Il tipo di partizionamento.</span><span class="sxs-lookup"><span data-stu-id="c1232-148">The kind of partitioning.</span></span>  
  
     <span data-ttu-id="c1232-149">In alcuni casi, una query PLINQ su una raccolta di origine indicizzabile può comportare un carico di lavoro non equilibrato.</span><span class="sxs-lookup"><span data-stu-id="c1232-149">In some cases, a PLINQ query over an indexable source collection may result in an unbalanced work load.</span></span> <span data-ttu-id="c1232-150">In questo caso, potrebbe essere in grado di aumentare le prestazioni delle query creando un partitioner.</span><span class="sxs-lookup"><span data-stu-id="c1232-150">When this occurs, you might be able to increase the query performance by creating a custom partitioner.</span></span> <span data-ttu-id="c1232-151">Per altre informazioni, vedere [Partitioner personalizzati per PLINQ e TPL](../../../docs/standard/parallel-programming/custom-partitioners-for-plinq-and-tpl.md).</span><span class="sxs-lookup"><span data-stu-id="c1232-151">For more information, see [Custom Partitioners for PLINQ and TPL](../../../docs/standard/parallel-programming/custom-partitioners-for-plinq-and-tpl.md).</span></span>  
  
## <a name="when-plinq-chooses-sequential-mode"></a><span data-ttu-id="c1232-152">Quando PLINQ sceglie la modalità sequenziale</span><span class="sxs-lookup"><span data-stu-id="c1232-152">When PLINQ Chooses Sequential Mode</span></span>  
 <span data-ttu-id="c1232-153">PLINQ tenterà sempre di eseguire una query almeno stessa velocità con la query verrebbe eseguita in sequenza.</span><span class="sxs-lookup"><span data-stu-id="c1232-153">PLINQ will always attempt to execute a query at least as fast as the query would run sequentially.</span></span> <span data-ttu-id="c1232-154">Anche se PLINQ non computazionale costosa i delegati dell'utente o Qual è l'origine di input, sembra essere per determinate query "forme".</span><span class="sxs-lookup"><span data-stu-id="c1232-154">Although PLINQ does not look at how computationally expensive the user delegates are, or how big the input source is, it does look for certain query "shapes."</span></span> <span data-ttu-id="c1232-155">In particolare, Cerca gli operatori di query o delle combinazioni di operatori che in genere una query viene eseguita più lentamente in modalità parallela.</span><span class="sxs-lookup"><span data-stu-id="c1232-155">Specifically, it looks for query operators or combinations of operators that typically cause a query to execute more slowly in parallel mode.</span></span> <span data-ttu-id="c1232-156">Quando trova tali forme, PLINQ per impostazione predefinita il fallback alla modalità sequenziale.</span><span class="sxs-lookup"><span data-stu-id="c1232-156">When it finds such shapes, PLINQ by default falls back to sequential mode.</span></span>  
  
 <span data-ttu-id="c1232-157">Tuttavia, dopo la misurazione delle prestazioni di query specifico, è possibile determinare che venga effettivamente eseguito più velocemente in modalità parallela.</span><span class="sxs-lookup"><span data-stu-id="c1232-157">However, after measuring a specific query's performance, you may determine that it actually runs faster in parallel mode.</span></span> <span data-ttu-id="c1232-158">In questi casi è possibile utilizzare il <xref:System.Linq.ParallelExecutionMode.ForceParallelism?displayProperty=nameWithType> flag tramite il <xref:System.Linq.ParallelEnumerable.WithExecutionMode%2A> metodo per indicare a PLINQ per parallelizzare la query.</span><span class="sxs-lookup"><span data-stu-id="c1232-158">In such cases you can use the <xref:System.Linq.ParallelExecutionMode.ForceParallelism?displayProperty=nameWithType> flag via the <xref:System.Linq.ParallelEnumerable.WithExecutionMode%2A> method to instruct PLINQ to parallelize the query.</span></span> <span data-ttu-id="c1232-159">Per altre informazioni, vedere [Procedura: Specificare la modalità di esecuzione in PLINQ](../../../docs/standard/parallel-programming/how-to-specify-the-execution-mode-in-plinq.md).</span><span class="sxs-lookup"><span data-stu-id="c1232-159">For more information, see [How to: Specify the Execution Mode in PLINQ](../../../docs/standard/parallel-programming/how-to-specify-the-execution-mode-in-plinq.md).</span></span>  
  
 <span data-ttu-id="c1232-160">L'elenco seguente descrive le forme di query PLINQ per impostazione predefinita verranno eseguite in modalità sequenziale:</span><span class="sxs-lookup"><span data-stu-id="c1232-160">The following list describes the query shapes that PLINQ by default will execute in sequential mode:</span></span>  
  
-   <span data-ttu-id="c1232-161">Le query che contengono un'istruzione Select, Where indicizzata, SelectMany indicizzata o nella clausola ElementAt dopo un operatore di ordinamento o filtro che ha rimosso o riorganizzare gli indici originali.</span><span class="sxs-lookup"><span data-stu-id="c1232-161">Queries that contain a Select, indexed Where, indexed SelectMany, or ElementAt clause after an ordering or filtering operator that has removed or rearranged original indices.</span></span>  
  
-   <span data-ttu-id="c1232-162">Query che contengono metodi Take, TakeWhile, Skip, SkipWhile operatore e in cui gli indici nella sequenza di origine non sono nell'ordine originale.</span><span class="sxs-lookup"><span data-stu-id="c1232-162">Queries that contain a Take, TakeWhile, Skip, SkipWhile operator and where indices in the source sequence are not in the original order.</span></span>  
  
-   <span data-ttu-id="c1232-163">Query che contengono Zip o SequenceEquals, a meno che in una delle origini dati non sia presente un indice originariamente ordinato e l'altra origine dati non sia indicizzabile (ad esempio un array o IList(T)).</span><span class="sxs-lookup"><span data-stu-id="c1232-163">Queries that contain Zip or SequenceEquals, unless one of the data sources has an originally ordered index and the other data source is indexable (i.e. an array or IList(T)).</span></span>  
  
-   <span data-ttu-id="c1232-164">Query che contengono Concat, a meno che non viene applicato a origini dati indicizzabili.</span><span class="sxs-lookup"><span data-stu-id="c1232-164">Queries that contain Concat, unless it is applied to indexable data sources.</span></span>  
  
-   <span data-ttu-id="c1232-165">Invertire le query che contengono, a meno che non applicato a un'origine dati indicizzabili.</span><span class="sxs-lookup"><span data-stu-id="c1232-165">Queries that contain Reverse, unless applied to an indexable data source.</span></span>  
  
## <a name="see-also"></a><span data-ttu-id="c1232-166">Vedere anche</span><span class="sxs-lookup"><span data-stu-id="c1232-166">See Also</span></span>  
 [<span data-ttu-id="c1232-167">Parallel LINQ (PLINQ)</span><span class="sxs-lookup"><span data-stu-id="c1232-167">Parallel LINQ (PLINQ)</span></span>](../../../docs/standard/parallel-programming/parallel-linq-plinq.md)
