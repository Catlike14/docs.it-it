---
title: "Flusso di dati (Task Parallel Library) | Microsoft Docs"
ms.custom: ""
ms.date: "03/30/2017"
ms.prod: ".net"
ms.reviewer: ""
ms.suite: ""
ms.technology: 
  - "dotnet-standard"
ms.tgt_pltfrm: ""
ms.topic: "article"
helpviewer_keywords: 
  - "Task Parallel Library, flussi di dati"
  - "libreria di flussi di dati TPL"
ms.assetid: 643575d0-d26d-4c35-8de7-a9c403e97dd6
caps.latest.revision: 22
author: "rpetrusha"
ms.author: "ronpet"
manager: "wpickett"
caps.handback.revision: 22
---
# Flusso di dati (Task Parallel Library)
<a name="top"></a>Task Parallel Library (TPL) fornisce componenti del flusso di dati per aumentare l'affidabilità delle applicazioni abilitate per la concorrenza. Questi componenti sono collettivamente il *flussi di dati TPL*. Con questo modello del flusso di dati viene promossa la programmazione basata su attori fornendo il passaggio di messaggi in-process per attività di pipelining e per un flusso di dati con granularità grossolana. I componenti del flusso di dati sono basati sui tipi e sull'infrastruttura di pianificazione della libreria TPL e si integrano con il supporto dei linguaggi C#, [!INCLUDE[vbprvb](../../../includes/vbprvb-md.md)] e F# per la programmazione asincrona. Questi componenti sono utili qualora siano presenti più operazioni che devono comunicare tra loro in modo asincrono o qualora si desideri elaborare i dati non appena diventano disponibili. Si consideri, ad esempio, un'applicazione tramite cui vengono elaborati i dati immagine di una webcam. Tramite il modello del flusso di dati, l'applicazione è in grado di elaborare i fotogrammi delle immagini quando diventano disponibili. Se l'applicazione vengono migliorati i fotogrammi dell'immagine, ad esempio, eseguendo la riduzione occhi rossi o correzione chiara, è possibile creare un *pipeline* dei componenti del flusso di dati. In ogni fase della pipeline è possibile utilizzare la funzionalità di parallelismo con maggiore granulosità grossolana, ad esempio la funzionalità fornita dalla libreria TPL, per trasformare l'immagine.  
  
 In questo documento viene fornita una panoramica della libreria del flusso di dati TPL. Vengono descritti il modello di programmazione e i tipi di blocchi di flussi di dati predefiniti e viene indicato come configurare i blocchi di flussi di dati per soddisfare specifici requisiti delle applicazioni.  
  
> [!TIP]
>  La libreria del flusso di dati TPL (<xref:System.Threading.Tasks.Dataflow?displayProperty=fullName> dello spazio dei nomi) non viene distribuita con il [!INCLUDE[net_v45](../../../includes/net-v45-md.md)]. Per installare il <xref:System.Threading.Tasks.Dataflow> spazio dei nomi, aprire il progetto in [!INCLUDE[vs_dev11_long](../../../includes/vs-dev11-long-md.md)], scegliere **Gestisci pacchetti NuGet** dal menu progetto e cercare online il `Microsoft.Tpl.Dataflow` pacchetto.  
  
 Questo documento contiene le seguenti sezioni:  
  
-   [Modello di programmazione](#model)  
  
-   [Tipi di blocchi di flussi di dati predefiniti](#predefined_types)  
  
-   [Configurazione del comportamento di blocco](#behavior)  
  
-   [Blocchi di flussi di dati personalizzati](#custom)  
  
<a name="model"></a>   
## <a name="programming-model"></a>Modello di programmazione  
 La libreria del flusso di dati TPL fornisce una base per il passaggio dei messaggi e per la parallelizzazione delle applicazioni con utilizzo intensivo di I/O e di CPU con velocità effettiva elevata e bassa latenza. Offre inoltre un controllo esplicito sul modo in cui i dati vengono memorizzati nel buffer e spostati nel sistema. Per comprendere meglio il modello di programmazione del flusso di dati, si consideri un'applicazione tramite cui vengono caricate in modo asincrono le immagini dal disco e viene creata una composizione di queste immagini. Per i modelli di programmazione tradizionali viene in genere richiesto l'utilizzo di callback e oggetti di sincronizzazione, ad esempio blocchi, per coordinare le attività e accedere ai dati condivisi. Tramite il modello di programmazione del flusso di dati è possibile creare oggetti del flusso di dati mediante i quali vengono elaborate le immagini mentre sono lette dal disco. Nel modello del flusso di dati è possibile dichiarare la modalità di gestione dei dati quando disponibili, nonché tutte le dipendenze tra i dati. Poiché le dipendenze tra i dati sono gestite dal runtime, è spesso possibile evitare la necessità di sincronizzare l'accesso ai dati condivisi. Inoltre, dal momento che tramite il runtime il lavoro viene pianificato in base all'arrivo asincrono di dati, con il flusso di dati è possibile migliorare la velocità di risposta e la velocità effettiva gestendo i thread sottostanti in modo efficiente. Per un esempio che utilizza il modello di programmazione del flusso di dati per implementare l'elaborazione di immagini in un'applicazione Windows Form, vedere [procedura dettagliata: utilizzo flussi di dati in un'applicazione Windows Form](../../../docs/standard/parallel-programming/walkthrough-using-dataflow-in-a-windows-forms-application.md).  
  
### <a name="sources-and-targets"></a>Origini e destinazioni  
 La libreria del flusso di dati TPL è costituito da *blocchi di flussi di dati*, vale a dire dati strutture dati buffer ed elaborati. La libreria TPL vengono definiti tre tipi di blocchi di flussi di dati: *blocchi di origine*, *i blocchi di destinazione*, e *blocchi di propagazione*. Un blocco di origine viene utilizzato come origine di dati da cui è possibile leggere. Un blocco di destinazione viene utilizzato come destinatario di dati in cui è possibile scrivere. Un blocco di propagazione viene utilizzato sia come blocco di origine sia come blocco di destinazione, quindi da cui è possibile leggere e in cui è possibile scrivere. La libreria TPL vengono definiti il <xref:System.Threading.Tasks.Dataflow.ISourceBlock%601?displayProperty=fullName> interfaccia per rappresentare le origini, <xref:System.Threading.Tasks.Dataflow.ITargetBlock%601?displayProperty=fullName> per rappresentare le destinazioni e <xref:System.Threading.Tasks.Dataflow.IPropagatorBlock%602?displayProperty=fullName> per rappresentare le propagazioni.</TInput, TOutput> <xref:System.Threading.Tasks.Dataflow.IPropagatorBlock%602> eredita sia da <xref:System.Threading.Tasks.Dataflow.ISourceBlock%601>, e <xref:System.Threading.Tasks.Dataflow.ITargetBlock%601>.\</TInput, TOutput>  
  
 La libreria di flussi di dati TPL fornisce vari tipi di blocchi di flussi di dati predefiniti che implementano il <xref:System.Threading.Tasks.Dataflow.ISourceBlock%601>, <xref:System.Threading.Tasks.Dataflow.ITargetBlock%601>, e <xref:System.Threading.Tasks.Dataflow.IPropagatorBlock%602> interfacce.\</TInput, TOutput> Questi tipi di blocchi di flussi di dati sono descritti in questo documento nella sezione [tipi di blocchi del flusso di dati predefiniti](#predefined_types).  
  
### <a name="connecting-blocks"></a>Connessione di blocchi  
 È possibile connettere blocchi di flussi di dati in formato *pipeline*, che sono sequenze lineari di blocchi di flussi di dati, o *reti*, che sono grafici di blocchi di flussi di dati. Una pipeline è un tipo di rete. I dati di origini in una pipeline o in una rete vengono propagati nelle destinazioni in modo asincrono quando i dati in questione diventano disponibili. Il <xref:System.Threading.Tasks.Dataflow.ISourceBlock%601.LinkTo%2A?displayProperty=fullName> metodo collega un blocco di flussi di dati di origine a un blocco di destinazione. Un'origine può essere collegata a zero o più destinazioni, mentre queste ultime possono essere collegate da zero o più origini. È possibile aggiungere o rimuovere contemporaneamente blocchi di flussi di dati a o da una pipeline o rete. Tramite i tipi di blocchi di flussi di dati predefiniti vengono gestiti tutti gli aspetti di collegamento e scollegamento thread safety.  
  
 Per un esempio di connessione di blocchi di flussi di dati per formare una pipeline di base, vedere [procedura dettagliata: creazione di una Pipeline di dati](../../../docs/standard/parallel-programming/walkthrough-creating-a-dataflow-pipeline.md). Per un esempio di connessione di blocchi di flussi di dati per formare una rete più complessa, vedere [procedura dettagliata: utilizzo flussi di dati in un'applicazione Windows Form](../../../docs/standard/parallel-programming/walkthrough-using-dataflow-in-a-windows-forms-application.md). Per un esempio di scollegamento di una destinazione di un'origine dopo l'offerta di destinazione un messaggio, vedere [procedura: scollegare i blocchi di flussi di dati](../../../docs/standard/parallel-programming/how-to-unlink-dataflow-blocks.md).  
  
#### <a name="filtering"></a>Filtro  
 Quando si chiama il <xref:System.Threading.Tasks.Dataflow.ISourceBlock%601.LinkTo%2A?displayProperty=fullName> metodo a cui collegare un'origine a una destinazione, è possibile fornire un delegato che determina se il blocco di destinazione accetta o rifiuta un messaggio in base al valore di tale messaggio. Questo meccanismo di filtro è utile per garantire la ricezione solo di determinati valori da parte di un blocco di flussi di dati. Per la maggior parte dei tipi di blocchi di flussi di dati predefiniti, se un blocco di origine è connesso a più blocchi di destinazione, quando da parte di un blocco di destinazione viene rifiutato un messaggio, quest'ultimo tramite l'origine viene offerto alla destinazione successiva. L'ordine di offerta dei messaggi da parte dell'origine alle destinazioni viene definito dall'origine e può variare a seconda del tipo di origine. L'offerta di un messaggio da parte della maggior parte dei tipi di blocco di origine viene arrestata dopo l'accettazione del messaggio in questione da una destinazione. Fa eccezione a questa regola di <xref:System.Threading.Tasks.Dataflow.BroadcastBlock%601> (classe), che offre a tutte le destinazioni, ogni messaggio, anche se alcune destinazioni rifiutare il messaggio. Per un esempio che usa il filtro per elaborare solo determinati messaggi, vedere [procedura dettagliata: utilizzo flussi di dati in un'applicazione Windows Form](../../../docs/standard/parallel-programming/walkthrough-using-dataflow-in-a-windows-forms-application.md).  
  
> [!IMPORTANT]
>  Poiché ogni tipo di blocco di flussi di dati di origine predefinito garantisce la propagazione all'esterno di questi messaggi nell'ordine in cui vengono ricevuti, ogni messaggio deve essere letto dal blocco di origine prima che da parte di quest'ultimo possa essere elaborato il messaggio successivo. Di conseguenza, quando si utilizzano i filtri per connettere più destinazioni a un'origine, accertarsi che ogni messaggio venga ricevuto da almeno un blocco di destinazione. In caso contrario, si potrebbe verificare un deadlock dell'applicazione.  
  
### <a name="message-passing"></a>Passaggio dei messaggi  
 Il modello di programmazione del flusso di dati è correlato al concetto di *passaggio dei messaggi*, in cui i componenti indipendenti di un programma di comunicano tra loro mediante l'invio di messaggi. Un modo per propagare i messaggi tra i componenti dell'applicazione consiste nel chiamare il <xref:System.Threading.Tasks.Dataflow.DataflowBlock.Post%2A> e <xref:System.Threading.Tasks.Dataflow.DataflowBlock.SendAsync%2A?displayProperty=fullName> metodi per inviare messaggi ai post di blocchi di destinazione del flusso di dati (<xref:System.Threading.Tasks.Dataflow.DataflowBlock.Post%2A> funziona in modo sincrono; <xref:System.Threading.Tasks.Dataflow.DataflowBlock.SendAsync%2A> funziona in modo asincrono) e <xref:System.Threading.Tasks.Dataflow.DataflowBlock.Receive%2A>, <xref:System.Threading.Tasks.Dataflow.DataflowBlock.ReceiveAsync%2A>, e <xref:System.Threading.Tasks.Dataflow.DataflowBlock.TryReceive%2A> metodi per ricevere messaggi da blocchi di origine. È possibile combinare questi metodi con pipeline o reti del flusso di dati inviando i dati di input al nodo principale (blocco di destinazione) e ricevendo i dati di output dal nodo terminale della pipeline o dai nodi terminali della rete (uno o più blocchi di origine). È inoltre possibile utilizzare il <xref:System.Threading.Tasks.Dataflow.DataflowBlock.Choose%2A> per leggere dalla prima delle origini fornite sono disponibili dati ed eseguire azioni su tali dati.  
  
 Blocchi di origine offrono dati ai blocchi di destinazione chiamando il <xref:System.Threading.Tasks.Dataflow.ITargetBlock%601.OfferMessage%2A?displayProperty=fullName> metodo. La risposta a un messaggio offerto viene fornita dal blocco di destinazione in tre modalità: il messaggio può essere accettato, rifiutato o posticipato. Quando la destinazione accetta il messaggio, il <xref:System.Threading.Tasks.Dataflow.ITargetBlock%601.OfferMessage%2A> restituisce <xref:System.Threading.Tasks.Dataflow.DataflowMessageStatus>. Quando la destinazione rifiuta il messaggio, il <xref:System.Threading.Tasks.Dataflow.ITargetBlock%601.OfferMessage%2A> restituisce <xref:System.Threading.Tasks.Dataflow.DataflowMessageStatus>. Quando la destinazione è necessario che non riceva più tutti i messaggi dall'origine, <xref:System.Threading.Tasks.Dataflow.ITargetBlock%601.OfferMessage%2A> restituisce <xref:System.Threading.Tasks.Dataflow.DataflowMessageStatus>. I tipi di blocchi di origine predefiniti non offrono messaggi alle destinazioni collegate dopo la ricezione di un valore restituito di questo tipo e vengono scollegati automaticamente da queste destinazioni.  
  
 Quando il messaggio per un utilizzo successivo viene posticipato un blocco di destinazione di <xref:System.Threading.Tasks.Dataflow.ITargetBlock%601.OfferMessage%2A> metodo <xref:System.Threading.Tasks.Dataflow.DataflowMessageStatus>. Un blocco di destinazione che viene posticipato un messaggio è possibile effettuare chiamate successive il <xref:System.Threading.Tasks.Dataflow.ISourceBlock%601.ReserveMessage%2A?displayProperty=fullName> metodo per provare a prenotare il messaggio offerto. A questo punto, il messaggio è ancora disponibile e può essere utilizzato dal blocco di destinazione oppure è stato accettato da un'altra destinazione. Quando il blocco di destinazione in un secondo momento richiede il messaggio o non è più necessario che il messaggio, chiama il <xref:System.Threading.Tasks.Dataflow.ISourceBlock%601.ConsumeMessage%2A?displayProperty=fullName> o <xref:System.Threading.Tasks.Dataflow.ISourceBlock%601.ReleaseReservation%2A> (metodo), rispettivamente. La prenotazione dei messaggi viene in genere utilizzata dai tipi di blocchi di flussi di dati che operano in modalità non greedy. La modalità non greedy verrà illustrata più avanti in questo documento. Anziché riservare un messaggio Posposto, è possibile utilizzare anche un blocco di destinazione di <xref:System.Threading.Tasks.Dataflow.ISourceBlock%601.ConsumeMessage%2A?displayProperty=fullName> metodo nel tentativo di utilizzare direttamente il messaggio posposto.  
  
### <a name="dataflow-block-completion"></a>Completamento dei blocchi di flussi di dati  
 Blocchi di flussi di dati supportano inoltre il concetto di *completamento*. Non viene eseguito alcun lavoro ulteriore da parte di un blocco di flussi di dati che si trova nello stato completato. Ogni blocco di flussi di dati è associato un <xref:System.Threading.Tasks.Task?displayProperty=fullName> oggetto, noto come un *attività di completamento*, che rappresenta lo stato di completamento del blocco. Poiché è possibile attendere un <xref:System.Threading.Tasks.Task> per completare, tramite le attività di completamento, è possibile attendere uno o più nodi terminali di un flusso di dati di rete alla fine dell'oggetto. Il <xref:System.Threading.Tasks.Dataflow.IDataflowBlock> interfaccia definisce il <xref:System.Threading.Tasks.Dataflow.IDataflowBlock.Complete%2A> (metodo), che informa il blocco di flussi di dati di una richiesta per il completamento, e <xref:System.Threading.Tasks.Dataflow.IDataflowBlock.Completion%2A> proprietà, che restituisce l'attività di completamento di questo tipo di blocco. Entrambi <xref:System.Threading.Tasks.Dataflow.ISourceBlock%601> e <xref:System.Threading.Tasks.Dataflow.ITargetBlock%601> ereditano il <xref:System.Threading.Tasks.Dataflow.IDataflowBlock> interfaccia.  
  
 Sono disponibili due modalità per determinare se un blocco di flussi di dati viene completato correttamente, se tramite esso vengono rilevati uno o più errori o se è stato annullato. Il primo modo consiste nel chiamare il <xref:System.Threading.Tasks.Task.Wait%2A?displayProperty=fullName> metodo sull'attività di completamento in un `try` - `catch` blocco (`Try` - `Catch` in Visual Basic). Nell'esempio seguente viene creato un <xref:System.Threading.Tasks.Dataflow.ActionBlock%601> oggetto che genera <xref:System.ArgumentOutOfRangeException> se il valore di input è minore di zero. <xref:System.AggregateException> viene generata quando viene chiamato in questo esempio <xref:System.Threading.Tasks.Task.Wait%2A> sull'attività di completamento. Il <xref:System.ArgumentOutOfRangeException> si accede tramite il <xref:System.AggregateException.InnerExceptions%2A> proprietà del <xref:System.AggregateException> oggetto.  
  
 [!code-csharp[TPLDataflow_Overview#10](../../../samples/snippets/csharp/VS_Snippets_Misc/tpldataflow_overview/cs/program.cs#10)]
 [!code-vb[TPLDataflow_Overview#10](../../../samples/snippets/visualbasic/VS_Snippets_Misc/tpldataflow_overview/vb/program.vb#10)]  
  
 In questo esempio viene illustrato il caso in cui un'eccezione non gestita viene inserita nel delegato di un blocco di flussi di dati di esecuzione. Si consiglia di gestire le eccezioni nei corpi di blocchi di questo tipo. In caso contrario, tuttavia, il comportamento del blocco è simile a quello di un annullamento e i messaggi in ingresso non vengono elaborati.  
  
 Quando un blocco di flussi di dati viene annullato in modo esplicito, il <xref:System.AggregateException> oggetto contiene <xref:System.OperationCanceledException> nel <xref:System.AggregateException.InnerExceptions%2A> proprietà. Per ulteriori informazioni sull'annullamento del flusso di dati, vedere Abilitazione dell'annullamento più avanti in questo documento.  
  
 La seconda modalità per determinare lo stato di completamento di un blocco di flussi di dati è utilizzare una continuazione dell'attività di completamento o le funzionalità asincrone dei linguaggi C# e Visual Basic per attendere in modo asincrono l'attività di completamento. Il delegato fornito per il <xref:System.Threading.Tasks.Task.ContinueWith%2A?displayProperty=fullName> metodo accetta un <xref:System.Threading.Tasks.Task> oggetto che rappresenta l'attività precedente. Nel caso del <xref:System.Threading.Tasks.Dataflow.IDataflowBlock.Completion%2A> proprietà, il delegato per la continuazione accetta l'attività di completamento. Nell'esempio seguente è simile a quello precedente, ad eccezione del fatto che viene utilizzato anche il <xref:System.Threading.Tasks.Task.ContinueWith%2A> metodo per creare un'attività di completamento che visualizza lo stato dell'operazione del flusso di dati globale.  
  
 [!code-csharp[TPLDataflow_Overview#11](../../../samples/snippets/csharp/VS_Snippets_Misc/tpldataflow_overview/cs/program.cs#11)]
 [!code-vb[TPLDataflow_Overview#11](../../../samples/snippets/visualbasic/VS_Snippets_Misc/tpldataflow_overview/vb/program.vb#11)]  
  
 È anche possibile utilizzare le proprietà, ad esempio <xref:System.Threading.Tasks.Task.IsCanceled%2A> nel corpo dell'attività di continuazione per determinare informazioni aggiuntive sullo stato di completamento di un blocco di flussi di dati. Per ulteriori informazioni sulle attività di continuazione e come interagiscono con l'annullamento e la gestione degli errori, vedere [concatenamento di attività tramite attività di continuazione](../../../docs/standard/parallel-programming/chaining-tasks-by-using-continuation-tasks.md), [annullamento delle attività](../../../docs/standard/parallel-programming/task-cancellation.md), [Exception Handling](../../../docs/standard/parallel-programming/exception-handling-task-parallel-library.md), e [NIB: procedura: gestire le eccezioni generate dalle attività](http://msdn.microsoft.com/it-it/d6c47ec8-9de9-4880-beb3-ff19ae51565d).  
  
 [[go to top](#top)]  
  
<a name="predefined_types"></a>   
## <a name="predefined-dataflow-block-types"></a>Tipi di blocchi di flussi di dati predefiniti  
 La libreria del flusso di dati TPL fornisce vari tipi di blocchi di flussi di dati predefiniti. Questi tipi sono suddivisi in tre categorie: *blocchi di buffering*, *blocchi di esecuzione*, e *blocchi di raggruppamento*. Nelle sezioni seguenti vengono descritti i tipi di blocchi che compongono queste categorie.  
  
### <a name="buffering-blocks"></a>Blocchi di buffering  
 Nei blocchi di buffering sono contenuti i dati utilizzati dai consumer di dati. La libreria del flusso di dati TPL fornisce tre tipi di blocchi di buffering: <xref:System.Threading.Tasks.Dataflow.BufferBlock%601?displayProperty=fullName>, <xref:System.Threading.Tasks.Dataflow.BroadcastBlock%601?displayProperty=fullName>, e <xref:System.Threading.Tasks.Dataflow.WriteOnceBlock%601?displayProperty=fullName>.  
  
#### <a name="bufferblockt"></a>BufferBlock(T)  
 Il <xref:System.Threading.Tasks.Dataflow.BufferBlock%601> classe rappresenta una struttura di messaggistica asincrona di utilizzo generale. Questa classe archivia una coda di messaggi FIFO (First In, First Out) che possono essere letti da più destinazioni o in cui possono scrivere più origini. Quando una destinazione riceve un messaggio da un <xref:System.Threading.Tasks.Dataflow.BufferBlock%601> oggetto messaggio viene rimosso dalla coda dei messaggi. Pertanto, sebbene un <xref:System.Threading.Tasks.Dataflow.BufferBlock%601> oggetto può avere più destinazioni, ogni messaggio verrà ricevuto da una sola destinazione. Il <xref:System.Threading.Tasks.Dataflow.BufferBlock%601> classe è utile quando si desidera passare più messaggi a un altro componente e tale componente deve ricevere ogni messaggio.  
  
 Nell'esempio di base seguente inseriti alcuni <xref:System.Int32> valori da un <xref:System.Threading.Tasks.Dataflow.BufferBlock%601> dell'oggetto e quindi legge i valori da tale oggetto.  
  
 [!code-csharp[TPLDataflow_Overview#1](../../../samples/snippets/csharp/VS_Snippets_Misc/tpldataflow_overview/cs/program.cs#1)]
 [!code-vb[TPLDataflow_Overview#1](../../../samples/snippets/visualbasic/VS_Snippets_Misc/tpldataflow_overview/vb/program.vb#1)]  
  
 Per un esempio completo che illustra come scrivere e leggere messaggi da un <xref:System.Threading.Tasks.Dataflow.BufferBlock%601> di oggetti, vedere [procedura: scrivere messaggi in e leggere messaggi da un Dataflow Block](../../../docs/standard/parallel-programming/how-to-write-messages-to-and-read-messages-from-a-dataflow-block.md).  
  
#### <a name="broadcastblockt"></a>BroadcastBlock(T)  
 Il <xref:System.Threading.Tasks.Dataflow.BroadcastBlock%601> classe è utile quando è necessario passare più messaggi a un altro componente, ma il componente necessita solo del valore più recente. Questa classe è utile anche quando si vuole trasmettere un messaggio a più componenti.  
  
 Esempio di base seguente viene inserito un <xref:System.Double> valore per un <xref:System.Threading.Tasks.Dataflow.BroadcastBlock%601> oggetto e quindi riletto dall'oggetto più volte. Poiché i valori non vengono rimossi da <xref:System.Threading.Tasks.Dataflow.BroadcastBlock%601> oggetti dopo la lettura, lo stesso valore è disponibile ogni volta.  
  
 [!code-csharp[TPLDataflow_Overview#2](../../../samples/snippets/csharp/VS_Snippets_Misc/tpldataflow_overview/cs/program.cs#2)]
 [!code-vb[TPLDataflow_Overview#2](../../../samples/snippets/visualbasic/VS_Snippets_Misc/tpldataflow_overview/vb/program.vb#2)]  
  
 Per un esempio completo che illustra come usare <xref:System.Threading.Tasks.Dataflow.BroadcastBlock%601> per trasmettere un messaggio a più blocchi di destinazione, vedere [procedura: specificare un'utilità di pianificazione in un Dataflow Block](../../../docs/standard/parallel-programming/how-to-specify-a-task-scheduler-in-a-dataflow-block.md).  
  
#### <a name="writeonceblockt"></a>WriteOnceBlock(T)  
 Il <xref:System.Threading.Tasks.Dataflow.WriteOnceBlock%601> classe è simile al <xref:System.Threading.Tasks.Dataflow.BroadcastBlock%601> classe, con la differenza che un <xref:System.Threading.Tasks.Dataflow.WriteOnceBlock%601> oggetto può essere scritto una sola volta. È possibile pensare <xref:System.Threading.Tasks.Dataflow.WriteOnceBlock%601> come c# [readonly](../Topic/readonly%20\(C%23%20Reference\).md) ([ReadOnly](../Topic/ReadOnly%20\(Visual%20Basic\).md) in [!INCLUDE[vbprvb](../../../includes/vbprvb-md.md)]) (parola chiave), tranne il fatto che un <xref:System.Threading.Tasks.Dataflow.WriteOnceBlock%601> oggetto diventa non modificabile dopo la ricezione di un valore anziché in fase di costruzione. Ad esempio il <xref:System.Threading.Tasks.Dataflow.BroadcastBlock%601> (classe), quando una destinazione riceve un messaggio da un <xref:System.Threading.Tasks.Dataflow.WriteOnceBlock%601> dell'oggetto, il messaggio non viene rimosso dall'oggetto in questione. Pertanto, più destinazioni riceveranno una copia del messaggio. Il <xref:System.Threading.Tasks.Dataflow.WriteOnceBlock%601> classe è utile quando si desidera propagare solo il primo di più messaggi.  
  
 Nell'esempio di base seguente post più <xref:System.String> valori da un <xref:System.Threading.Tasks.Dataflow.WriteOnceBlock%601> oggetto e quindi vengono riletti dall'oggetto in questione. Poiché un <xref:System.Threading.Tasks.Dataflow.WriteOnceBlock%601> oggetto può essere scritto una sola volta solo dopo un <xref:System.Threading.Tasks.Dataflow.WriteOnceBlock%601> oggetto riceve un messaggio, i messaggi successivi vengono rimossi.  
  
 [!code-csharp[TPLDataflow_Overview#3](../../../samples/snippets/csharp/VS_Snippets_Misc/tpldataflow_overview/cs/program.cs#3)]
 [!code-vb[TPLDataflow_Overview#3](../../../samples/snippets/visualbasic/VS_Snippets_Misc/tpldataflow_overview/vb/program.vb#3)]  
  
 Per un esempio completo che illustra come usare <xref:System.Threading.Tasks.Dataflow.WriteOnceBlock%601> per ricevere il valore della prima operazione che viene completata, vedere [procedura: scollegare i blocchi di flussi di dati](../../../docs/standard/parallel-programming/how-to-unlink-dataflow-blocks.md).  
  
### <a name="execution-blocks"></a>Blocchi di esecuzione  
 Tramite i blocchi di esecuzione viene chiamato un delegato fornito dall'utente per ogni blocco di dati ricevuti. La libreria di flussi di dati TPL fornisce tre tipi di blocchi di esecuzione: <xref:System.Threading.Tasks.Dataflow.ActionBlock%601>, <xref:System.Threading.Tasks.Dataflow.TransformBlock%602?displayProperty=fullName>, e <xref:System.Threading.Tasks.Dataflow.TransformManyBlock%602?displayProperty=fullName>.\</TInput, TOutput> \</TInput, TOutput>  
  
#### <a name="actionblockt"></a>ActionBlock(T)  
 Il <xref:System.Threading.Tasks.Dataflow.ActionBlock%601> classe è un blocco di destinazione che chiama un delegato alla ricezione dei dati. Si tratta di un <xref:System.Threading.Tasks.Dataflow.ActionBlock%601> oggetto come un delegato che viene eseguito in modo asincrono quando i dati diventano disponibili. Il delegato fornito a un <xref:System.Threading.Tasks.Dataflow.ActionBlock%601> oggetto può essere di tipo <xref:System.Action> o tipo `System.Func\<TInput, Task>`. Quando si utilizza un <xref:System.Threading.Tasks.Dataflow.ActionBlock%601> con <xref:System.Action>, l'elaborazione di ogni elemento di input viene considerata completata alla restituzione del delegato. Quando si utilizza un <xref:System.Threading.Tasks.Dataflow.ActionBlock%601> con `System.Func\<TInput, Task>`, l'elaborazione di ogni elemento di input viene considerata completata solo quando l'oggetto restituito <xref:System.Threading.Tasks.Task> oggetto è stato completato. Tramite questi due meccanismi, è possibile utilizzare <xref:System.Threading.Tasks.Dataflow.ActionBlock%601> per l'elaborazione sincrona e asincrona di ogni elemento di input.  
  
 Nell'esempio di base seguente post più <xref:System.Int32> valori da un <xref:System.Threading.Tasks.Dataflow.ActionBlock%601> oggetto. Il <xref:System.Threading.Tasks.Dataflow.ActionBlock%601> oggetto vengono stampati i valori nella console. In questo esempio il blocco viene quindi impostato sullo stato completato e attende il completamento di tutte le attività del flusso di dati.  
  
 [!code-csharp[TPLDataflow_Overview#4](../../../samples/snippets/csharp/VS_Snippets_Misc/tpldataflow_overview/cs/program.cs#4)]
 [!code-vb[TPLDataflow_Overview#4](../../../samples/snippets/visualbasic/VS_Snippets_Misc/tpldataflow_overview/vb/program.vb#4)]  
  
 Per esempi completi in cui viene illustrato come utilizzare i delegati con la <xref:System.Threading.Tasks.Dataflow.ActionBlock%601> , vedere [procedura: eseguire quando un flusso di dati blocco riceve i dati dell'azione](../../../docs/standard/parallel-programming/how-to-perform-action-when-a-dataflow-block-receives-data.md).  
  
#### <a name="transformblocktinput-toutput"></a>TransformBlock(TInput, TOutput)  
 Il <xref:System.Threading.Tasks.Dataflow.TransformBlock%602> classe è simile al <xref:System.Threading.Tasks.Dataflow.ActionBlock%601> classe, ad eccezione del fatto che viene utilizzata sia come origine sia come destinazione.\</TInput, TOutput> Il delegato che viene passato a un <xref:System.Threading.Tasks.Dataflow.TransformBlock%602> oggetto restituisce un valore di tipo `TOutput`.</TInput, TOutput> Il delegato fornito a un <xref:System.Threading.Tasks.Dataflow.TransformBlock%602> oggetto può essere di tipo `System.Func<TInput, TOutput>` o tipo `System.Func<TInput, Task>`.\</TInput, TOutput> Quando si utilizza un <xref:System.Threading.Tasks.Dataflow.TransformBlock%602> con `System.Func\<TInput, TOutput>`, l'elaborazione di ogni elemento di input viene considerata completata alla restituzione del delegato.</TInput, TOutput> Quando si utilizza un <xref:System.Threading.Tasks.Dataflow.TransformBlock%602> oggetto utilizzato con `System.Func<TInput, Task<TOutput>>`, l'elaborazione di ogni elemento di input viene considerata completata solo quando l'oggetto restituito <xref:System.Threading.Tasks.Task> oggetto è stato completato.\</TInput, TOutput> Come con <xref:System.Threading.Tasks.Dataflow.ActionBlock%601>, tramite questi due meccanismi, è possibile utilizzare <xref:System.Threading.Tasks.Dataflow.TransformBlock%602> per l'elaborazione sincrona e asincrona di ogni elemento di input.\</TInput, TOutput>  
  
 Nell'esempio di base seguente viene creato un <xref:System.Threading.Tasks.Dataflow.TransformBlock%602> oggetto che calcola la radice quadrata dell'input.</TInput, TOutput> Il <xref:System.Threading.Tasks.Dataflow.TransformBlock%602> richiede <xref:System.Int32> valori come input e produce <xref:System.Double> valori come output.\</TInput, TOutput>  
  
 [!code-csharp[TPLDataflow_Overview#5](../../../samples/snippets/csharp/VS_Snippets_Misc/tpldataflow_overview/cs/program.cs#5)]
 [!code-vb[TPLDataflow_Overview#5](../../../samples/snippets/visualbasic/VS_Snippets_Misc/tpldataflow_overview/vb/program.vb#5)]  
  
 Per esempi completi che utilizza <xref:System.Threading.Tasks.Dataflow.TransformBlock%602> in una rete di blocchi di flussi di dati che esegue l'elaborazione di immagini in un'applicazione Windows Form, vedere [procedura dettagliata: utilizzo flussi di dati in un'applicazione Windows Form](../../../docs/standard/parallel-programming/walkthrough-using-dataflow-in-a-windows-forms-application.md).\</TInput, TOutput>  
  
#### <a name="transformmanyblocktinput-toutput"></a>TransformManyBlock(TInput, TOutput)  
 Il <xref:System.Threading.Tasks.Dataflow.TransformManyBlock%602> classe è simile al <xref:System.Threading.Tasks.Dataflow.TransformBlock%602> classe, con la differenza che <xref:System.Threading.Tasks.Dataflow.TransformManyBlock%602> produce zero o più valori di output per ogni valore di input, anziché solo un valore di output per ogni valore di input.</TInput, TOutput> </TInput, TOutput> </TInput, TOutput> Il delegato fornito a un <xref:System.Threading.Tasks.Dataflow.TransformManyBlock%602> oggetto può essere di tipo `System.Func<TInput, IEnumerable<TOutput>>` o `type System.Func<TInput, Task<IEnumerable<TOutput>>>`.\</TInput, TOutput> Quando si utilizza un <xref:System.Threading.Tasks.Dataflow.TransformManyBlock%602> con `System.Func<TInput, IEnumerable<TOutput>>`, l'elaborazione di ogni elemento di input viene considerata completata alla restituzione del delegato.</TInput, TOutput> Quando si utilizza un <xref:System.Threading.Tasks.Dataflow.TransformManyBlock%602> con `System.Func<TInput, Task<IEnumerable<TOutput>>>`, l'elaborazione di ogni elemento di input viene considerata completata solo quando l'oggetto restituito `System.Threading.Tasks.Task<IEnumerable<TOutput>>` oggetto è stato completato.\</TInput, TOutput>  
  
 Nell'esempio di base seguente viene creato un <xref:System.Threading.Tasks.Dataflow.TransformManyBlock%602> oggetto che le stringhe vengono suddivise in singole sequenze di caratteri.</TInput, TOutput> Il <xref:System.Threading.Tasks.Dataflow.TransformManyBlock%602> richiede <xref:System.String> valori come input e produce <xref:System.Char> valori come output.\</TInput, TOutput>  
  
 [!code-csharp[TPLDataflow_Overview#6](../../../samples/snippets/csharp/VS_Snippets_Misc/tpldataflow_overview/cs/program.cs#6)]
 [!code-vb[TPLDataflow_Overview#6](../../../samples/snippets/visualbasic/VS_Snippets_Misc/tpldataflow_overview/vb/program.vb#6)]  
  
 Per esempi completi che utilizzano <xref:System.Threading.Tasks.Dataflow.TransformManyBlock%602> per generare più output indipendenti per ogni input in una pipeline di dati, vedere [procedura dettagliata: creazione di una Pipeline di dati](../../../docs/standard/parallel-programming/walkthrough-creating-a-dataflow-pipeline.md).\</TInput, TOutput>  
  
#### <a name="degree-of-parallelism"></a>Grado di parallelismo  
 Ogni <xref:System.Threading.Tasks.Dataflow.ActionBlock%601>, <xref:System.Threading.Tasks.Dataflow.TransformBlock%602>, e <xref:System.Threading.Tasks.Dataflow.TransformManyBlock%602> buffer oggetto messaggi di input fino a quando il blocco è pronto per elaborarli.</TInput, TOutput> </TInput, TOutput> Per impostazione predefinita, i messaggi vengono elaborati da queste classi nell'ordine in cui vengono ricevuti, un messaggio alla volta. È inoltre possibile specificare il grado di parallelismo per consentire <xref:System.Threading.Tasks.Dataflow.ActionBlock%601>, <xref:System.Threading.Tasks.Dataflow.TransformBlock%602> e <xref:System.Threading.Tasks.Dataflow.TransformManyBlock%602> oggetti da elaborare più messaggi contemporaneamente.\</TInput, TOutput> \</TInput, TOutput> Per ulteriori informazioni sull'esecuzione simultanea, vedere la sezione Specifica del grado di parallelismo più avanti in questo documento. Per un esempio che imposta il grado di parallelismo per consentire a un blocco di flussi di dati di esecuzione elaborare più messaggi contemporaneamente, vedere [procedura: specificare il grado di parallelismo in un Dataflow Block](../../../docs/standard/parallel-programming/how-to-specify-the-degree-of-parallelism-in-a-dataflow-block.md).  
  
#### <a name="summary-of-delegate-types"></a>Riepilogo dei tipi delegati  
 Nella tabella seguente sono riepilogati i tipi delegati che è possibile fornire a <xref:System.Threading.Tasks.Dataflow.ActionBlock%601>, <xref:System.Threading.Tasks.Dataflow.TransformBlock%602>, e <xref:System.Threading.Tasks.Dataflow.TransformManyBlock%602> oggetti.\</TInput, TOutput> \</TInput, TOutput> Viene inoltre specificato se il tipo delegato viene eseguito in modo sincrono o asincrono.  
  
|Tipo|Tipo delegato sincrono|Tipo delegato asincrono|  
|----------|-------------------------------|--------------------------------|  
|<xref:System.Threading.Tasks.Dataflow.ActionBlock%601>|`System.Action`|`System.Func\<TInput, Task>`|  
|<xref:System.Threading.Tasks.Dataflow.TransformBlock%602></TInput, TOutput>|`System.Func\<TInput, TOutput>`2`|`System.Func<TInput, Task<TOutput>>`|  
|<xref:System.Threading.Tasks.Dataflow.TransformManyBlock%602></TInput, TOutput>|`System.Func<TInput, IEnumerable<TOutput>>`|`System.Func<TInput, Task<IEnumerable<TOutput>>>`|  
  
 È inoltre possibile utilizzare le espressioni lambda quando si utilizzano tipi di blocchi di esecuzione. Per un esempio in cui viene illustrato come utilizzare un'espressione lambda con un blocco di esecuzione, vedere [procedura: eseguire quando un flusso di dati blocco riceve i dati dell'azione](../../../docs/standard/parallel-programming/how-to-perform-action-when-a-dataflow-block-receives-data.md).  
  
### <a name="grouping-blocks"></a>Blocchi di raggruppamento  
 Con i blocchi di raggruppamento è possibile combinare i dati da una o più origini e con vari vincoli. La libreria di flussi di dati TPL fornisce tre tipi di blocchi join: <xref:System.Threading.Tasks.Dataflow.BatchBlock%601>, <xref:System.Threading.Tasks.Dataflow.JoinBlock%602>, e <xref:System.Threading.Tasks.Dataflow.BatchedJoinBlock%602>.\</T1, T2> \</T1, T2>  
  
#### <a name="batchblockt"></a>BatchBlock(T)  
 Il <xref:System.Threading.Tasks.Dataflow.BatchBlock%601> classe combina i set di dati di input, noti come batch, in matrici di dati di output. Specificare la dimensione di ciascun batch quando si crea un <xref:System.Threading.Tasks.Dataflow.BatchBlock%601> oggetto. Quando il <xref:System.Threading.Tasks.Dataflow.BatchBlock%601> oggetto riceve il numero specificato di elementi di input, viene propagata in modo asincrono all'esterno una matrice contenente gli elementi. Se un <xref:System.Threading.Tasks.Dataflow.BatchBlock%601> oggetto è impostato sullo stato completato ma non contiene elementi sufficienti per formare un batch, viene propagata all'esterno una matrice finale contenente gli elementi di input rimanenti.  
  
 Il <xref:System.Threading.Tasks.Dataflow.BatchBlock%601> classe viene eseguita in modalità *greedy* o *non-greedy* modalità. In modalità greedy, ovvero l'impostazione predefinita, un <xref:System.Threading.Tasks.Dataflow.BatchBlock%601> oggetto accetta ogni messaggio che viene offerto e propaga all'esterno una matrice dopo aver ricevuto il numero specificato di elementi. In modalità non greedy, un <xref:System.Threading.Tasks.Dataflow.BatchBlock%601> oggetto vengono posticipati tutti i messaggi in ingresso finché non sufficiente origini offerti messaggi al blocco per formare un batch. L'esecuzione in modalità greedy è in genere migliore rispetto a quella non greedy dal momento che necessita di un sovraccarico inferiore di elaborazione. Tuttavia, è possibile utilizzare la modalità non greedy quando è necessario coordinare l'utilizzo da più origini in modo atomico. Specificare la modalità non greedy impostando <xref:System.Threading.Tasks.Dataflow.GroupingDataflowBlockOptions.Greedy%2A> a `False` nel `dataflowBlockOptions` parametro il <xref:System.Threading.Tasks.Dataflow.BatchBlock%601.%23ctor%2A> costruttore.  
  
 Nell'esempio di base seguente inseriti alcuni <xref:System.Int32> valori da un <xref:System.Threading.Tasks.Dataflow.BatchBlock%601> oggetto contenente dieci elementi in un batch. Per garantire che tutti i valori vengano propagati fuori il <xref:System.Threading.Tasks.Dataflow.BatchBlock%601>, questo esempio viene chiamato il <xref:System.Threading.Tasks.Dataflow.IDataflowBlock.Complete%2A> metodo. Il <xref:System.Threading.Tasks.Dataflow.IDataflowBlock.Complete%2A> metodo imposta la <xref:System.Threading.Tasks.Dataflow.BatchBlock%601> oggetto allo stato completato e di conseguenza, il <xref:System.Threading.Tasks.Dataflow.BatchBlock%601> oggetto propaga tutti gli elementi rimanenti come batch finale.  
  
 [!code-csharp[TPLDataflow_Overview#7](../../../samples/snippets/csharp/VS_Snippets_Misc/tpldataflow_overview/cs/program.cs#7)]
 [!code-vb[TPLDataflow_Overview#7](../../../samples/snippets/visualbasic/VS_Snippets_Misc/tpldataflow_overview/vb/program.vb#7)]  
  
 Per un esempio completo che utilizza <xref:System.Threading.Tasks.Dataflow.BatchBlock%601> per migliorare l'efficienza delle operazioni di inserimento del database, vedere [procedura dettagliata: uso di BatchBlock e BatchedJoinBlock per migliorare l'efficienza](../../../docs/standard/parallel-programming/walkthrough-using-batchblock-and-batchedjoinblock-to-improve-efficiency.md).  
  
#### <a name="joinblockt1-t2-"></a>JoinBlock(T1, T2, ...)  
 Il <xref:System.Threading.Tasks.Dataflow.JoinBlock%602> e <xref:System.Threading.Tasks.Dataflow.JoinBlock%603> classi di raccolta di elementi di input e propagati all'esterno <xref:System.Tuple%602?displayProperty=fullName> o <xref:System.Tuple%603?displayProperty=fullName> gli oggetti che contengono tali elementi.\</T1, T2, T3> \</T1, T2> \</T1, T2, T3> \</T1, T2> Il <xref:System.Threading.Tasks.Dataflow.JoinBlock%602> e <xref:System.Threading.Tasks.Dataflow.JoinBlock%603> classi ereditano da <xref:System.Threading.Tasks.Dataflow.ITargetBlock%601>.</T1, T2, T3> </T1, T2> Forniscono invece proprietà, <xref:System.Threading.Tasks.Dataflow.JoinBlock%602.Target1%2A>, <xref:System.Threading.Tasks.Dataflow.JoinBlock%602.Target2%2A>, e <xref:System.Threading.Tasks.Dataflow.JoinBlock%603.Target3%2A>, che implementano <xref:System.Threading.Tasks.Dataflow.ITargetBlock%601>.  
  
 Ad esempio <xref:System.Threading.Tasks.Dataflow.BatchBlock%601>, <xref:System.Threading.Tasks.Dataflow.JoinBlock%602> e <xref:System.Threading.Tasks.Dataflow.JoinBlock%603> operare in modalità greedy o non greedy.</T1, T2, T3> </T1, T2> In modalità greedy, ovvero l'impostazione predefinita, un <xref:System.Threading.Tasks.Dataflow.JoinBlock%602> o <xref:System.Threading.Tasks.Dataflow.JoinBlock%603> oggetto accetta ogni messaggio che viene offerto e propaga all'esterno una tupla dopo ciascuna delle relative destinazioni viene ricevuto almeno un messaggio.</T1, T2, T3> </T1, T2> In modalità non greedy, un <xref:System.Threading.Tasks.Dataflow.JoinBlock%602> o <xref:System.Threading.Tasks.Dataflow.JoinBlock%603> oggetto vengono posticipati tutti i messaggi in ingresso finché non sono stati offerti i dati necessari per creare una tupla a tutte le destinazioni.\</T1, T2, T3> \</T1, T2> A questo punto, nel blocco viene utilizzato un protocollo di commit a due fasi per recuperare atomicamente tutti gli elementi richiesti dalle origini. Questo rinvio consente a un'altra entità di utilizzare i dati nel frattempo per permettere al sistema complessivo di avanzare.  
  
 Nell'esempio di base seguente viene illustrato un caso in cui un <xref:System.Threading.Tasks.Dataflow.JoinBlock%603> oggetto richiede più dati per calcolare un valore.</T1, T2, T3> Questo esempio viene creato un <xref:System.Threading.Tasks.Dataflow.JoinBlock%603> oggetto che richiede due <xref:System.Int32> valori e un <xref:System.Char> valore per eseguire un'operazione aritmetica.\</T1, T2, T3>  
  
 [!code-csharp[TPLDataflow_Overview#8](../../../samples/snippets/csharp/VS_Snippets_Misc/tpldataflow_overview/cs/program.cs#8)]
 [!code-vb[TPLDataflow_Overview#8](../../../samples/snippets/visualbasic/VS_Snippets_Misc/tpldataflow_overview/vb/program.vb#8)]  
  
 Per un esempio completo che utilizza <xref:System.Threading.Tasks.Dataflow.JoinBlock%602> degli oggetti in modalità non greedy per condividere in modo cooperativo una risorsa, vedere [procedura: usare JoinBlock per leggere dati da più origini](../../../docs/standard/parallel-programming/how-to-use-joinblock-to-read-data-from-multiple-sources.md).\</T1, T2>  
  
#### <a name="batchedjoinblockt1-t2-"></a>BatchedJoinBlock(T1, T2, ...)  
 Il <xref:System.Threading.Tasks.Dataflow.BatchedJoinBlock%602> e <xref:System.Threading.Tasks.Dataflow.BatchedJoinBlock%603> classi raccolti batch di elementi di input e propagati all'esterno `System.Tuple(IList(T1), IList(T2))` o `System.Tuple(IList(T1), IList(T2), IList(T3))` gli oggetti che contengono tali elementi.\</T1, T2, T3> \</T1, T2> Si tratta di <xref:System.Threading.Tasks.Dataflow.BatchedJoinBlock%602> come una combinazione di <xref:System.Threading.Tasks.Dataflow.BatchBlock%601> e <xref:System.Threading.Tasks.Dataflow.JoinBlock%602>.</T1, T2> </T1, T2> Specificare le dimensioni di ciascun batch quando si crea un <xref:System.Threading.Tasks.Dataflow.BatchedJoinBlock%602> oggetto.\</T1, T2> <xref:System.Threading.Tasks.Dataflow.BatchedJoinBlock%602> fornisce inoltre le proprietà, <xref:System.Threading.Tasks.Dataflow.BatchedJoinBlock%602.Target1%2A> e <xref:System.Threading.Tasks.Dataflow.BatchedJoinBlock%602.Target2%2A>, che implementano <xref:System.Threading.Tasks.Dataflow.ITargetBlock%601>.\</T1, T2> Quando il numero specificato di elementi di input viene ricevuto attraverso tutte le destinazioni, il <xref:System.Threading.Tasks.Dataflow.BatchedJoinBlock%602> oggetto propaga in modo asincrono un `System.Tuple(IList(T1), IList(T2))` oggetto che contiene gli elementi.\</T1, T2>  
  
 Nell'esempio di base seguente viene creato un <xref:System.Threading.Tasks.Dataflow.BatchedJoinBlock%602> oggetto contenente i risultati, <xref:System.Int32> valori e gli errori di <xref:System.Exception> oggetti.</T1, T2> In questo esempio vengono eseguite più operazioni e vengono scritti i risultati di <xref:System.Threading.Tasks.Dataflow.BatchedJoinBlock%602.Target1%2A> , proprietà ed errori per il <xref:System.Threading.Tasks.Dataflow.BatchedJoinBlock%602.Target2%2A> proprietà, del <xref:System.Threading.Tasks.Dataflow.BatchedJoinBlock%602> oggetto.\</T1, T2> Poiché il conteggio delle operazioni riuscite e non è noto in anticipo, il <xref:System.Collections.Generic.IList%601> oggetti consentono di ogni destinazione di ricevere zero o più valori.  
  
 [!code-csharp[TPLDataflow_Overview#9](../../../samples/snippets/csharp/VS_Snippets_Misc/tpldataflow_overview/cs/program.cs#9)]
 [!code-vb[TPLDataflow_Overview#9](../../../samples/snippets/visualbasic/VS_Snippets_Misc/tpldataflow_overview/vb/program.vb#9)]  
  
 Per un esempio completo che utilizza <xref:System.Threading.Tasks.Dataflow.BatchedJoinBlock%602> per acquisire i risultati e tutte le eccezioni che si verificano durante il programma legge da un database, vedere [procedura dettagliata: uso di BatchBlock e BatchedJoinBlock per migliorare l'efficienza](../../../docs/standard/parallel-programming/walkthrough-using-batchblock-and-batchedjoinblock-to-improve-efficiency.md).\</T1, T2>  
  
 [[go to top](#top)]  
  
<a name="behavior"></a>   
## <a name="configuring-dataflow--block-behavior"></a>Configurazione del comportamento dei blocchi di flussi di dati  
 È possibile abilitare opzioni aggiuntive fornendo un <xref:System.Threading.Tasks.Dataflow.DataflowBlockOptions?displayProperty=fullName> oggetto al costruttore di tipi di blocchi di flussi di dati. Tramite queste opzioni viene controllato il comportamento dell'utilità di pianificazione mediante la quale vengono gestiti l'attività sottostante e il grado di parallelismo. Il <xref:System.Threading.Tasks.Dataflow.DataflowBlockOptions> dispone inoltre di tipi che specificano il comportamento specifico di determinati tipi di blocchi di flussi di dati derivati. Nella tabella seguente viene riepilogato il tipo di opzioni associato a ogni tipo di blocco di flussi di dati.  
  
|Tipo di blocco di flussi di dati|<xref:System.Threading.Tasks.Dataflow.DataflowBlockOptions> tipo|  
|-------------------------|------------------------------------------------------------------------------------------------------------------------------------------------------------------------|  
|<xref:System.Threading.Tasks.Dataflow.BufferBlock%601>|<xref:System.Threading.Tasks.Dataflow.DataflowBlockOptions>|  
|<xref:System.Threading.Tasks.Dataflow.BroadcastBlock%601>|<xref:System.Threading.Tasks.Dataflow.DataflowBlockOptions>|  
|<xref:System.Threading.Tasks.Dataflow.WriteOnceBlock%601>|<xref:System.Threading.Tasks.Dataflow.DataflowBlockOptions>|  
|<xref:System.Threading.Tasks.Dataflow.ActionBlock%601>|<xref:System.Threading.Tasks.Dataflow.ExecutionDataflowBlockOptions>|  
|<xref:System.Threading.Tasks.Dataflow.TransformBlock%602>\</TInput, TOutput>|<xref:System.Threading.Tasks.Dataflow.ExecutionDataflowBlockOptions>|  
|<xref:System.Threading.Tasks.Dataflow.TransformManyBlock%602>\</TInput, TOutput>|<xref:System.Threading.Tasks.Dataflow.ExecutionDataflowBlockOptions>|  
|<xref:System.Threading.Tasks.Dataflow.BatchBlock%601>|<xref:System.Threading.Tasks.Dataflow.GroupingDataflowBlockOptions>|  
|<xref:System.Threading.Tasks.Dataflow.JoinBlock%602>\</T1, T2>|<xref:System.Threading.Tasks.Dataflow.GroupingDataflowBlockOptions>|  
|<xref:System.Threading.Tasks.Dataflow.BatchedJoinBlock%602>\</T1, T2>|<xref:System.Threading.Tasks.Dataflow.GroupingDataflowBlockOptions>|  
  
 Le sezioni seguenti forniscono ulteriori informazioni sui tipi di flussi di dati importanti opzioni per il blocco che sono disponibili tramite il <xref:System.Threading.Tasks.Dataflow.DataflowBlockOptions?displayProperty=fullName>, <xref:System.Threading.Tasks.Dataflow.ExecutionDataflowBlockOptions?displayProperty=fullName>, e <xref:System.Threading.Tasks.Dataflow.GroupingDataflowBlockOptions?displayProperty=fullName> classi.  
  
### <a name="specifying-the-task-scheduler"></a>Specifica dell'Utilità di pianificazione  
 In ogni blocco di flussi di dati predefinito viene utilizzato il meccanismo di pianificazione delle attività TPL per eseguire attività quali la propagazione dei dati in una destinazione, la ricezione dei dati da un'origine e l'esecuzione di delegati definiti dall'utente quando i dati diventano disponibili. <xref:System.Threading.Tasks.TaskScheduler> è una classe astratta che rappresenta un'utilità di pianificazione che accoda attività nei thread. Utilità di pianificazione predefinita, <xref:System.Threading.Tasks.TaskScheduler.Default%2A>, utilizza il <xref:System.Threading.ThreadPool> classe per accodare ed eseguire il lavoro. È possibile eseguire l'override di utilità di pianificazione predefinita impostando la <xref:System.Threading.Tasks.Dataflow.DataflowBlockOptions.TaskScheduler%2A> proprietà quando si costruisce un oggetto di blocco di flussi di dati.  
  
 Quando tramite la stessa Utilità di pianificazione vengono gestiti più blocchi di flussi di dati, è possibile applicarvi dei criteri. Ad esempio, se più blocchi di flussi di dati sono configurati ognuno per utilizzare l'utilità di pianificazione esclusivo dello stesso <xref:System.Threading.Tasks.ConcurrentExclusiveSchedulerPair> dell'oggetto, tutto il lavoro eseguito tramite questi blocchi viene serializzato. Analogamente, se questi blocchi sono configurati per utilizzare l'utilità di pianificazione simultanee dello stesso <xref:System.Threading.Tasks.ConcurrentExclusiveSchedulerPair> oggetto e l'utilità di pianificazione è configurata per disporre di un livello massimo di concorrenza, tutto il lavoro di questi blocchi è limitato a quel numero di operazioni simultanee. Per un esempio che utilizza il <xref:System.Threading.Tasks.ConcurrentExclusiveSchedulerPair> classe per consentire operazioni di lettura si verificano in parallelo, ma vengono eseguite separatamente da tutte le altre operazioni, vedere le operazioni di scrittura [procedura: specificare un'utilità di pianificazione in un Dataflow Block](../../../docs/standard/parallel-programming/how-to-specify-a-task-scheduler-in-a-dataflow-block.md). Per ulteriori informazioni sulle utilità di pianificazione in TPL, vedere il <xref:System.Threading.Tasks.TaskScheduler> argomento relativo alla classe.  
  
### <a name="specifying-the-degree-of-parallelism"></a>Specifica del grado di parallelismo  
 Per impostazione predefinita, i tipi di blocchi di tre esecuzione forniti dalla libreria del flusso di dati TPL, <xref:System.Threading.Tasks.Dataflow.ActionBlock%601>, <xref:System.Threading.Tasks.Dataflow.TransformBlock%602>, e <xref:System.Threading.Tasks.Dataflow.TransformManyBlock%602>, elaborare un messaggio alla volta.\</TInput, TOutput> \</TInput, TOutput> Tramite questi tipi di blocchi di flussi di dati i messaggi vengono inoltre elaborati nell'ordine in cui vengono ricevuti. Per abilitare questi blocchi di flussi di dati elaborare i messaggi contemporaneamente, impostare il <xref:System.Threading.Tasks.Dataflow.ExecutionDataflowBlockOptions.MaxDegreeOfParallelism%2A?displayProperty=fullName> proprietà quando si crea l'oggetto di blocco di flussi di dati.  
  
 Il valore predefinito di <xref:System.Threading.Tasks.Dataflow.ExecutionDataflowBlockOptions.MaxDegreeOfParallelism%2A> è 1, che garantisce che il blocco di flussi elabora uno messaggio alla volta. Impostando questa proprietà su un valore maggiore di 1 possono essere elaborati più messaggi contemporaneamente da parte del blocco di flussi di dati. Impostando questa proprietà su <xref:System.Threading.Tasks.Dataflow.DataflowBlockOptions.Unbounded?displayProperty=fullName> consente l'utilità di pianificazione sottostante gestire il massimo livello di concorrenza.  
  
> [!IMPORTANT]
>  Quando si specifica un grado massimo di parallelismo maggiore di 1, vengono elaborati contemporaneamente più messaggi, pertanto questi ultimi potrebbero non essere elaborati nell'ordine in cui vengono ricevuti. L'ordine in cui i messaggi vengono restituiti dal blocco sarà, tuttavia, correttamente ordinato.  
  
 Poiché il <xref:System.Threading.Tasks.Dataflow.ExecutionDataflowBlockOptions.MaxDegreeOfParallelism%2A> proprietà rappresenta il grado massimo di parallelismo, il blocco di flussi di dati può essere eseguito con un minore grado di parallelismo maggiore di quello specificato. È possibile che nel blocco di flussi di dati venga utilizzato un grado di parallelismo minore per soddisfare i requisiti funzionali o perché vi è una mancanza di risorse di sistema disponibili. Da parte di un blocco di flussi di dati non viene mai scelto un parallelismo maggiore di quello specificato.  
  
 Il valore di <xref:System.Threading.Tasks.Dataflow.ExecutionDataflowBlockOptions.MaxDegreeOfParallelism%2A> è esclusivo per ogni oggetto di blocco di flussi di dati. Ad esempio, se da ognuno dei quattro oggetti del blocco di flussi di dati viene specificato 1 come massimo grado di parallelismo, tutti e quattro gli oggetti del blocco di flussi di dati possono essere potenzialmente eseguiti in parallelo.  
  
 Per un esempio che imposta il grado massimo di parallelismo per consentire l'esecuzione in parallelo di operazioni lunghe, vedere [procedura: specificare il grado di parallelismo in un Dataflow Block](../../../docs/standard/parallel-programming/how-to-specify-the-degree-of-parallelism-in-a-dataflow-block.md).  
  
### <a name="specifying-the-number-of-messages-per-task"></a>Specifica del numero di messaggi per attività  
 Nei tipi di blocchi di flussi di dati predefiniti vengono utilizzate attività per elaborare più elementi di input. In questo modo è possibile ridurre il numero di oggetti di attività necessari per elaborare i dati, consentendo alle applicazioni un'esecuzione più efficiente. Tuttavia, quando tramite le attività di un set di blocchi di flussi di dati vengono elaborati i dati, è possibile che le attività di altri blocchi di flussi di dati debbano attendere il tempo di elaborazione inserendo in coda i messaggi. Per abilitare la migliore equità tra attività del flusso di dati, impostare il <xref:System.Threading.Tasks.Dataflow.DataflowBlockOptions.MaxMessagesPerTask%2A> proprietà. Quando <xref:System.Threading.Tasks.Dataflow.DataflowBlockOptions.MaxMessagesPerTask%2A> è impostato su <xref:System.Threading.Tasks.Dataflow.DataflowBlockOptions.Unbounded?displayProperty=fullName>, ossia l'impostazione predefinita, l'attività utilizzata da un blocco di flussi di dati vengono elaborati tutti i messaggi che sono disponibili. Quando <xref:System.Threading.Tasks.Dataflow.DataflowBlockOptions.MaxMessagesPerTask%2A> è impostata su un valore diverso da <xref:System.Threading.Tasks.Dataflow.DataflowBlockOptions.Unbounded>, il blocco di flussi elaborato al massimo questo numero di messaggi per <xref:System.Threading.Tasks.Task> oggetto. Sebbene l'impostazione di <xref:System.Threading.Tasks.Dataflow.DataflowBlockOptions.MaxMessagesPerTask%2A> proprietà può aumentare l'equità tra le attività, può causare la generazione di più attività rispetto al necessario, il sistema che può ridurre le prestazioni.  
  
### <a name="enabling-cancellation"></a>Abilitazione dell'annullamento  
 TPL fornisce un meccanismo che consente alle attività di coordinare l'annullamento in modo cooperativo. Per abilitare i blocchi di flussi di dati di far parte di questo meccanismo di annullamento, impostare il <xref:System.Threading.Tasks.Dataflow.DataflowBlockOptions.CancellationToken%2A> proprietà. Quando questo <xref:System.Threading.CancellationToken> oggetto viene impostato sullo stato annullato, tutti i blocchi di flussi di dati che controllano questo token viene terminata l'esecuzione dell'elemento corrente ma non viene avviata l'elaborazione degli elementi successivi. Tramite questi blocchi di flussi di dati vengono inoltre cancellati tutti i messaggi memorizzati nel buffer, vengono rilasciate le connessioni a tutti i blocchi di origine e di destinazione e viene eseguita la transizione allo stato di annullamento. Con la transizione allo stato annullato, il <xref:System.Threading.Tasks.Dataflow.IDataflowBlock.Completion%2A> proprietà ha il <xref:System.Threading.Tasks.Task.Status%2A> impostata su <xref:System.Threading.Tasks.TaskStatus>, a meno che non si è verificata un'eccezione durante l'elaborazione. In tal caso, <xref:System.Threading.Tasks.Task.Status%2A> è impostato su <xref:System.Threading.Tasks.TaskStatus>.  
  
 Per un esempio che illustra come utilizzare l'annullamento in un'applicazione Windows Form, vedere [procedura: annullare un Dataflow Block](../../../docs/standard/parallel-programming/how-to-cancel-a-dataflow-block.md). Per ulteriori informazioni sull'annullamento in TPL, vedere [annullamento delle attività](../../../docs/standard/parallel-programming/task-cancellation.md).  
  
### <a name="specifying-greedy-versus-non-greedy-behavior"></a>Specifica del comportamento greedy e non greedy a confronto  
 Diversi tipi di blocchi di raggruppamento del flusso di dati possono essere eseguiti in modalità *greedy* o *non-greedy* modalità. Per impostazione predefinita, i tipi di blocchi di flussi di dati predefiniti vengono eseguiti in modalità greedy.  
  
 Per il join, ad esempio i tipi di blocchi <xref:System.Threading.Tasks.Dataflow.JoinBlock%602>, la modalità greedy indica che il blocco accetta immediatamente i dati anche se i dati corrispondenti con cui si desidera creare un join non sono ancora disponibili.</T1, T2> La modalità non greedy indica che nel blocco vengono posticipati tutti i messaggi in ingresso finché non ne è disponibile uno per ciascuna delle relative destinazioni per completare il join. Se uno dei messaggi posposti non è più disponibile, tramite il blocco join vengono rilasciati tutti i messaggi posposti e viene riavviato il processo. Per il <xref:System.Threading.Tasks.Dataflow.BatchBlock%601> classe greedy e non-greedy comportamento è simile, con la differenza che in modalità non greedy, un <xref:System.Threading.Tasks.Dataflow.BatchBlock%601> oggetto vengono posticipati tutti i messaggi in ingresso finché non è un numero sufficiente disponibili da origini diverse per completare un batch.  
  
 Per specificare la modalità non greedy per un blocco di flussi di dati, impostare <xref:System.Threading.Tasks.Dataflow.GroupingDataflowBlockOptions.Greedy%2A> a `False`. Per un esempio che illustra come utilizzare la modalità non greedy per consentire a più blocchi join di condividere in modo più efficiente un'origine dati, vedere [procedura: utilizzare JoinBlock per leggere dati da più origini](../../../docs/standard/parallel-programming/how-to-use-joinblock-to-read-data-from-multiple-sources.md).  
  
 [[go to top](#top)]  
  
<a name="custom"></a>   
## <a name="custom-dataflow-blocks"></a>Blocchi di flussi di dati personalizzati  
 Anche se la libreria del flusso di dati TPL fornisce molti tipi di blocchi predefiniti, è possibile crearne degli altri tramite cui eseguire comportamenti personalizzati. Implementare il <xref:System.Threading.Tasks.Dataflow.ISourceBlock%601> o <xref:System.Threading.Tasks.Dataflow.ITargetBlock%601> interfacce direttamente o utilizzare il <xref:System.Threading.Tasks.Dataflow.DataflowBlock.Encapsulate%2A> metodo per compilare un blocco complesso che incapsula il comportamento dei tipi di blocchi esistenti.\</TInput, TOutput> Per esempi che illustrano come implementare la funzionalità di blocco di flussi di dati personalizzati, vedere [procedura dettagliata: creazione di un tipo di blocco di flussi di dati personalizzato](../../../docs/standard/parallel-programming/walkthrough-creating-a-custom-dataflow-block-type.md).  
  
 [[go to top](#top)]  
  
## <a name="related-topics"></a>Argomenti correlati  
  
|Titolo|Descrizione|  
|-----------|-----------------|  
|[Procedura: scrivere e leggere messaggi da un blocco di flussi](../../../docs/standard/parallel-programming/how-to-write-messages-to-and-read-messages-from-a-dataflow-block.md)|Viene illustrato come scrivere e leggere messaggi da un <xref:System.Threading.Tasks.Dataflow.BufferBlock%601> oggetto.|  
|[Procedura: implementare un modello di flusso di dati Producer-Consumer](../../../docs/standard/parallel-programming/how-to-implement-a-producer-consumer-dataflow-pattern.md)|Viene descritto come utilizzare il modello di flusso di dati per implementare uno schema producer-consumer, in cui il producer invia messaggi a un blocco di flussi di dati e il consumer legge i messaggi dal blocco in questione.|  
|[Procedura: eseguire l'azione alla ricezione di un blocco di flussi di dati](../../../docs/standard/parallel-programming/how-to-perform-action-when-a-dataflow-block-receives-data.md)|Viene descritto come fornire delegati ai tipi di blocchi di esecuzione del flusso di dati, <xref:System.Threading.Tasks.Dataflow.ActionBlock%601>, <xref:System.Threading.Tasks.Dataflow.TransformBlock%602>, e <xref:System.Threading.Tasks.Dataflow.TransformManyBlock%602>.\</TInput, TOutput> \</TInput, TOutput>|  
|[Procedura dettagliata: Creazione di una Pipeline di dati](../../../docs/standard/parallel-programming/walkthrough-creating-a-dataflow-pipeline.md)|Viene descritto come creare una pipeline di flusso di dati tramite cui viene scaricato un testo dal Web e vengono eseguite operazioni su questo testo.|  
|[Procedura: scollegare i blocchi di flussi di dati](../../../docs/standard/parallel-programming/how-to-unlink-dataflow-blocks.md)|Viene illustrato come utilizzare il <xref:System.Threading.Tasks.Dataflow.ISourceBlock%601.LinkTo%2A> metodo per scollegare un blocco di destinazione dalla relativa origine dopo che l'offerta di un messaggio alla destinazione.|  
|[Procedura dettagliata: Utilizzo del flusso di dati in un'applicazione Windows Form](../../../docs/standard/parallel-programming/walkthrough-using-dataflow-in-a-windows-forms-application.md)|Viene illustrato come creare una rete di blocchi di flussi di dati tramite cui viene eseguita l'elaborazione di immagini in un'applicazione Windows Form.|  
|[Procedura: annullare un blocco di flussi di dati](../../../docs/standard/parallel-programming/how-to-cancel-a-dataflow-block.md)|Viene illustrato come utilizzare l'annullamento in un'applicazione Windows Form.|  
|[Procedura: utilizzare JoinBlock per leggere dati da più origini](../../../docs/standard/parallel-programming/how-to-use-joinblock-to-read-data-from-multiple-sources.md)|Viene illustrato come utilizzare il <xref:System.Threading.Tasks.Dataflow.JoinBlock%602> per eseguire un'operazione quando sono disponibili dati da più origini e come utilizzare la modalità non greedy per consentire a più blocchi join di condividere un'origine dati in modo più efficiente.\</T1, T2>|  
|[Procedura: specificare il grado di parallelismo in un blocco di flussi di dati](../../../docs/standard/parallel-programming/how-to-specify-the-degree-of-parallelism-in-a-dataflow-block.md)|Viene descritto come impostare il <xref:System.Threading.Tasks.Dataflow.ExecutionDataflowBlockOptions.MaxDegreeOfParallelism%2A> proprietà per abilitare un blocco di flussi di dati di esecuzione elaborare più messaggi contemporaneamente.|  
|[Procedura: specificare un'utilità di pianificazione in un blocco di flussi di dati](../../../docs/standard/parallel-programming/how-to-specify-a-task-scheduler-in-a-dataflow-block.md)|Viene illustrato come associare una specifica Utilità di pianificazione quando si utilizza il flusso di dati nell'applicazione.|  
|[Procedura dettagliata: Utilizzo di BatchBlock e BatchedJoinBlock per migliorare l'efficienza](../../../docs/standard/parallel-programming/walkthrough-using-batchblock-and-batchedjoinblock-to-improve-efficiency.md)|Viene descritto come utilizzare il <xref:System.Threading.Tasks.Dataflow.BatchBlock%601> classe per migliorare l'efficienza del database inserire operazioni e come utilizzare il <xref:System.Threading.Tasks.Dataflow.BatchedJoinBlock%602> (classe) per acquisire i risultati e tutte le eccezioni che si verificano durante il programma legge da un database.\</T1, T2>|  
|[Procedura dettagliata: Creazione di un tipo di blocco di flussi di dati personalizzati](../../../docs/standard/parallel-programming/walkthrough-creating-a-custom-dataflow-block-type.md)|Vengono illustrati due modi per creare un tipo di blocco di flussi di dati tramite cui viene implementato il comportamento personalizzato.|  
|[Task Parallel Library (TPL)](../../../docs/standard/parallel-programming/task-parallel-library-tpl.md)|Viene introdotta TPL, una libreria tramite cui viene semplificata la programmazione parallela e concorrente nelle applicazioni [!INCLUDE[dnprdnshort](../../../includes/dnprdnshort-md.md)].|