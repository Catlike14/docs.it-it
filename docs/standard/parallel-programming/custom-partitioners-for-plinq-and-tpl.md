---
title: Partitioner personalizzati per PLINQ e TPL
ms.custom: 
ms.date: 03/30/2017
ms.prod: .net
ms.reviewer: 
ms.suite: 
ms.technology: dotnet-standard
ms.tgt_pltfrm: 
ms.topic: article
dev_langs:
- csharp
- vb
helpviewer_keywords: tasks, partitioners
ms.assetid: 96153688-9a01-47c4-8430-909cee9a2887
caps.latest.revision: "19"
author: rpetrusha
ms.author: ronpet
manager: wpickett
ms.openlocfilehash: 12d234b86b0067178d54d2fdcb5d37ceaee6109d
ms.sourcegitcommit: 4f3fef493080a43e70e951223894768d36ce430a
ms.translationtype: HT
ms.contentlocale: it-IT
ms.lasthandoff: 11/21/2017
---
# <a name="custom-partitioners-for-plinq-and-tpl"></a><span data-ttu-id="3791b-102">Partitioner personalizzati per PLINQ e TPL</span><span class="sxs-lookup"><span data-stu-id="3791b-102">Custom Partitioners for PLINQ and TPL</span></span>
<span data-ttu-id="3791b-103">Per parallelizzare un'operazione su un'origine dati, è uno dei passaggi essenziali per *partizione* l'origine in più sezioni a cui è possibile accedere contemporaneamente da più thread.</span><span class="sxs-lookup"><span data-stu-id="3791b-103">To parallelize an operation on a data source, one of the essential steps is to *partition* the source into multiple sections that can be accessed concurrently by multiple threads.</span></span> <span data-ttu-id="3791b-104">PLINQ e Task Parallel Library (TPL) forniscono partitioner predefiniti che funzionano in modo trasparente quando si scrive una query parallela o <xref:System.Threading.Tasks.Parallel.ForEach%2A> ciclo.</span><span class="sxs-lookup"><span data-stu-id="3791b-104">PLINQ and the Task Parallel Library (TPL) provide default partitioners that work transparently when you write a parallel query or <xref:System.Threading.Tasks.Parallel.ForEach%2A> loop.</span></span> <span data-ttu-id="3791b-105">Per scenari più avanzati, è possibile collegare il proprio partitioner.</span><span class="sxs-lookup"><span data-stu-id="3791b-105">For more advanced scenarios, you can plug in your own partitioner.</span></span>  
  
## <a name="kinds-of-partitioning"></a><span data-ttu-id="3791b-106">Tipi di partizionamento</span><span class="sxs-lookup"><span data-stu-id="3791b-106">Kinds of Partitioning</span></span>  
 <span data-ttu-id="3791b-107">Esistono diversi modi per suddividere un'origine dati.</span><span class="sxs-lookup"><span data-stu-id="3791b-107">There are many ways to partition a data source.</span></span> <span data-ttu-id="3791b-108">Negli approcci più efficienti, più thread cooperano ai fini della sequenza di origine originale invece di separazione fisica di origine in più sottosequenze.</span><span class="sxs-lookup"><span data-stu-id="3791b-108">In the most efficient approaches, multiple threads cooperate to process the original source sequence, rather than physically separating the source into multiple subsequences.</span></span> <span data-ttu-id="3791b-109">Per le matrici e altri indicizzata origini, ad esempio <xref:System.Collections.IList> raccolte in cui la lunghezza è nota in anticipo, *il partizionamento per intervalli* è il tipo più semplice di partizionamento.</span><span class="sxs-lookup"><span data-stu-id="3791b-109">For arrays and other indexed sources such as <xref:System.Collections.IList> collections where the length is known in advance, *range partitioning* is the simplest kind of partitioning.</span></span> <span data-ttu-id="3791b-110">Ogni thread riceve univoco indici iniziali e finali, in modo che sia possibile elaborare l'intervallo di origine senza sovrascrivere o vengano sovrascritti dagli altri thread.</span><span class="sxs-lookup"><span data-stu-id="3791b-110">Every thread receives unique beginning and ending indexes, so that it can process its range of the source without overwriting or being overwritten by any other thread.</span></span> <span data-ttu-id="3791b-111">L'unico overhead necessario per eseguire il partizionamento per intervalli è il lavoro iniziale di creazione degli intervalli; Nessun ulteriore sincronizzazione è necessario in seguito.</span><span class="sxs-lookup"><span data-stu-id="3791b-111">The only overhead involved in range partitioning is the initial work of creating the ranges; no additional synchronization is required after that.</span></span> <span data-ttu-id="3791b-112">Pertanto, può fornire buone prestazioni, purché il carico di lavoro viene suddiviso equamente.</span><span class="sxs-lookup"><span data-stu-id="3791b-112">Therefore, it can provide good performance as long as the workload is divided evenly.</span></span> <span data-ttu-id="3791b-113">Uno svantaggio del partizionamento per intervalli è che se un thread termina prima del previsto, in grado di altri thread terminato il lavoro.</span><span class="sxs-lookup"><span data-stu-id="3791b-113">A disadvantage of range partitioning is that if one thread finishes early, it cannot help the other threads finish their work.</span></span>  
  
 <span data-ttu-id="3791b-114">Per gli elenchi collegati o altri insiemi la cui lunghezza non è noto, è possibile utilizzare *il partizionamento*.</span><span class="sxs-lookup"><span data-stu-id="3791b-114">For linked lists or other collections whose length is not known, you can use *chunk partitioning*.</span></span> <span data-ttu-id="3791b-115">Nel partizionamento, ogni thread o attività in un ciclo parallelo o la query utilizza un determinato numero di elementi di origine in un blocco, li elabora e quindi torna a recuperare altri elementi.</span><span class="sxs-lookup"><span data-stu-id="3791b-115">In chunk partitioning, every thread or task in a parallel loop or query consumes some number of source elements in one chunk, processes them, and then comes back to retrieve additional elements.</span></span> <span data-ttu-id="3791b-116">Il partitioner garantisce che tutti gli elementi vengono distribuiti e che non siano presenti duplicati.</span><span class="sxs-lookup"><span data-stu-id="3791b-116">The partitioner ensures that all elements are distributed and that there are no duplicates.</span></span> <span data-ttu-id="3791b-117">Un blocco può essere di qualsiasi dimensione.</span><span class="sxs-lookup"><span data-stu-id="3791b-117">A chunk may be any size.</span></span> <span data-ttu-id="3791b-118">Ad esempio, l'elemento partitioner viene dimostrato in [come: partizioni dinamiche implementano](../../../docs/standard/parallel-programming/how-to-implement-dynamic-partitions.md) creazione di blocchi che contengono un solo elemento.</span><span class="sxs-lookup"><span data-stu-id="3791b-118">For example, the partitioner that is demonstrated in [How to: Implement Dynamic Partitions](../../../docs/standard/parallel-programming/how-to-implement-dynamic-partitions.md) creates chunks that contain just one element.</span></span> <span data-ttu-id="3791b-119">Finché i blocchi non sono troppo grandi, questo tipo di partizionamento è progettato per il bilanciamento del carico perché l'assegnazione di elementi per i thread non è predeterminato.</span><span class="sxs-lookup"><span data-stu-id="3791b-119">As long as the chunks are not too large, this kind of partitioning is inherently load-balancing because the assignment of elements to threads is not pre-determined.</span></span> <span data-ttu-id="3791b-120">Tuttavia, l'elemento partitioner, tuttavia, il sovraccarico della sincronizzazione ogni volta che il thread per ottenere un altro blocco.</span><span class="sxs-lookup"><span data-stu-id="3791b-120">However, the partitioner does incur the synchronization overhead each time the thread needs to get another chunk.</span></span> <span data-ttu-id="3791b-121">La quantità di sincronizzazione in questi casi è inversamente proporzionale alla dimensione dei blocchi.</span><span class="sxs-lookup"><span data-stu-id="3791b-121">The amount of synchronization incurred in these cases is inversely proportional to the size of the chunks.</span></span>  
  
 <span data-ttu-id="3791b-122">In generale, il partizionamento per intervalli è più veloce quando il tempo di esecuzione del delegato è ridotto a moderato e l'origine contiene un numero elevato di elementi e il lavoro totale di ogni partizione è quasi equivalente.</span><span class="sxs-lookup"><span data-stu-id="3791b-122">In general, range partitioning is only faster when the execution time of the delegate is small to moderate, and the source has a large number of elements, and the total work of each partition is roughly equivalent.</span></span> <span data-ttu-id="3791b-123">Il partizionamento è pertanto in genere più veloce nella maggior parte dei casi.</span><span class="sxs-lookup"><span data-stu-id="3791b-123">Chunk partitioning is therefore generally faster in most cases.</span></span> <span data-ttu-id="3791b-124">Origini con un numero limitato di elementi o tempi di esecuzione per il delegato, quindi le prestazioni di blocco e il partizionamento per intervalli riguarda uguale.</span><span class="sxs-lookup"><span data-stu-id="3791b-124">On sources with a small number of elements or longer execution times for the delegate, then the performance of chunk and range partitioning is about equal.</span></span>  
  
 <span data-ttu-id="3791b-125">I partitioner TPL supportano anche un numero di partizioni dinamico.</span><span class="sxs-lookup"><span data-stu-id="3791b-125">The TPL partitioners also support a dynamic number of partitions.</span></span> <span data-ttu-id="3791b-126">Ciò significa che possono creare partizioni in qualsiasi momento, ad esempio, quando il <xref:System.Threading.Tasks.Parallel.ForEach%2A> ciclo genera una nuova attività.</span><span class="sxs-lookup"><span data-stu-id="3791b-126">This means they can create partitions on-the-fly, for example, when the <xref:System.Threading.Tasks.Parallel.ForEach%2A> loop spawns a new task.</span></span> <span data-ttu-id="3791b-127">Questa funzionalità consente il partitioner scalabilità insieme al ciclo stesso.</span><span class="sxs-lookup"><span data-stu-id="3791b-127">This feature enables the partitioner to scale together with the loop itself.</span></span> <span data-ttu-id="3791b-128">Partitioner dinamico sono anche implicitamente il bilanciamento del carico.</span><span class="sxs-lookup"><span data-stu-id="3791b-128">Dynamic partitioners are also inherently load-balancing.</span></span> <span data-ttu-id="3791b-129">Quando si crea un partitioner personalizzato, è necessario supportare il partizionamento dinamico per essere utilizzabile da un <xref:System.Threading.Tasks.Parallel.ForEach%2A> ciclo.</span><span class="sxs-lookup"><span data-stu-id="3791b-129">When you create a custom partitioner, you must support dynamic partitioning to be consumable from a <xref:System.Threading.Tasks.Parallel.ForEach%2A> loop.</span></span>  
  
### <a name="configuring-load-balancing-partitioners-for-plinq"></a><span data-ttu-id="3791b-130">Configurazione di bilanciamento del carico partitioner per PLINQ</span><span class="sxs-lookup"><span data-stu-id="3791b-130">Configuring Load Balancing Partitioners for PLINQ</span></span>  
 <span data-ttu-id="3791b-131">Alcuni overload di <xref:System.Collections.Concurrent.Partitioner.Create%2A?displayProperty=nameWithType> metodo consentono di creare un partitioner per una matrice o <xref:System.Collections.IList> di origine e specificare se deve tentare di bilanciare il carico di lavoro tra i thread.</span><span class="sxs-lookup"><span data-stu-id="3791b-131">Some overloads of the <xref:System.Collections.Concurrent.Partitioner.Create%2A?displayProperty=nameWithType> method let you create a partitioner for an array or <xref:System.Collections.IList> source and specify whether it should attempt to balance the workload among the threads.</span></span> <span data-ttu-id="3791b-132">Quando il partitioner è configurato per il bilanciamento del carico, il partizionamento viene utilizzato e gli elementi vengono passati a ogni partizione in piccoli blocchi quando vengono richiesti.</span><span class="sxs-lookup"><span data-stu-id="3791b-132">When the partitioner is configured to load-balance, chunk partitioning is used, and the elements are handed off to each partition in small chunks as they are requested.</span></span> <span data-ttu-id="3791b-133">Questo approccio consente di garantire che tutte le partizioni sono presenti elementi da elaborare fino a quando l'intero ciclo o query è stata completata.</span><span class="sxs-lookup"><span data-stu-id="3791b-133">This approach helps ensure that all partitions have elements to process until the entire loop or query is completed.</span></span> <span data-ttu-id="3791b-134">Un overload aggiuntivo utilizzabile per implementare il bilanciamento del carico di partizionamento di qualsiasi <xref:System.Collections.IEnumerable> origine.</span><span class="sxs-lookup"><span data-stu-id="3791b-134">An additional overload can be used to provide load-balancing partitioning of any <xref:System.Collections.IEnumerable> source.</span></span>  
  
 <span data-ttu-id="3791b-135">Il bilanciamento del carico richiede in genere, le partizioni per richiedere elementi relativamente spesso il partitioner.</span><span class="sxs-lookup"><span data-stu-id="3791b-135">In general, load balancing requires the partitions to request elements relatively frequently from the partitioner.</span></span> <span data-ttu-id="3791b-136">Al contrario, un partitioner che esegue il partizionamento statico può assegnare gli elementi a ogni partitioner tutti contemporaneamente utilizzando l'intervallo o il partizionamento.</span><span class="sxs-lookup"><span data-stu-id="3791b-136">By contrast, a partitioner that does static partitioning can assign the elements to each partitioner all at once by using either range or chunk partitioning.</span></span> <span data-ttu-id="3791b-137">Ciò comporta un sovraccarico minore rispetto a bilanciamento del carico, ma potrebbe richiedere più tempo se un thread finisce con molte più attività rispetto alle altre.</span><span class="sxs-lookup"><span data-stu-id="3791b-137">This requires less overhead than load balancing, but it might take longer to execute if one thread ends up with significantly more work than the others.</span></span> <span data-ttu-id="3791b-138">Per impostazione predefinita quando viene passato una IList o una matrice, PLINQ Usa sempre il partizionamento per intervalli senza bilanciamento del carico.</span><span class="sxs-lookup"><span data-stu-id="3791b-138">By default when it is passed an IList or an array, PLINQ always uses range partitioning without load balancing.</span></span> <span data-ttu-id="3791b-139">Per abilitare il bilanciamento del carico per PLINQ, utilizzare il `Partitioner.Create` (metodo), come illustrato nell'esempio seguente.</span><span class="sxs-lookup"><span data-stu-id="3791b-139">To enable load balancing for PLINQ, use the `Partitioner.Create` method, as shown in the following example.</span></span>  
  
 [!code-csharp[TPL_Partitioners#02](../../../samples/snippets/csharp/VS_Snippets_Misc/tpl_partitioners/cs/partitioners.cs#02)]
 [!code-vb[TPL_Partitioners#02](../../../samples/snippets/visualbasic/VS_Snippets_Misc/tpl_partitioners/vb/partitionsnippets_vb.vb#02)]  
  
 <span data-ttu-id="3791b-140">Il modo migliore per determinare se per utilizzare il bilanciamento del carico in qualsiasi scenario specificato è nello sperimentare e misurare il tempo impiegato completamento nelle configurazioni di computer e carichi rappresentativi delle operazioni.</span><span class="sxs-lookup"><span data-stu-id="3791b-140">The best way to determine whether to use load balancing in any given scenario is to experiment and measure how long it takes operations to complete under representative loads and computer configurations.</span></span> <span data-ttu-id="3791b-141">Ad esempio, il partizionamento statico potrebbe fornire un aumento significativo in un computer multicore con solo pochi core, ma potrebbe causare rallentamenti nei computer che dispongono di core relativamente elevato.</span><span class="sxs-lookup"><span data-stu-id="3791b-141">For example, static partitioning might provide significant speedup on a multi-core computer that has only a few cores, but it might result in slowdowns on computers that have relatively many cores.</span></span>  
  
 <span data-ttu-id="3791b-142">La tabella seguente elenca gli overload disponibili del <xref:System.Collections.Concurrent.Partitioner.Create%2A> metodo.</span><span class="sxs-lookup"><span data-stu-id="3791b-142">The following table lists the available overloads of the <xref:System.Collections.Concurrent.Partitioner.Create%2A> method.</span></span> <span data-ttu-id="3791b-143">Questi partitioner non sono limitati a usare solo con PLINQ o <xref:System.Threading.Tasks.Task>.</span><span class="sxs-lookup"><span data-stu-id="3791b-143">These partitioners are not limited to use only with PLINQ or <xref:System.Threading.Tasks.Task>.</span></span> <span data-ttu-id="3791b-144">Possono inoltre essere utilizzati con qualsiasi costrutto parallelo personalizzato.</span><span class="sxs-lookup"><span data-stu-id="3791b-144">They can also be used with any custom parallel construct.</span></span>  
  
|<span data-ttu-id="3791b-145">Eseguire l'overload</span><span class="sxs-lookup"><span data-stu-id="3791b-145">Overload</span></span>|<span data-ttu-id="3791b-146">Usa il bilanciamento del carico</span><span class="sxs-lookup"><span data-stu-id="3791b-146">Uses load balancing</span></span>|  
|--------------|-------------------------|  
|<xref:System.Collections.Concurrent.Partitioner.Create%60%601%28System.Collections.Generic.IEnumerable%7B%60%600%7D%29>|<span data-ttu-id="3791b-147">Sempre</span><span class="sxs-lookup"><span data-stu-id="3791b-147">Always</span></span>|  
|<xref:System.Collections.Concurrent.Partitioner.Create%60%601%28%60%600%5B%5D%2CSystem.Boolean%29>|<span data-ttu-id="3791b-148">Quando l'argomento booleano viene specificato come true</span><span class="sxs-lookup"><span data-stu-id="3791b-148">When the Boolean argument is specified as true</span></span>|  
|<xref:System.Collections.Concurrent.Partitioner.Create%60%601%28System.Collections.Generic.IList%7B%60%600%7D%2CSystem.Boolean%29>|<span data-ttu-id="3791b-149">Quando l'argomento booleano viene specificato come true</span><span class="sxs-lookup"><span data-stu-id="3791b-149">When the Boolean argument is specified as true</span></span>|  
|<xref:System.Collections.Concurrent.Partitioner.Create%28System.Int32%2CSystem.Int32%29>|<span data-ttu-id="3791b-150">Mai</span><span class="sxs-lookup"><span data-stu-id="3791b-150">Never</span></span>|  
|<xref:System.Collections.Concurrent.Partitioner.Create%28System.Int32%2CSystem.Int32%2CSystem.Int32%29>|<span data-ttu-id="3791b-151">Mai</span><span class="sxs-lookup"><span data-stu-id="3791b-151">Never</span></span>|  
|<xref:System.Collections.Concurrent.Partitioner.Create%28System.Int64%2CSystem.Int64%29>|<span data-ttu-id="3791b-152">Mai</span><span class="sxs-lookup"><span data-stu-id="3791b-152">Never</span></span>|  
|<xref:System.Collections.Concurrent.Partitioner.Create%28System.Int64%2CSystem.Int64%2CSystem.Int64%29>|<span data-ttu-id="3791b-153">Mai</span><span class="sxs-lookup"><span data-stu-id="3791b-153">Never</span></span>|  
  
### <a name="configuring-static-range-partitioners-for-parallelforeach"></a><span data-ttu-id="3791b-154">Configurazione di partitioner statico intervallo per Parallel. foreach</span><span class="sxs-lookup"><span data-stu-id="3791b-154">Configuring Static Range Partitioners for Parallel.ForEach</span></span>  
 <span data-ttu-id="3791b-155">In un <xref:System.Threading.Tasks.Parallel.For%2A> ciclo, il corpo del ciclo viene fornito come un delegato al metodo.</span><span class="sxs-lookup"><span data-stu-id="3791b-155">In a <xref:System.Threading.Tasks.Parallel.For%2A> loop, the body of the loop is provided to the method as a delegate.</span></span> <span data-ttu-id="3791b-156">Il costo della chiamata al delegato è paragonabile a una chiamata al metodo virtuale.</span><span class="sxs-lookup"><span data-stu-id="3791b-156">The cost of invoking that delegate is about the same as a virtual method call.</span></span> <span data-ttu-id="3791b-157">In alcuni scenari, il corpo di un ciclo parallelo potrebbe essere sufficientemente piccolo che diventa significativo il costo della chiamata al delegato a ogni iterazione del ciclo.</span><span class="sxs-lookup"><span data-stu-id="3791b-157">In some scenarios, the body of a parallel loop might be small enough that the cost of the delegate invocation on each loop iteration becomes significant.</span></span> <span data-ttu-id="3791b-158">In tali situazioni, è possibile utilizzare uno del <xref:System.Collections.Concurrent.Partitioner.Create%2A> overload per creare un <xref:System.Collections.Generic.IEnumerable%601> di partizioni a intervalli sugli elementi di origine.</span><span class="sxs-lookup"><span data-stu-id="3791b-158">In such situations, you can use one of the <xref:System.Collections.Concurrent.Partitioner.Create%2A> overloads to create an <xref:System.Collections.Generic.IEnumerable%601> of range partitions over the source elements.</span></span> <span data-ttu-id="3791b-159">Quindi, è possibile passare questo insieme di intervalli per un <xref:System.Threading.Tasks.Parallel.ForEach%2A> metodo il cui corpo è costituito da una normale `for` ciclo.</span><span class="sxs-lookup"><span data-stu-id="3791b-159">Then, you can pass this collection of ranges to a <xref:System.Threading.Tasks.Parallel.ForEach%2A> method whose body consists of a regular `for` loop.</span></span> <span data-ttu-id="3791b-160">Il vantaggio di questo approccio è che il costo della chiamata al delegato si verifica una sola volta per ogni intervallo, anziché una volta per ogni elemento.</span><span class="sxs-lookup"><span data-stu-id="3791b-160">The benefit of this approach is that the delegate invocation cost is incurred only once per range, rather than once per element.</span></span> <span data-ttu-id="3791b-161">Nell'esempio seguente viene illustrato il modello di base.</span><span class="sxs-lookup"><span data-stu-id="3791b-161">The following example demonstrates the basic pattern.</span></span>  
  
 [!code-csharp[TPL_Partitioners#01](../../../samples/snippets/csharp/VS_Snippets_Misc/tpl_partitioners/cs/partitioner01.cs#01)]
 [!code-vb[TPL_Partitioners#01](../../../samples/snippets/visualbasic/VS_Snippets_Misc/tpl_partitioners/vb/partitionercreate01.vb#01)]  
  
 <span data-ttu-id="3791b-162">Ogni thread nel ciclo riceve il proprio <xref:System.Tuple%602> che contiene i valori iniziale e finale dell'indice dell'intervallo secondario specificato.</span><span class="sxs-lookup"><span data-stu-id="3791b-162">Every thread in the loop receives its own <xref:System.Tuple%602> that contains the starting and ending index values in the specified sub-range.</span></span> <span data-ttu-id="3791b-163">Interna `for` ciclo viene utilizzato il `fromInclusive` e `toExclusive` valori per eseguire il ciclo di matrice o <xref:System.Collections.IList> direttamente.</span><span class="sxs-lookup"><span data-stu-id="3791b-163">The inner `for` loop uses the `fromInclusive` and `toExclusive` values to loop over the array or the <xref:System.Collections.IList> directly.</span></span>  
  
 <span data-ttu-id="3791b-164">Uno del <xref:System.Collections.Concurrent.Partitioner.Create%2A> overload consente di specificare le dimensioni delle partizioni e il numero di partizioni.</span><span class="sxs-lookup"><span data-stu-id="3791b-164">One of the <xref:System.Collections.Concurrent.Partitioner.Create%2A> overloads lets you specify the size of the partitions, and the number of partitions.</span></span> <span data-ttu-id="3791b-165">Questo overload è utilizzabile negli scenari in cui ogni elemento di lavoro viene così ridotto che anche un metodo virtuale chiamata per ogni elemento ha un impatto notevole sulle prestazioni.</span><span class="sxs-lookup"><span data-stu-id="3791b-165">This overload can be used in scenarios where the work per element is so low that even one virtual method call per element has a noticeable impact on performance.</span></span>  
  
## <a name="custom-partitioners"></a><span data-ttu-id="3791b-166">Partitioner personalizzati</span><span class="sxs-lookup"><span data-stu-id="3791b-166">Custom Partitioners</span></span>  
 <span data-ttu-id="3791b-167">In alcuni scenari, potrebbe essere utile o anche necessari per implementare un partitioner personalizzato.</span><span class="sxs-lookup"><span data-stu-id="3791b-167">In some scenarios, it might be worthwhile or even required to implement your own partitioner.</span></span> <span data-ttu-id="3791b-168">Ad esempio, potrebbe essere una classe di raccolta personalizzato che è possibile partizionare in modo più efficiente rispetto al valore predefinito di partitioner può, in base alla propria conoscenza della struttura interna della classe.</span><span class="sxs-lookup"><span data-stu-id="3791b-168">For example, you might have a custom collection class that you can partition more efficiently than the default partitioners can, based on your knowledge of the internal structure of the class.</span></span> <span data-ttu-id="3791b-169">In alternativa, è consigliabile creare partizioni a intervalli di dimensioni variabili in base alla propria conoscenza del tempo necessario per l'elaborazione degli elementi in posizioni diverse nella raccolta di origine.</span><span class="sxs-lookup"><span data-stu-id="3791b-169">Or, you may want to create range partitions of varying sizes based on your knowledge of how long it will take to process elements at different locations in the source collection.</span></span>  
  
 <span data-ttu-id="3791b-170">Per creare un partitioner personalizzato di base, derivare una classe da <xref:System.Collections.Concurrent.Partitioner%601?displayProperty=nameWithType> ed eseguire l'override dei metodi virtuali, come descritto nella tabella seguente.</span><span class="sxs-lookup"><span data-stu-id="3791b-170">To create a basic custom partitioner, derive a class from <xref:System.Collections.Concurrent.Partitioner%601?displayProperty=nameWithType> and override the virtual methods, as described in the following table.</span></span>  
  
|||  
|-|-|  
|<xref:System.Collections.Concurrent.Partitioner%601.GetPartitions%2A>|<span data-ttu-id="3791b-171">Questo metodo viene chiamato una volta dal thread principale e restituisce un IList(IEnumerator(TSource)).</span><span class="sxs-lookup"><span data-stu-id="3791b-171">This method is called once by the main thread and returns an IList(IEnumerator(TSource)).</span></span> <span data-ttu-id="3791b-172">Ogni thread di lavoro del ciclo o di una query è possibile chiamare `GetEnumerator` dell'elenco per recuperare un <xref:System.Collections.Generic.IEnumerator%601> su una partizione distinta.</span><span class="sxs-lookup"><span data-stu-id="3791b-172">Each worker thread in the loop or query can call `GetEnumerator` on the list to retrieve a <xref:System.Collections.Generic.IEnumerator%601> over a distinct partition.</span></span>|  
|<xref:System.Collections.Concurrent.Partitioner%601.SupportsDynamicPartitions%2A>|<span data-ttu-id="3791b-173">Restituire `true` se si implementa <xref:System.Collections.Concurrent.Partitioner%601.GetDynamicPartitions%2A>, in caso contrario, `false`.</span><span class="sxs-lookup"><span data-stu-id="3791b-173">Return `true` if you implement <xref:System.Collections.Concurrent.Partitioner%601.GetDynamicPartitions%2A>, otherwise, `false`.</span></span>|  
|<xref:System.Collections.Concurrent.Partitioner%601.GetDynamicPartitions%2A>|<span data-ttu-id="3791b-174">Se <xref:System.Collections.Concurrent.Partitioner%601.SupportsDynamicPartitions%2A> è `true`, questo metodo può essere chiamato facoltativamente anziché <xref:System.Collections.Concurrent.Partitioner%601.GetPartitions%2A>.</span><span class="sxs-lookup"><span data-stu-id="3791b-174">If <xref:System.Collections.Concurrent.Partitioner%601.SupportsDynamicPartitions%2A> is `true`, this method can optionally be called instead of <xref:System.Collections.Concurrent.Partitioner%601.GetPartitions%2A>.</span></span>|  
  
 <span data-ttu-id="3791b-175">Se i risultati devono essere ordinabili o si richiede l'accesso indicizzato agli elementi, derivare da <xref:System.Collections.Concurrent.OrderablePartitioner%601?displayProperty=nameWithType> ed eseguire l'override dei metodi virtuali, come descritto nella tabella seguente.</span><span class="sxs-lookup"><span data-stu-id="3791b-175">If the results must be sortable or you require indexed access into the elements, then derive from <xref:System.Collections.Concurrent.OrderablePartitioner%601?displayProperty=nameWithType> and override its virtual methods as described in the following table.</span></span>  
  
|||  
|-|-|  
|<xref:System.Collections.Concurrent.OrderablePartitioner%601.GetPartitions%2A>|<span data-ttu-id="3791b-176">Questo metodo viene chiamato una volta dal thread principale e restituisce un `IList(IEnumerator(TSource))`.</span><span class="sxs-lookup"><span data-stu-id="3791b-176">This method is called once by the main thread and returns an `IList(IEnumerator(TSource))`.</span></span> <span data-ttu-id="3791b-177">Ogni thread di lavoro del ciclo o di una query è possibile chiamare `GetEnumerator` dell'elenco per recuperare un <xref:System.Collections.Generic.IEnumerator%601> su una partizione distinta.</span><span class="sxs-lookup"><span data-stu-id="3791b-177">Each worker thread in the loop or query can call `GetEnumerator` on the list to retrieve a <xref:System.Collections.Generic.IEnumerator%601> over a distinct partition.</span></span>|  
|<xref:System.Collections.Concurrent.Partitioner%601.SupportsDynamicPartitions%2A>|<span data-ttu-id="3791b-178">Restituire `true` se si implementa <xref:System.Collections.Concurrent.OrderablePartitioner%601.GetDynamicPartitions%2A>; in caso contrario, false.</span><span class="sxs-lookup"><span data-stu-id="3791b-178">Return `true` if you implement <xref:System.Collections.Concurrent.OrderablePartitioner%601.GetDynamicPartitions%2A>; otherwise, false.</span></span>|  
|<xref:System.Collections.Concurrent.OrderablePartitioner%601.GetDynamicPartitions%2A>|<span data-ttu-id="3791b-179">In genere, si limita a chiamare <xref:System.Collections.Concurrent.OrderablePartitioner%601.GetOrderableDynamicPartitions%2A>.</span><span class="sxs-lookup"><span data-stu-id="3791b-179">Typically, this just calls <xref:System.Collections.Concurrent.OrderablePartitioner%601.GetOrderableDynamicPartitions%2A>.</span></span>|  
|<xref:System.Collections.Concurrent.OrderablePartitioner%601.GetOrderableDynamicPartitions%2A>|<span data-ttu-id="3791b-180">Se <xref:System.Collections.Concurrent.Partitioner%601.SupportsDynamicPartitions%2A> è `true`, questo metodo può essere chiamato facoltativamente anziché <xref:System.Collections.Concurrent.Partitioner%601.GetPartitions%2A>.</span><span class="sxs-lookup"><span data-stu-id="3791b-180">If <xref:System.Collections.Concurrent.Partitioner%601.SupportsDynamicPartitions%2A> is `true`, this method can optionally be called instead of <xref:System.Collections.Concurrent.Partitioner%601.GetPartitions%2A>.</span></span>|  
  
 <span data-ttu-id="3791b-181">Nella tabella seguente fornisce informazioni aggiuntive dettagliate su come i tre tipi di bilanciamento del carico partitioner implementare la <xref:System.Collections.Concurrent.OrderablePartitioner%601> classe.</span><span class="sxs-lookup"><span data-stu-id="3791b-181">The following table provides additional details about how the three kinds of load-balancing partitioners implement the <xref:System.Collections.Concurrent.OrderablePartitioner%601> class.</span></span>  
  
|<span data-ttu-id="3791b-182">Metodo o proprietà</span><span class="sxs-lookup"><span data-stu-id="3791b-182">Method/Property</span></span>|<span data-ttu-id="3791b-183">IList / matrice senza bilanciamento del carico</span><span class="sxs-lookup"><span data-stu-id="3791b-183">IList / Array without Load Balancing</span></span>|<span data-ttu-id="3791b-184">IList / matrice con bilanciamento del carico</span><span class="sxs-lookup"><span data-stu-id="3791b-184">IList / Array with Load Balancing</span></span>|<span data-ttu-id="3791b-185">IEnumerable</span><span class="sxs-lookup"><span data-stu-id="3791b-185">IEnumerable</span></span>|  
|----------------------|-------------------------------------------|----------------------------------------|-----------------|  
|<xref:System.Collections.Concurrent.OrderablePartitioner%601.GetOrderablePartitions%2A>|<span data-ttu-id="3791b-186">Utilizza il partizionamento per intervallo</span><span class="sxs-lookup"><span data-stu-id="3791b-186">Uses range partitioning</span></span>|<span data-ttu-id="3791b-187">Utilizza il partizionamento ottimizzato per gli elenchi per l'elemento partitionCount specificato</span><span class="sxs-lookup"><span data-stu-id="3791b-187">Uses chunk partitioning optimized for Lists for the partitionCount specified</span></span>|<span data-ttu-id="3791b-188">Utilizza il partizionamento tramite la creazione di un numero statico di partizioni.</span><span class="sxs-lookup"><span data-stu-id="3791b-188">Uses chunk partitioning by creating a static number of partitions.</span></span>|  
|<xref:System.Collections.Concurrent.OrderablePartitioner%601.GetOrderableDynamicPartitions%2A?displayProperty=nameWithType>|<span data-ttu-id="3791b-189">Eccezione generata non supportata</span><span class="sxs-lookup"><span data-stu-id="3791b-189">Throws not-supported exception</span></span>|<span data-ttu-id="3791b-190">Utilizza il partizionamento ottimizzato per gli elenchi e le partizioni dinamiche</span><span class="sxs-lookup"><span data-stu-id="3791b-190">Uses chunk partitioning optimized for Lists and dynamic partitions</span></span>|<span data-ttu-id="3791b-191">Utilizza il partizionamento tramite la creazione di un numero di partizioni dinamico.</span><span class="sxs-lookup"><span data-stu-id="3791b-191">Uses chunk partitioning by creating a dynamic number of partitions.</span></span>|  
|<xref:System.Collections.Concurrent.OrderablePartitioner%601.KeysOrderedInEachPartition%2A>|<span data-ttu-id="3791b-192">Restituisce `true`.</span><span class="sxs-lookup"><span data-stu-id="3791b-192">Returns `true`</span></span>|<span data-ttu-id="3791b-193">Restituisce `true`.</span><span class="sxs-lookup"><span data-stu-id="3791b-193">Returns `true`</span></span>|<span data-ttu-id="3791b-194">Restituisce `true`.</span><span class="sxs-lookup"><span data-stu-id="3791b-194">Returns `true`</span></span>|  
|<xref:System.Collections.Concurrent.OrderablePartitioner%601.KeysOrderedAcrossPartitions%2A>|<span data-ttu-id="3791b-195">Restituisce `true`.</span><span class="sxs-lookup"><span data-stu-id="3791b-195">Returns `true`</span></span>|<span data-ttu-id="3791b-196">Restituisce `false`.</span><span class="sxs-lookup"><span data-stu-id="3791b-196">Returns `false`</span></span>|<span data-ttu-id="3791b-197">Restituisce `false`.</span><span class="sxs-lookup"><span data-stu-id="3791b-197">Returns `false`</span></span>|  
|<xref:System.Collections.Concurrent.OrderablePartitioner%601.KeysNormalized%2A>|<span data-ttu-id="3791b-198">Restituisce `true`.</span><span class="sxs-lookup"><span data-stu-id="3791b-198">Returns `true`</span></span>|<span data-ttu-id="3791b-199">Restituisce `true`.</span><span class="sxs-lookup"><span data-stu-id="3791b-199">Returns `true`</span></span>|<span data-ttu-id="3791b-200">Restituisce `true`.</span><span class="sxs-lookup"><span data-stu-id="3791b-200">Returns `true`</span></span>|  
|<xref:System.Collections.Concurrent.Partitioner%601.SupportsDynamicPartitions%2A>|<span data-ttu-id="3791b-201">Restituisce `false`.</span><span class="sxs-lookup"><span data-stu-id="3791b-201">Returns `false`</span></span>|<span data-ttu-id="3791b-202">Restituisce `true`.</span><span class="sxs-lookup"><span data-stu-id="3791b-202">Returns `true`</span></span>|<span data-ttu-id="3791b-203">Restituisce `true`.</span><span class="sxs-lookup"><span data-stu-id="3791b-203">Returns `true`</span></span>|  
  
### <a name="dynamic-partitions"></a><span data-ttu-id="3791b-204">Partizioni dinamiche</span><span class="sxs-lookup"><span data-stu-id="3791b-204">Dynamic Partitions</span></span>  
 <span data-ttu-id="3791b-205">Se si prevede che il partitioner da utilizzare in un <xref:System.Threading.Tasks.Parallel.ForEach%2A> (metodo), è necessario essere in grado di restituire un numero di partizioni dinamico.</span><span class="sxs-lookup"><span data-stu-id="3791b-205">If you intend the partitioner to be used in a <xref:System.Threading.Tasks.Parallel.ForEach%2A> method, you must be able to return a dynamic number of partitions.</span></span> <span data-ttu-id="3791b-206">Ciò significa che il partitioner può fornire un enumeratore per una nuova partizione su richiesta in qualsiasi momento durante l'esecuzione del ciclo.</span><span class="sxs-lookup"><span data-stu-id="3791b-206">This means that the partitioner can supply an enumerator for a new partition on-demand at any time during loop execution.</span></span> <span data-ttu-id="3791b-207">In pratica, ogni volta che il ciclo aggiunge una nuova attività parallela, verrà richiesta una nuova partizione per l'attività.</span><span class="sxs-lookup"><span data-stu-id="3791b-207">Basically, whenever the loop adds a new parallel task, it requests a new partition for that task.</span></span> <span data-ttu-id="3791b-208">Se si richiedono i dati siano ordinabili, derivare da <xref:System.Collections.Concurrent.OrderablePartitioner%601?displayProperty=nameWithType> in modo che ogni elemento in ogni partizione viene assegnato un indice univoco.</span><span class="sxs-lookup"><span data-stu-id="3791b-208">If you require the data to be orderable, then derive from <xref:System.Collections.Concurrent.OrderablePartitioner%601?displayProperty=nameWithType> so that each item in each partition is assigned a unique index.</span></span>  
  
 <span data-ttu-id="3791b-209">Per ulteriori informazioni e un esempio, vedere [How to: Implement Dynamic Partitions](../../../docs/standard/parallel-programming/how-to-implement-dynamic-partitions.md).</span><span class="sxs-lookup"><span data-stu-id="3791b-209">For more information, and an example, see [How to: Implement Dynamic Partitions](../../../docs/standard/parallel-programming/how-to-implement-dynamic-partitions.md).</span></span>  
  
### <a name="contract-for-partitioners"></a><span data-ttu-id="3791b-210">Contratto per i partitioner</span><span class="sxs-lookup"><span data-stu-id="3791b-210">Contract for Partitioners</span></span>  
 <span data-ttu-id="3791b-211">Quando si implementa un partitioner personalizzato, seguire queste linee guida per garantire la corretta interazione con PLINQ e <xref:System.Threading.Tasks.Parallel.ForEach%2A> in TPL:</span><span class="sxs-lookup"><span data-stu-id="3791b-211">When you implement a custom partitioner, follow these guidelines to help ensure correct interaction with PLINQ and <xref:System.Threading.Tasks.Parallel.ForEach%2A> in the TPL:</span></span>  
  
-   <span data-ttu-id="3791b-212">Se <xref:System.Collections.Concurrent.Partitioner%601.GetPartitions%2A> viene chiamata con un argomento di zero o meno, per `partitionsCount`, generare <xref:System.ArgumentOutOfRangeException>.</span><span class="sxs-lookup"><span data-stu-id="3791b-212">If <xref:System.Collections.Concurrent.Partitioner%601.GetPartitions%2A> is called with an argument of zero or less for `partitionsCount`, throw <xref:System.ArgumentOutOfRangeException>.</span></span> <span data-ttu-id="3791b-213">Anche se PLINQ e TPL non passeranno mai in un `partitionCount` uguale a 0, si consiglia comunque di prevenire il possibilità.</span><span class="sxs-lookup"><span data-stu-id="3791b-213">Although PLINQ and TPL will never pass in a `partitionCount` equal to 0, we nevertheless recommend that you guard against the possibility.</span></span>  
  
-   <span data-ttu-id="3791b-214"><xref:System.Collections.Concurrent.Partitioner%601.GetPartitions%2A>e <xref:System.Collections.Concurrent.OrderablePartitioner%601.GetOrderablePartitions%2A> deve sempre restituire `partitionsCount` numero di partizioni.</span><span class="sxs-lookup"><span data-stu-id="3791b-214"><xref:System.Collections.Concurrent.Partitioner%601.GetPartitions%2A> and <xref:System.Collections.Concurrent.OrderablePartitioner%601.GetOrderablePartitions%2A> should always return `partitionsCount` number of partitions.</span></span> <span data-ttu-id="3791b-215">Se l'elemento partitioner dati si esaurisce e non è possibile creare tante partizioni quante richiesto, il metodo deve restituire un enumeratore vuoto per ciascuna delle rimanenti partizioni.</span><span class="sxs-lookup"><span data-stu-id="3791b-215">If the partitioner runs out of data and cannot create as many partitions as requested, then the method should return an empty enumerator for each of the remaining partitions.</span></span> <span data-ttu-id="3791b-216">In caso contrario, sia PLINQ e TPL genererà un <xref:System.InvalidOperationException>.</span><span class="sxs-lookup"><span data-stu-id="3791b-216">Otherwise, both PLINQ and TPL will throw an <xref:System.InvalidOperationException>.</span></span>  
  
-   <span data-ttu-id="3791b-217"><xref:System.Collections.Concurrent.Partitioner%601.GetPartitions%2A>, <xref:System.Collections.Concurrent.OrderablePartitioner%601.GetOrderablePartitions%2A>, <xref:System.Collections.Concurrent.Partitioner%601.GetDynamicPartitions%2A>, e <xref:System.Collections.Concurrent.OrderablePartitioner%601.GetOrderableDynamicPartitions%2A> non devono mai restituire `null` (`Nothing` in Visual Basic).</span><span class="sxs-lookup"><span data-stu-id="3791b-217"><xref:System.Collections.Concurrent.Partitioner%601.GetPartitions%2A>, <xref:System.Collections.Concurrent.OrderablePartitioner%601.GetOrderablePartitions%2A>, <xref:System.Collections.Concurrent.Partitioner%601.GetDynamicPartitions%2A>, and <xref:System.Collections.Concurrent.OrderablePartitioner%601.GetOrderableDynamicPartitions%2A> should never return `null` (`Nothing` in Visual Basic).</span></span> <span data-ttu-id="3791b-218">In caso affermativo, PLINQ / TPL genererà un <xref:System.InvalidOperationException>.</span><span class="sxs-lookup"><span data-stu-id="3791b-218">If they do, PLINQ / TPL will throw an <xref:System.InvalidOperationException>.</span></span>  
  
-   <span data-ttu-id="3791b-219">Metodi che restituiscono le partizioni devono sempre restituire partizioni che possono enumerare completamente e in modo univoco l'origine dati.</span><span class="sxs-lookup"><span data-stu-id="3791b-219">Methods that return partitions should always return partitions that can fully and uniquely enumerate the data source.</span></span> <span data-ttu-id="3791b-220">Devono essere presenti duplicati nell'origine dati o elementi ignorati a meno che non specificamente richiesto dalla progettazione del partitioner.</span><span class="sxs-lookup"><span data-stu-id="3791b-220">There should be no duplication in the data source or skipped items unless specifically required by the design of the partitioner.</span></span> <span data-ttu-id="3791b-221">Se questa regola non viene rispettata, può alterato l'ordine di output.</span><span class="sxs-lookup"><span data-stu-id="3791b-221">If this rule is not followed, then the output order may be scrambled.</span></span>  
  
-   <span data-ttu-id="3791b-222">Il getter booleana seguente deve sempre restituire esattamente i valori seguenti in modo che l'ordine di output non è codificato:</span><span class="sxs-lookup"><span data-stu-id="3791b-222">The following Boolean getters must always accurately return the following values so that the output order is not scrambled:</span></span>  
  
    -   <span data-ttu-id="3791b-223">`KeysOrderedInEachPartition`: Ogni partizione restituisce gli elementi con indici di chiave incrementali.</span><span class="sxs-lookup"><span data-stu-id="3791b-223">`KeysOrderedInEachPartition`: Each partition returns elements with increasing key indices.</span></span>  
  
    -   <span data-ttu-id="3791b-224">`KeysOrderedAcrossPartitions`: Per tutte le partizioni che vengono restituiti gli indici di chiave di partizione *si* sono maggiori degli indici di chiave di partizione *si*-1.</span><span class="sxs-lookup"><span data-stu-id="3791b-224">`KeysOrderedAcrossPartitions`: For all partitions that are returned, the key indices in partition *i* are higher than the key indices in partition *i*-1.</span></span>  
  
    -   <span data-ttu-id="3791b-225">`KeysNormalized`: Tutti gli indici di chiave sono a incremento progressivo costante senza interruzioni, a partire da zero.</span><span class="sxs-lookup"><span data-stu-id="3791b-225">`KeysNormalized`: All key indices are monotonically increasing without gaps, starting from zero.</span></span>  
  
-   <span data-ttu-id="3791b-226">Tutti gli indici devono essere univoci.</span><span class="sxs-lookup"><span data-stu-id="3791b-226">All indices must be unique.</span></span> <span data-ttu-id="3791b-227">Potrebbe non essere indici duplicati.</span><span class="sxs-lookup"><span data-stu-id="3791b-227">There may not be duplicate indices.</span></span> <span data-ttu-id="3791b-228">Se questa regola non viene rispettata, può alterato l'ordine di output.</span><span class="sxs-lookup"><span data-stu-id="3791b-228">If this rule is not followed, then the output order may be scrambled.</span></span>  
  
-   <span data-ttu-id="3791b-229">Tutti gli indici devono essere negativi.</span><span class="sxs-lookup"><span data-stu-id="3791b-229">All indices must be nonnegative.</span></span> <span data-ttu-id="3791b-230">Se questa regola non viene rispettata, PLINQ/TPL può generare eccezioni.</span><span class="sxs-lookup"><span data-stu-id="3791b-230">If this rule is not followed, then PLINQ/TPL may throw exceptions.</span></span>  
  
## <a name="see-also"></a><span data-ttu-id="3791b-231">Vedere anche</span><span class="sxs-lookup"><span data-stu-id="3791b-231">See Also</span></span>  
 [<span data-ttu-id="3791b-232">Programmazione parallela</span><span class="sxs-lookup"><span data-stu-id="3791b-232">Parallel Programming</span></span>](../../../docs/standard/parallel-programming/index.md)  
 [<span data-ttu-id="3791b-233">Procedura: Implementare partizioni dinamiche</span><span class="sxs-lookup"><span data-stu-id="3791b-233">How to: Implement Dynamic Partitions</span></span>](../../../docs/standard/parallel-programming/how-to-implement-dynamic-partitions.md)  
 [<span data-ttu-id="3791b-234">Procedura: Implementare un partitioner per il partizionamento statico</span><span class="sxs-lookup"><span data-stu-id="3791b-234">How to: Implement a Partitioner for Static Partitioning</span></span>](../../../docs/standard/parallel-programming/how-to-implement-a-partitioner-for-static-partitioning.md)
