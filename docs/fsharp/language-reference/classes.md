---
title: Classi (F#)
description: 'Informazioni su come le classi F # sono tipi che rappresentano oggetti che possono disporre di proprietà, metodi ed eventi.'
author: cartermp
ms.author: phcart
ms.date: 05/16/2016
ms.topic: language-reference
ms.prod: dotnet-fsharp
ms.devlang: fsharp
ms.openlocfilehash: 0bfb45b6481576729bfe8d4bd016fb151757660a
ms.sourcegitcommit: 03ee570f6f528a7d23a4221dcb26a9498edbdf8c
ms.translationtype: MT
ms.contentlocale: it-IT
ms.lasthandoff: 04/28/2018
---
# <a name="classes"></a><span data-ttu-id="24001-103">Classi</span><span class="sxs-lookup"><span data-stu-id="24001-103">Classes</span></span>

<span data-ttu-id="24001-104">*Classi* sono tipi che rappresentano oggetti che possono avere proprietà, metodi ed eventi.</span><span class="sxs-lookup"><span data-stu-id="24001-104">*Classes* are types that represent objects that can have properties, methods, and events.</span></span>


## <a name="syntax"></a><span data-ttu-id="24001-105">Sintassi</span><span class="sxs-lookup"><span data-stu-id="24001-105">Syntax</span></span>

```fsharp
// Class definition:
type [access-modifier] type-name [type-params] [access-modifier] ( parameter-list ) [ as identifier ] =
[ class ]
[ inherit base-type-name(base-constructor-args) ]
[ let-bindings ]
[ do-bindings ]
member-list
...
[ end ]
// Mutually recursive class definitions:
type [access-modifier] type-name1 ...
and [access-modifier] type-name2 ...
...
```

## <a name="remarks"></a><span data-ttu-id="24001-106">Note</span><span class="sxs-lookup"><span data-stu-id="24001-106">Remarks</span></span>
<span data-ttu-id="24001-107">Le classi rappresentano la descrizione fondamentale dei tipi di oggetto .NET. la classe è il concetto di tipo primario che supporta la programmazione orientata a oggetti in F #.</span><span class="sxs-lookup"><span data-stu-id="24001-107">Classes represent the fundamental description of .NET object types; the class is the primary type concept that supports object-oriented programming in F#.</span></span>

<span data-ttu-id="24001-108">Nella sintassi precedente, il `type-name` qualsiasi identificatore valido.</span><span class="sxs-lookup"><span data-stu-id="24001-108">In the preceding syntax, the `type-name` is any valid identifier.</span></span> <span data-ttu-id="24001-109">Il `type-params` vengono descritti i parametri di tipo generico facoltativi.</span><span class="sxs-lookup"><span data-stu-id="24001-109">The `type-params` describes optional generic type parameters.</span></span> <span data-ttu-id="24001-110">È costituito da nomi di parametro di tipo e vincoli racchiuso tra parentesi angolari (`<` e `>`).</span><span class="sxs-lookup"><span data-stu-id="24001-110">It consists of type parameter names and constraints enclosed in angle brackets (`<` and `>`).</span></span> <span data-ttu-id="24001-111">Per ulteriori informazioni, vedere [Generics](generics/index.md) e [vincoli](generics/constraints.md).</span><span class="sxs-lookup"><span data-stu-id="24001-111">For more information, see [Generics](generics/index.md) and [Constraints](generics/constraints.md).</span></span> <span data-ttu-id="24001-112">Il `parameter-list` descrive i parametri del costruttore.</span><span class="sxs-lookup"><span data-stu-id="24001-112">The `parameter-list` describes constructor parameters.</span></span> <span data-ttu-id="24001-113">Il primo modificatore di accesso relativo al tipo; il secondo si riferisce al costruttore primario.</span><span class="sxs-lookup"><span data-stu-id="24001-113">The first access modifier pertains to the type; the second pertains to the primary constructor.</span></span> <span data-ttu-id="24001-114">In entrambi i casi, il valore predefinito è `public`.</span><span class="sxs-lookup"><span data-stu-id="24001-114">In both cases, the default is `public`.</span></span>

<span data-ttu-id="24001-115">Specificare la classe base per una classe utilizzando il `inherit` (parola chiave).</span><span class="sxs-lookup"><span data-stu-id="24001-115">You specify the base class for a class by using the `inherit` keyword.</span></span> <span data-ttu-id="24001-116">È necessario fornire argomenti tra parentesi, per il costruttore di classe di base.</span><span class="sxs-lookup"><span data-stu-id="24001-116">You must supply arguments, in parentheses, for the base class constructor.</span></span>

<span data-ttu-id="24001-117">Si dichiara campi o valori di locale per la classe di funzioni `let` associazioni e si devono seguire le regole generali per `let` associazioni.</span><span class="sxs-lookup"><span data-stu-id="24001-117">You declare fields or function values that are local to the class by using `let` bindings, and you must follow the general rules for `let` bindings.</span></span> <span data-ttu-id="24001-118">Il `do-bindings` sezione include codice da eseguire durante la costruzione di oggetti.</span><span class="sxs-lookup"><span data-stu-id="24001-118">The `do-bindings` section includes code to be executed upon object construction.</span></span>

<span data-ttu-id="24001-119">Il `member-list` include costruttori aggiuntivi, istanza e le dichiarazioni di metodo statico, le dichiarazioni di interfaccia, associazioni astratte e dichiarazioni di proprietà ed eventi.</span><span class="sxs-lookup"><span data-stu-id="24001-119">The `member-list` consists of additional constructors, instance and static method declarations, interface declarations, abstract bindings, and property and event declarations.</span></span> <span data-ttu-id="24001-120">Questi elementi sono descritti [membri](members/index.md).</span><span class="sxs-lookup"><span data-stu-id="24001-120">These are described in [Members](members/index.md).</span></span>

<span data-ttu-id="24001-121">Il `identifier` utilizzato con l'opzione facoltativa `as` (parola chiave) fornisce un nome per la variabile di istanza o autoidentificatore, che può essere utilizzato nella definizione del tipo per fare riferimento all'istanza del tipo.</span><span class="sxs-lookup"><span data-stu-id="24001-121">The `identifier` that is used with the optional `as` keyword gives a name to the instance variable, or self identifier, which can be used in the type definition to refer to the instance of the type.</span></span> <span data-ttu-id="24001-122">Per ulteriori informazioni, vedere la sezione autoidentificatori più avanti in questo argomento.</span><span class="sxs-lookup"><span data-stu-id="24001-122">For more information, see the section Self Identifiers later in this topic.</span></span>

<span data-ttu-id="24001-123">Le parole chiave `class` e `end` che contrassegna l'inizio e fine della definizione sono facoltativi.</span><span class="sxs-lookup"><span data-stu-id="24001-123">The keywords `class` and `end` that mark the start and end of the definition are optional.</span></span>

<span data-ttu-id="24001-124">Si escludono a tipi ricorsiva, che sono tipi che fanno riferimento a altro, vengono uniti con il `and` parola chiave come funzioni ricorsive reciproche.</span><span class="sxs-lookup"><span data-stu-id="24001-124">Mutually recursive types, which are types that reference each other, are joined together with the `and` keyword just as mutually recursive functions are.</span></span> <span data-ttu-id="24001-125">Per un esempio, vedere la sezione tipi ricorsivi reciproci.</span><span class="sxs-lookup"><span data-stu-id="24001-125">For an example, see the section Mutually Recursive Types.</span></span>


## <a name="constructors"></a><span data-ttu-id="24001-126">Costruttori</span><span class="sxs-lookup"><span data-stu-id="24001-126">Constructors</span></span>
<span data-ttu-id="24001-127">Il costruttore è codice che crea un'istanza del tipo di classe.</span><span class="sxs-lookup"><span data-stu-id="24001-127">The constructor is code that creates an instance of the class type.</span></span> <span data-ttu-id="24001-128">Costruttori di classi eseguite in modo diverso in F # rispetto a in altri linguaggi .NET.</span><span class="sxs-lookup"><span data-stu-id="24001-128">Constructors for classes work somewhat differently in F# than they do in other .NET languages.</span></span> <span data-ttu-id="24001-129">In una classe F #, è sempre un costruttore primario i cui argomenti sono descritti nel `parameter-list` che segue il nome del tipo e il cui corpo è costituito il `let` (e `let rec`) associazioni all'inizio della dichiarazione di classe e il `do`associazioni che seguono.</span><span class="sxs-lookup"><span data-stu-id="24001-129">In an F# class, there is always a primary constructor whose arguments are described in the `parameter-list` that follows the type name, and whose body consists of the `let` (and `let rec`) bindings at the start of the class declaration and the `do` bindings that follow.</span></span> <span data-ttu-id="24001-130">Gli argomenti del costruttore primario sono nell'ambito della dichiarazione di classe.</span><span class="sxs-lookup"><span data-stu-id="24001-130">The arguments of the primary constructor are in scope throughout the class declaration.</span></span>

<span data-ttu-id="24001-131">È possibile aggiungere costruttori aggiuntivi tramite il `new` (parola chiave) per aggiungere un membro, come indicato di seguito:</span><span class="sxs-lookup"><span data-stu-id="24001-131">You can add additional constructors by using the `new` keyword to add a member, as follows:</span></span>

<span data-ttu-id="24001-132">`new`(`argument-list`) = `constructor-body`</span><span class="sxs-lookup"><span data-stu-id="24001-132">`new`(`argument-list`) = `constructor-body`</span></span>

<span data-ttu-id="24001-133">Il corpo del costruttore della nuova deve richiamare il costruttore primario specificato nella parte superiore della dichiarazione di classe.</span><span class="sxs-lookup"><span data-stu-id="24001-133">The body of the new constructor must invoke the primary constructor that is specified at the top of the class declaration.</span></span>

<span data-ttu-id="24001-134">Nell'esempio seguente viene illustrato questo concetto.</span><span class="sxs-lookup"><span data-stu-id="24001-134">The following example illustrates this concept.</span></span> <span data-ttu-id="24001-135">Nel codice seguente, `MyClass` dispone di due costruttori, un costruttore primario che accetta due argomenti e un altro costruttore che non accetta argomenti.</span><span class="sxs-lookup"><span data-stu-id="24001-135">In the following code, `MyClass` has two constructors, a primary constructor that takes two arguments and another constructor that takes no arguments.</span></span>

[!code-fsharp[Main](../../../samples/snippets/fsharp/lang-ref-1/snippet2401.fs)]
    
## <a name="let-and-do-bindings"></a><span data-ttu-id="24001-136">Associazioni let e do</span><span class="sxs-lookup"><span data-stu-id="24001-136">let and do Bindings</span></span>

<span data-ttu-id="24001-137">Il `let` e `do` binding in una definizione di classe formano il corpo del costruttore della classe primaria e pertanto vengono eseguiti ogni volta che viene creata un'istanza della classe.</span><span class="sxs-lookup"><span data-stu-id="24001-137">The `let` and `do` bindings in a class definition form the body of the primary class constructor, and therefore they run whenever a class instance is created.</span></span> <span data-ttu-id="24001-138">Se un `let` associazione è una funzione, quindi viene compilato in un membro.</span><span class="sxs-lookup"><span data-stu-id="24001-138">If a `let` binding is a function, then it is compiled into a member.</span></span> <span data-ttu-id="24001-139">Se il `let` associazione è un valore che non viene utilizzato in qualsiasi funzione o membro, quindi viene compilato in una variabile locale per il costruttore.</span><span class="sxs-lookup"><span data-stu-id="24001-139">If the `let` binding is a value that is not used in any function or member, then it is compiled into a variable that is local to the constructor.</span></span> <span data-ttu-id="24001-140">In caso contrario, viene compilato in un campo della classe.</span><span class="sxs-lookup"><span data-stu-id="24001-140">Otherwise, it is compiled into a field of the class.</span></span> <span data-ttu-id="24001-141">Il `do` espressioni che seguono vengono compilate nel costruttore primario ed eseguire il codice di inizializzazione per ogni istanza.</span><span class="sxs-lookup"><span data-stu-id="24001-141">The `do` expressions that follow are compiled into the primary constructor and execute initialization code for every instance.</span></span> <span data-ttu-id="24001-142">Poiché qualsiasi costruttore aggiuntivo chiama sempre il costruttore primario, il `let` associazioni e `do` vengono sempre eseguite, indipendentemente da quale costruttore viene chiamato.</span><span class="sxs-lookup"><span data-stu-id="24001-142">Because any additional constructors always call the primary constructor, the `let` bindings and `do` bindings always execute regardless of which constructor is called.</span></span>

<span data-ttu-id="24001-143">I campi che vengono creati `let` associazioni accessibili nei metodi e proprietà della classe; tuttavia, che non siano accessibili da metodi statici, anche se i metodi statici accettano una variabile di istanza come parametro.</span><span class="sxs-lookup"><span data-stu-id="24001-143">Fields that are created by `let` bindings can be accessed throughout the methods and properties of the class; however, they cannot be accessed from static methods, even if the static methods take an instance variable as a parameter.</span></span> <span data-ttu-id="24001-144">Non è possibile accedervi tramite l'autoidentificatore, se presente.</span><span class="sxs-lookup"><span data-stu-id="24001-144">They cannot be accessed by using the self identifier, if one exists.</span></span>


## <a name="self-identifiers"></a><span data-ttu-id="24001-145">Autoidentificatori</span><span class="sxs-lookup"><span data-stu-id="24001-145">Self Identifiers</span></span>

<span data-ttu-id="24001-146">Oggetto *autoidentificatore* è un nome che rappresenta l'istanza corrente.</span><span class="sxs-lookup"><span data-stu-id="24001-146">A *self identifier* is a name that represents the current instance.</span></span> <span data-ttu-id="24001-147">Autoidentificatori simile di `this` (parola chiave) in c# o C++ o `Me` in Visual Basic.</span><span class="sxs-lookup"><span data-stu-id="24001-147">Self identifiers resemble the `this` keyword in C# or C++ or `Me` in Visual Basic.</span></span> <span data-ttu-id="24001-148">È possibile definire un autoidentificatore in due modi diversi, a seconda che si voglia l'autoidentificatore sia nell'ambito per l'intera definizione di classe o solo per un singolo metodo.</span><span class="sxs-lookup"><span data-stu-id="24001-148">You can define a self identifier in two different ways, depending on whether you want the self identifier to be in scope for the whole class definition or just for an individual method.</span></span>

<span data-ttu-id="24001-149">Per definire un autoidentificatore per l'intera classe, utilizzare il `as` (parola chiave) dopo la parentesi di chiusura del parametro del costruttore elenco e specificare il nome dell'identificatore.</span><span class="sxs-lookup"><span data-stu-id="24001-149">To define a self identifier for the whole class, use the `as` keyword after the closing parentheses of the constructor parameter list, and specify the identifier name.</span></span>

<span data-ttu-id="24001-150">Per definire un autoidentificatore solo per un metodo, fornire l'autoidentificatore nella dichiarazione del membro, appena prima del nome di metodo e un punto (.) come separatore.</span><span class="sxs-lookup"><span data-stu-id="24001-150">To define a self identifier for just one method, provide the self identifier in the member declaration, just before the method name and a period (.) as a separator.</span></span>

<span data-ttu-id="24001-151">Esempio di codice seguente illustra due modi per creare un identificatore utente.</span><span class="sxs-lookup"><span data-stu-id="24001-151">The following code example illustrates the two ways to create a self identifier.</span></span> <span data-ttu-id="24001-152">Nella prima riga, il `as` parola chiave viene utilizzata per definire l'autoidentificatore.</span><span class="sxs-lookup"><span data-stu-id="24001-152">In the first line, the `as` keyword is used to define the self identifier.</span></span> <span data-ttu-id="24001-153">Nella quinta riga, l'identificatore `this` viene utilizzato per definire un autoidentificatore il cui ambito è limitato al metodo `PrintMessage`.</span><span class="sxs-lookup"><span data-stu-id="24001-153">In the fifth line, the identifier `this` is used to define a self identifier whose scope is restricted to the method `PrintMessage`.</span></span>

```fsharp
type MyClass2(dataIn) as self =
    let data = dataIn
    do
        self.PrintMessage()
    member this.PrintMessage() =
        printf "Creating MyClass2 with Data %d" data
```

<span data-ttu-id="24001-154">A differenza di altri linguaggi .NET, è possibile denominare l'autoidentificatore tuttavia si desidera. non sono è limitato ai nomi, ad esempio `self`, `Me`, o `this`.</span><span class="sxs-lookup"><span data-stu-id="24001-154">Unlike in other .NET languages, you can name the self identifier however you want; you are not restricted to names such as `self`, `Me`, or `this`.</span></span>

<span data-ttu-id="24001-155">L'autoidentificatore è dichiarato con la `as` parola chiave non viene inizializzato fino a dopo il `let` vengono eseguite le associazioni.</span><span class="sxs-lookup"><span data-stu-id="24001-155">The self identifier that is declared with the `as` keyword is not initialized until after the `let` bindings are executed.</span></span> <span data-ttu-id="24001-156">Pertanto, non può essere utilizzato nel `let` associazioni.</span><span class="sxs-lookup"><span data-stu-id="24001-156">Therefore, it cannot be used in the `let` bindings.</span></span> <span data-ttu-id="24001-157">È possibile utilizzare l'autoidentificatore nella `do` sezione delle associazioni.</span><span class="sxs-lookup"><span data-stu-id="24001-157">You can use the self identifier in the `do` bindings section.</span></span>


## <a name="generic-type-parameters"></a><span data-ttu-id="24001-158">Parametri di tipo generico</span><span class="sxs-lookup"><span data-stu-id="24001-158">Generic Type Parameters</span></span>

<span data-ttu-id="24001-159">Parametri di tipo generico vengono specificati tra parentesi quadre (`<` e `>`), sotto forma di una virgoletta singola, seguita da un identificatore.</span><span class="sxs-lookup"><span data-stu-id="24001-159">Generic type parameters are specified in angle brackets (`<` and `>`), in the form of a single quotation mark followed by an identifier.</span></span> <span data-ttu-id="24001-160">Più parametri di tipo generico sono separati da virgole.</span><span class="sxs-lookup"><span data-stu-id="24001-160">Multiple generic type parameters are separated by commas.</span></span> <span data-ttu-id="24001-161">Il parametro di tipo generico è nell'ambito della dichiarazione.</span><span class="sxs-lookup"><span data-stu-id="24001-161">The generic type parameter is in scope throughout the declaration.</span></span> <span data-ttu-id="24001-162">Esempio di codice seguente viene illustrato come specificare i parametri di tipo generico.</span><span class="sxs-lookup"><span data-stu-id="24001-162">The following code example shows how to specify generic type parameters.</span></span>

[!code-fsharp[Main](../../../samples/snippets/fsharp/lang-ref-1/snippet2403.fs)]

<span data-ttu-id="24001-163">Gli argomenti di tipo vengono dedotti quando viene utilizzato il tipo.</span><span class="sxs-lookup"><span data-stu-id="24001-163">Type arguments are inferred when the type is used.</span></span> <span data-ttu-id="24001-164">Nel codice seguente, il tipo derivato è una sequenza di tuple.</span><span class="sxs-lookup"><span data-stu-id="24001-164">In the following code, the inferred type is a sequence of tuples.</span></span>

[!code-fsharp[Main](../../../samples/snippets/fsharp/lang-ref-1/snippet24031.fs)]
    
## <a name="specifying-inheritance"></a><span data-ttu-id="24001-165">Impostazione dell'ereditarietà</span><span class="sxs-lookup"><span data-stu-id="24001-165">Specifying Inheritance</span></span>

<span data-ttu-id="24001-166">Il `inherit` clausola identifica la classe base diretta, se presente.</span><span class="sxs-lookup"><span data-stu-id="24001-166">The `inherit` clause identifies the direct base class, if there is one.</span></span> <span data-ttu-id="24001-167">In F #, è consentita solo una classe base diretta.</span><span class="sxs-lookup"><span data-stu-id="24001-167">In F#, only one direct base class is allowed.</span></span> <span data-ttu-id="24001-168">Le interfacce implementate da una classe non vengono considerate le classi di base.</span><span class="sxs-lookup"><span data-stu-id="24001-168">Interfaces that a class implements are not considered base classes.</span></span> <span data-ttu-id="24001-169">Vengono descritte le interfacce nella [interfacce](Interfaces.md) argomento.</span><span class="sxs-lookup"><span data-stu-id="24001-169">Interfaces are discussed in the [Interfaces](Interfaces.md) topic.</span></span>

<span data-ttu-id="24001-170">È possibile accedere i metodi e proprietà della classe base dalla classe derivata utilizzando la parola chiave language `base` come identificatore, seguita da un punto (.) e il nome del membro.</span><span class="sxs-lookup"><span data-stu-id="24001-170">You can access the methods and properties of the base class from the derived class by using the language keyword `base` as an identifier, followed by a period (.) and the name of the member.</span></span>

<span data-ttu-id="24001-171">Per altre informazioni, vedere [Ereditarietà](inheritance.md).</span><span class="sxs-lookup"><span data-stu-id="24001-171">For more information, see [Inheritance](inheritance.md).</span></span>


## <a name="members-section"></a><span data-ttu-id="24001-172">Sezione di membri</span><span class="sxs-lookup"><span data-stu-id="24001-172">Members Section</span></span>
<span data-ttu-id="24001-173">È possibile definire statici o metodi di istanza, proprietà, le implementazioni dell'interfaccia, membri astratti, dichiarazioni di eventi e costruttori aggiuntivi in questa sezione.</span><span class="sxs-lookup"><span data-stu-id="24001-173">You can define static or instance methods, properties, interface implementations, abstract members, event declarations, and additional constructors in this section.</span></span> <span data-ttu-id="24001-174">Consentire ed effettuare associazioni non può trovarsi in questa sezione.</span><span class="sxs-lookup"><span data-stu-id="24001-174">Let and do bindings cannot appear in this section.</span></span> <span data-ttu-id="24001-175">Poiché è possibile aggiungere membri a una varietà di tipi F #, oltre alle classi, questi vengono illustrati in argomenti separati, [membri](members/index.md).</span><span class="sxs-lookup"><span data-stu-id="24001-175">Because members can be added to a variety of F# types in addition to classes, they are discussed in a separate topic, [Members](members/index.md).</span></span>


## <a name="mutually-recursive-types"></a><span data-ttu-id="24001-176">Tipi ricorsivi reciproci</span><span class="sxs-lookup"><span data-stu-id="24001-176">Mutually Recursive Types</span></span>
<span data-ttu-id="24001-177">Quando si definiscono i tipi che fanno riferimento a altro in modo circolare, unire le definizioni dei tipi utilizzando il `and` (parola chiave).</span><span class="sxs-lookup"><span data-stu-id="24001-177">When you define types that reference each other in a circular way, you string together the type definitions by using the `and` keyword.</span></span> <span data-ttu-id="24001-178">Il `and` (parola chiave) sostituisce il `type` parola chiave in tutti, ad eccezione della prima definizione, come indicato di seguito.</span><span class="sxs-lookup"><span data-stu-id="24001-178">The `and` keyword replaces the `type` keyword on all except the first definition, as follows.</span></span>

[!code-fsharp[Main](../../../samples/snippets/fsharp/lang-ref-1/snippet2404.fs)]

<span data-ttu-id="24001-179">L'output è un elenco di tutti i file nella directory corrente.</span><span class="sxs-lookup"><span data-stu-id="24001-179">The output is a list of all the files in the current directory.</span></span>


## <a name="when-to-use-classes-unions-records-and-structures"></a><span data-ttu-id="24001-180">Quando utilizzare strutture, unioni, record e classi</span><span class="sxs-lookup"><span data-stu-id="24001-180">When to Use Classes, Unions, Records, and Structures</span></span>
<span data-ttu-id="24001-181">Data la varietà di tipi tra cui scegliere, è necessario avere una buona conoscenza di ciò che è progettata per ogni tipo per selezionare il tipo appropriato per una determinata situazione.</span><span class="sxs-lookup"><span data-stu-id="24001-181">Given the variety of types to choose from, you need to have a good understanding of what each type is designed for to select the appropriate type for a particular situation.</span></span> <span data-ttu-id="24001-182">Classi sono progettate per l'utilizzo in contesti di programmazione orientata agli oggetti.</span><span class="sxs-lookup"><span data-stu-id="24001-182">Classes are designed for use in object-oriented programming contexts.</span></span> <span data-ttu-id="24001-183">Programmazione orientata a oggetti è il paradigma principale utilizzato nelle applicazioni che vengono scritti per .NET Framework.</span><span class="sxs-lookup"><span data-stu-id="24001-183">Object-oriented programming is the dominant paradigm used in applications that are written for the .NET Framework.</span></span> <span data-ttu-id="24001-184">Se il codice F # include a collaborare con .NET Framework o a un'altra libreria orientata agli oggetti, e in particolare se è necessario estendere da un sistema di tipo orientata agli oggetti, ad esempio una libreria dell'interfaccia utente, le classi sono probabilmente appropriate.</span><span class="sxs-lookup"><span data-stu-id="24001-184">If your F# code has to work closely with the .NET Framework or another object-oriented library, and especially if you have to extend from an object-oriented type system such as a UI library, classes are probably appropriate.</span></span>

<span data-ttu-id="24001-185">Se non si interagisce strettamente con il codice orientato o se si scrive codice che è indipendente e pertanto frequente interazione con codice orientata agli oggetti, si consiglia di utilizzare i record e unioni discriminate.</span><span class="sxs-lookup"><span data-stu-id="24001-185">If you are not interoperating closely with object-oriented code, or if you are writing code that is self-contained and therefore protected from frequent interaction with object-oriented code, you should consider using records and discriminated unions.</span></span> <span data-ttu-id="24001-186">Un singolo anche pensiero: out unione discriminata, insieme a codice, corrispondenza dei appropriato può spesso essere utilizzata come un'alternativa più semplice per una gerarchia di oggetti.</span><span class="sxs-lookup"><span data-stu-id="24001-186">A single, well thought–out discriminated union, together with appropriate pattern matching code, can often be used as a simpler alternative to an object hierarchy.</span></span> <span data-ttu-id="24001-187">Per ulteriori informazioni sulle unioni discriminate, vedere [unioni discriminate](discriminated-unions.md).</span><span class="sxs-lookup"><span data-stu-id="24001-187">For more information about discriminated unions, see [Discriminated Unions](discriminated-unions.md).</span></span>

<span data-ttu-id="24001-188">Record hanno il vantaggio di essere più semplice rispetto alle classi, ma non sono appropriati quando le richieste di un tipo superano ciò che può essere eseguita con la loro semplicità.</span><span class="sxs-lookup"><span data-stu-id="24001-188">Records have the advantage of being simpler than classes, but records are not appropriate when the demands of a type exceed what can be accomplished with their simplicity.</span></span> <span data-ttu-id="24001-189">I record sono fondamentalmente aggregazioni semplici di valori, senza costruttori distinti che possono eseguire azioni personalizzate, senza campi nascosti e senza implementazioni di interfaccia o di ereditarietà.</span><span class="sxs-lookup"><span data-stu-id="24001-189">Records are basically simple aggregates of values, without separate constructors that can perform custom actions, without hidden fields, and without inheritance or interface implementations.</span></span> <span data-ttu-id="24001-190">Sebbene ai record per rendere il proprio comportamento più complesso, è possibile aggiungere membri, ad esempio proprietà e metodi, i campi archiviati in un record sono comunque una semplice aggregazione di valori.</span><span class="sxs-lookup"><span data-stu-id="24001-190">Although members such as properties and methods can be added to records to make their behavior more complex, the fields stored in a record are still a simple aggregate of values.</span></span> <span data-ttu-id="24001-191">Per ulteriori informazioni sui record, vedere [record](records.md).</span><span class="sxs-lookup"><span data-stu-id="24001-191">For more information about records, see [Records](records.md).</span></span>

<span data-ttu-id="24001-192">Le strutture sono utili anche per piccole aggregazioni di dati, ma differiscono da classi e i record in quanto sono tipi di valore .NET.</span><span class="sxs-lookup"><span data-stu-id="24001-192">Structures are also useful for small aggregates of data, but they differ from classes and records in that they are .NET value types.</span></span> <span data-ttu-id="24001-193">Le classi e i record sono tipi di riferimento .NET.</span><span class="sxs-lookup"><span data-stu-id="24001-193">Classes and records are .NET reference types.</span></span> <span data-ttu-id="24001-194">La semantica dei tipi di valore e tipi di riferimento è diversi tipi di valore vengono passati per valore.</span><span class="sxs-lookup"><span data-stu-id="24001-194">The semantics of value types and reference types are different in that value types are passed by value.</span></span> <span data-ttu-id="24001-195">Ciò significa che vengono copiati bit per bit quando vengono passati come parametro o restituiti da una funzione.</span><span class="sxs-lookup"><span data-stu-id="24001-195">This means that they are copied bit for bit when they are passed as a parameter or returned from a function.</span></span> <span data-ttu-id="24001-196">Vengono anche archiviate nello stack o, se vengono usati come un campo, incorporato all'interno dell'oggetto padre anziché archiviati in una posizione separata nell'heap.</span><span class="sxs-lookup"><span data-stu-id="24001-196">They are also stored on the stack or, if they are used as a field, embedded inside the parent object instead of stored in their own separate location on the heap.</span></span> <span data-ttu-id="24001-197">Le strutture sono pertanto appropriate per i dati utilizzati di frequente quando l'overhead di accesso all'heap è un problema.</span><span class="sxs-lookup"><span data-stu-id="24001-197">Therefore, structures are appropriate for frequently accessed data when the overhead of accessing the heap is a problem.</span></span> <span data-ttu-id="24001-198">Per ulteriori informazioni sulle strutture, vedere [strutture](structures.md).</span><span class="sxs-lookup"><span data-stu-id="24001-198">For more information about structures, see [Structures](structures.md).</span></span>


## <a name="see-also"></a><span data-ttu-id="24001-199">Vedere anche</span><span class="sxs-lookup"><span data-stu-id="24001-199">See Also</span></span>
[<span data-ttu-id="24001-200">Riferimenti per il linguaggio F#</span><span class="sxs-lookup"><span data-stu-id="24001-200">F# Language Reference</span></span>](index.md)

[<span data-ttu-id="24001-201">Membri</span><span class="sxs-lookup"><span data-stu-id="24001-201">Members</span></span>](members/index.md)

[<span data-ttu-id="24001-202">Ereditarietà</span><span class="sxs-lookup"><span data-stu-id="24001-202">Inheritance</span></span>](inheritance.md)

[<span data-ttu-id="24001-203">Interfacce</span><span class="sxs-lookup"><span data-stu-id="24001-203">Interfaces</span></span>](interfaces.md)

